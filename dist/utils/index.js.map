{
  "version": 3,
  "sources": ["../../src/utils/config-merge.ts", "../../src/utils/date-timestamp.ts"],
  "sourcesContent": [
    "/**\n * Deep partial type for recursive partial application\n */\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n/**\n * Type guard to check if a value is a plain object\n */\nfunction isObject(item: unknown): item is Record<string, unknown> {\n  return Boolean(item && typeof item === 'object' && !Array.isArray(item) && !(item instanceof Date));\n}\n\n/**\n * Intelligently merge arrays based on object identity\n * For arrays of objects with 'name' property, merge by name\n * Otherwise, replace the array\n */\nfunction mergeArrays<T>(target: T[], source: T[]): T[] {\n  // Check if both arrays contain objects with 'name' property\n  const hasNamedObjects = target.every(item =>\n    isObject(item) && typeof (item as any).name === 'string'\n  ) && source.every(item =>\n    isObject(item) && typeof (item as any).name === 'string'\n  );\n\n  if (hasNamedObjects) {\n    // Merge by name property\n    const result = [...target];\n    const resultMap = new Map<string, number>();\n\n    // Create map of existing items by name\n    result.forEach((item, index) => {\n      resultMap.set((item as any).name, index);\n    });\n\n    // Merge or add source items\n    for (const sourceItem of source) {\n      const name = (sourceItem as any).name;\n      const existingIndex = resultMap.get(name);\n\n      if (existingIndex !== undefined) {\n        // Merge with existing item\n        result[existingIndex] = deepMerge(result[existingIndex] as object, sourceItem as object) as T;\n      } else {\n        // Add new item\n        result.push(sourceItem);\n        resultMap.set(name, result.length - 1);\n      }\n    }\n\n    return result;\n  }\n\n  // For other arrays, replace completely\n  return source;\n}\n\n/**\n * Modern performant deep merge utility using best practices\n * - Type-safe with proper generic constraints\n * - Handles nested objects recursively\n * - Intelligently merges arrays of named objects\n * - Excludes Date objects from deep merging\n */\nexport function deepMerge<T extends object>(target: T, ...sources: Array<DeepPartial<T>>): T {\n  if (!sources.length) return target;\n\n  const result = structuredClone(target);\n\n  for (const source of sources) {\n    if (!source) continue;\n\n    for (const key in source) {\n      const sourceValue = source[key];\n      const targetValue = result[key];\n\n      if (sourceValue === undefined) continue;\n\n      if (Array.isArray(sourceValue) && Array.isArray(targetValue)) {\n        // Intelligently merge arrays\n        (result as any)[key] = mergeArrays(targetValue, sourceValue);\n      } else if (isObject(sourceValue) && isObject(targetValue)) {\n        // Recursively merge nested objects\n        (result as any)[key] = deepMerge(targetValue as object, sourceValue as DeepPartial<object>);\n      } else {\n        // Direct assignment for primitives, dates, null, etc.\n        (result as any)[key] = sourceValue;\n      }\n    }\n  }\n\n  return result;\n}\n\n// Export types\nexport type { DeepPartial };\n",
    "/**\n * Get current timestamp in milliseconds\n */\nexport function getCurrentTimestamp(): number {\n  return Date.now();\n}\n\n/**\n * Add time to current timestamp\n */\nexport function addTimeToNow(timeInSeconds: number): number {\n  return getCurrentTimestamp() + (timeInSeconds * 1000);\n}\n\n/**\n * Check if timestamp is expired\n */\nexport function isExpired(expirationTimestamp: number): boolean {\n  return getCurrentTimestamp() > expirationTimestamp;\n}\n\n/**\n * Time constants for session management\n */\nexport const AUTH_SESSION_TTL = 60 * 60 * 24 * 15; // 15 days\nexport const AUTH_TOTP_PERIOD = 60 * 10; // 10 minutes\n"
  ],
  "mappings": ";AAUA,SAAS,QAAQ,CAAC,MAAgD;AAAA,EAChE,OAAO,QAAQ,QAAQ,OAAO,SAAS,aAAa,MAAM,QAAQ,IAAI,OAAO,gBAAgB,KAAK;AAAA;AAQpG,SAAS,WAAc,CAAC,QAAa,QAAkB;AAAA,EAErD,MAAM,kBAAkB,OAAO,MAAM,UACnC,SAAS,IAAI,KAAK,OAAQ,KAAa,SAAS,QAClD,KAAK,OAAO,MAAM,UAChB,SAAS,IAAI,KAAK,OAAQ,KAAa,SAAS,QAClD;AAAA,EAEA,IAAI,iBAAiB;AAAA,IAEnB,MAAM,SAAS,CAAC,GAAG,MAAM;AAAA,IACzB,MAAM,YAAY,IAAI;AAAA,IAGtB,OAAO,QAAQ,CAAC,MAAM,UAAU;AAAA,MAC9B,UAAU,IAAK,KAAa,MAAM,KAAK;AAAA,KACxC;AAAA,IAGD,WAAW,cAAc,QAAQ;AAAA,MAC/B,MAAM,OAAQ,WAAmB;AAAA,MACjC,MAAM,gBAAgB,UAAU,IAAI,IAAI;AAAA,MAExC,IAAI,kBAAkB,WAAW;AAAA,QAE/B,OAAO,iBAAiB,UAAU,OAAO,gBAA0B,UAAoB;AAAA,MACzF,EAAO;AAAA,QAEL,OAAO,KAAK,UAAU;AAAA,QACtB,UAAU,IAAI,MAAM,OAAO,SAAS,CAAC;AAAA;AAAA,IAEzC;AAAA,IAEA,OAAO;AAAA,EACT;AAAA,EAGA,OAAO;AAAA;AAUF,SAAS,SAA2B,CAAC,WAAc,SAAmC;AAAA,EAC3F,KAAK,QAAQ;AAAA,IAAQ,OAAO;AAAA,EAE5B,MAAM,SAAS,gBAAgB,MAAM;AAAA,EAErC,WAAW,UAAU,SAAS;AAAA,IAC5B,KAAK;AAAA,MAAQ;AAAA,IAEb,WAAW,OAAO,QAAQ;AAAA,MACxB,MAAM,cAAc,OAAO;AAAA,MAC3B,MAAM,cAAc,OAAO;AAAA,MAE3B,IAAI,gBAAgB;AAAA,QAAW;AAAA,MAE/B,IAAI,MAAM,QAAQ,WAAW,KAAK,MAAM,QAAQ,WAAW,GAAG;AAAA,QAE3D,OAAe,OAAO,YAAY,aAAa,WAAW;AAAA,MAC7D,EAAO,SAAI,SAAS,WAAW,KAAK,SAAS,WAAW,GAAG;AAAA,QAExD,OAAe,OAAO,UAAU,aAAuB,WAAkC;AAAA,MAC5F,EAAO;AAAA,QAEJ,OAAe,OAAO;AAAA;AAAA,IAE3B;AAAA,EACF;AAAA,EAEA,OAAO;AAAA;;AC1FF,SAAS,mBAAmB,GAAW;AAAA,EAC5C,OAAO,KAAK,IAAI;AAAA;AAMX,SAAS,YAAY,CAAC,eAA+B;AAAA,EAC1D,OAAO,oBAAoB,IAAK,gBAAgB;AAAA;AAM3C,SAAS,SAAS,CAAC,qBAAsC;AAAA,EAC9D,OAAO,oBAAoB,IAAI;AAAA;AAM1B,IAAM,mBAAmB,KAAK,KAAK,KAAK;AACxC,IAAM,mBAAmB,KAAK;",
  "debugId": "95C09E12FC93F7AF64756E2164756E21",
  "names": []
}