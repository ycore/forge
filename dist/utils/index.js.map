{"version":3,"file":"index.js","sources":["../../src/utils/config-merge.ts","../../src/utils/database/sqlite-db.ts","../../src/utils/database/migrate.ts","../../src/utils/date-timestamp.ts","../../../../node_modules/.bun/nanoid@5.1.6/node_modules/nanoid/url-alphabet/index.js","../../../../node_modules/.bun/nanoid@5.1.6/node_modules/nanoid/index.browser.js","../../src/utils/drizzle-helpers.ts"],"sourcesContent":["/**\n * Deep partial type for recursive partial application\n */\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n/**\n * Type guard to check if a value is a plain object\n */\nfunction isObject(item: unknown): item is Record<string, unknown> {\n  return Boolean(item && typeof item === 'object' && !Array.isArray(item) && !(item instanceof Date));\n}\n\n/**\n * Intelligently merge arrays based on object identity\n * For arrays of objects with 'name' property, merge by name\n * Otherwise, replace the array\n */\n// Type guard for objects with name property\nfunction hasNameProperty(obj: unknown): obj is { name: string } {\n  return isObject(obj) && typeof (obj as Record<string, unknown>).name === 'string';\n}\n\nfunction mergeArrays<T>(target: T[], source: T[]): T[] {\n  // Check if both arrays contain objects with 'name' property\n  const hasNamedObjects = target.every(hasNameProperty) && source.every(hasNameProperty);\n\n  if (hasNamedObjects) {\n    // Merge by name property\n    const result = [...target];\n    const resultMap = new Map<string, number>();\n\n    // Create map of existing items by name\n    result.forEach((item, index) => {\n      if (hasNameProperty(item)) {\n        resultMap.set(item.name, index);\n      }\n    });\n\n    // Merge or add source items\n    for (const sourceItem of source) {\n      if (!hasNameProperty(sourceItem)) continue;\n      const name = sourceItem.name;\n      const existingIndex = resultMap.get(name);\n\n      if (existingIndex !== undefined) {\n        // Merge with existing item\n        result[existingIndex] = deepMerge(result[existingIndex] as object, sourceItem as object) as T;\n      } else {\n        // Add new item\n        result.push(sourceItem);\n        resultMap.set(name, result.length - 1);\n      }\n    }\n\n    return result;\n  }\n\n  // For other arrays, replace completely\n  return source;\n}\n\n/**\n * Deep clone helper that preserves functions\n */\nfunction deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime()) as T;\n  if (Array.isArray(obj)) {\n    return obj.map(item => deepClone(item)) as T;\n  }\n  if (typeof obj === 'function') return obj;\n\n  const clonedObj = {} as T;\n  for (const key in obj) {\n    if (Object.hasOwn(obj, key)) {\n      clonedObj[key] = deepClone(obj[key]);\n    }\n  }\n  return clonedObj;\n}\n\n/**\n * Modern performant deep merge utility using best practices\n * - Type-safe with proper generic constraints\n * - Handles nested objects recursively\n * - Intelligently merges arrays of named objects\n * - Excludes Date objects from deep merging\n * - Preserves functions (for config callbacks)\n */\nexport function deepMerge<T extends object>(target: T, ...sources: Array<DeepPartial<T>>): T {\n  if (!sources.length) return target;\n\n  const result = deepClone(target);\n\n  for (const source of sources) {\n    if (!source) continue;\n\n    for (const key in source) {\n      const sourceValue = source[key];\n      const targetValue = result[key];\n\n      if (sourceValue === undefined) continue;\n\n      if (Array.isArray(sourceValue) && Array.isArray(targetValue)) {\n        // Intelligently merge arrays\n        (result as Record<string, unknown>)[key] = mergeArrays(targetValue, sourceValue);\n      } else if (isObject(sourceValue) && isObject(targetValue)) {\n        // Recursively merge nested objects\n        (result as Record<string, unknown>)[key] = deepMerge(targetValue as object, sourceValue as DeepPartial<object>);\n      } else {\n        // Direct assignment for primitives, dates, null, etc.\n        (result as Record<string, unknown>)[key] = sourceValue;\n      }\n    }\n  }\n\n  return result;\n}\n","import { getTableName, is, SQL } from 'drizzle-orm';\nimport { CasingCache } from 'drizzle-orm/casing';\nimport type { DrizzleD1Database } from 'drizzle-orm/d1';\nimport { getTableConfig, SQLiteBaseInteger, type SQLiteTable, type TableConfig } from 'drizzle-orm/sqlite-core';\n\n/**\n * SQLite database utilities for Cloudflare D1\n * Consolidates table management, migration, and seeding functionality\n */\n\n// Types\nexport interface DatabaseTableInfo {\n  schema: string;\n  name: string;\n}\n\nexport interface IndexDefinition {\n  table: string;\n  name: string;\n  columns: string[];\n  unique: boolean;\n  where?: SQL<unknown>;\n}\n\nexport interface TableSQLDefinition {\n  tableName: string;\n  schema: string;\n  createStatement: string;\n  indexStatements: string[];\n}\n\nexport interface BatchExecutionResult {\n  success: boolean;\n  results?: D1Result<unknown>[];\n  error?: string;\n}\n\n// Table Management\nexport async function getTableList(db: D1Database): Promise<DatabaseTableInfo[]> {\n  const result = await db.prepare('PRAGMA table_list').all();\n  return result.results\n    .filter(table => !['_cf_KV', '_cf_METADATA', 'sqlite_temp_schema'].includes(table.name as string))\n    .map(table => ({\n      schema: table.schema as string,\n      name: table.name as string,\n    }));\n}\n\nexport async function getDropTableStatements(db: D1Database): Promise<string[]> {\n  const tables = await getTableList(db);\n\n  return tables.filter(table => !['_cf_KV', 'sqlite_sequence', 'sqlite_schema', 'sqlite_temp_schema'].includes(table.name)).map(table => `DROP TABLE IF EXISTS \\`${table.name}\\`;`);\n}\n\nexport async function getClearTableStatements(db: D1Database): Promise<string[]> {\n  const tables = await getTableList(db);\n\n  return tables\n    .filter(table => !['_cf_KV', 'sqlite_sequence', 'sqlite_schema', 'sqlite_temp_schema'].includes(table.name))\n    .flatMap(table => [`DELETE FROM \\`${table.name}\\`;`, `UPDATE \\`sqlite_sequence\\` SET \\`seq\\` = 0 WHERE \\`name\\` = '${table.name}';`]);\n}\n\n// Table Creation from Drizzle Schema\nexport function generateTableSQL(table: SQLiteTable<TableConfig>): TableSQLDefinition {\n  const { name: tableName, columns, indexes, foreignKeys, uniqueConstraints } = getTableConfig(table);\n  const indexDefinitions: IndexDefinition[] = [];\n\n  // Generate column definitions\n  const columnDefinitions = columns.map(column => {\n    const parts = {\n      name: column.name,\n      type: column.getSQLType(),\n      notNull: column.notNull ? ' NOT NULL' : '',\n      primary: column.primary ? ' PRIMARY KEY' : '',\n      autoincrement: is(column, SQLiteBaseInteger) && column.autoIncrement ? ' AUTOINCREMENT' : '',\n      default: column.default ? (is(column.default, SQL) ? ` DEFAULT ${sqlToString(column.default)}` : ` DEFAULT '${column.default}'`) : '',\n    };\n\n    // Handle unique constraints on individual columns\n    if (column.isUnique && column.uniqueName) {\n      indexDefinitions.push({\n        table: tableName,\n        name: column.uniqueName,\n        columns: [column.name],\n        unique: true,\n      });\n    }\n\n    return `\\n  \\`${parts.name}\\` ${parts.type}${parts.primary}${parts.autoincrement}${parts.notNull}${parts.default}`;\n  });\n\n  // Generate index definitions\n  indexes.forEach(index => {\n    indexDefinitions.push({\n      table: tableName,\n      name: index.config.name,\n      columns: index.config.columns.map(col => (typeof col === 'object' && 'name' in col ? col.name : String(col))),\n      unique: index.config.unique ?? false,\n      where: index.config.where,\n    });\n  });\n\n  // Generate foreign key constraints\n  const foreignKeyDefinitions = foreignKeys.map(key => {\n    const reference = key.reference();\n    const onDelete = key.onDelete ? ` ON DELETE ${key.onDelete}` : '';\n    const onUpdate = key.onUpdate ? ` ON UPDATE ${key.onUpdate}` : '';\n    const columnsFrom = reference.columns.map(col => `\\`${col.name}\\``).join(',');\n    const columnsTo = reference.foreignColumns.map(col => `\\`${col.name}\\``).join(',');\n    const tableTo = getTableName(reference.foreignTable);\n\n    return `\\n  FOREIGN KEY (${columnsFrom}) REFERENCES \\`${tableTo}\\`(${columnsTo})${onUpdate}${onDelete}`;\n  });\n\n  // Generate unique constraints\n  const uniqueConstraintDefinitions = uniqueConstraints\n    .filter(constraint => constraint.name)\n    .map(constraint => {\n      const columns = constraint.columns.map(col => `\\`${col.name}\\``).join(',');\n\n      if (constraint.name) {\n        indexDefinitions.push({\n          table: tableName,\n          name: constraint.name,\n          columns: constraint.columns.map(col => col.name),\n          unique: true,\n        });\n      }\n\n      return `\\n  CONSTRAINT ${constraint.name} UNIQUE(${columns})`;\n    });\n\n  // Combine all table elements\n  const tableElements = [...columnDefinitions, ...foreignKeyDefinitions, ...uniqueConstraintDefinitions];\n  const createStatement = `CREATE TABLE \\`${tableName}\\` (${tableElements.join(',')}\\n);`;\n\n  // Generate index statements\n  const indexStatements = indexDefinitions.map(index => {\n    const indexType = index.unique ? 'UNIQUE INDEX' : 'INDEX';\n    const columns = index.columns.map(col => `\\`${col}\\``).join(',');\n    const whereClause = index.where ? ` WHERE ${index.where}` : '';\n\n    return `CREATE ${indexType} \\`${index.name}\\` ON \\`${index.table}\\` (${columns})${whereClause};`;\n  });\n\n  return { tableName, schema: '', createStatement, indexStatements };\n}\n\nexport function generateSchemaSQL(schema: Record<string, SQLiteTable<TableConfig>>): string[] {\n  const tables = Object.values(schema);\n  return tables.flatMap(table => {\n    const { createStatement, indexStatements } = generateTableSQL(table);\n    return [createStatement, ...indexStatements];\n  });\n}\n\n// Batch Execution\nexport async function executeBatch(db: D1Database, statements: string[]): Promise<BatchExecutionResult> {\n  if (statements.length === 0) {\n    return { success: true, results: [] };\n  }\n\n  const sqlStatements = ['PRAGMA defer_foreign_keys = on;', ...statements, 'PRAGMA defer_foreign_keys = off;'];\n\n  try {\n    const results = await db.batch(sqlStatements.map(sql => db.prepare(sql)));\n    return { success: true, results };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    return { success: false, error: errorMessage };\n  }\n}\n\n// Schema Operations\nexport async function migrateSchema(db: D1Database, schema: Record<string, SQLiteTable<TableConfig>>): Promise<BatchExecutionResult> {\n  const dropStatements = await getDropTableStatements(db);\n  const createStatements = generateSchemaSQL(schema);\n  const allStatements = [...dropStatements, ...createStatements];\n\n  return executeBatch(db, allStatements);\n}\n\nexport async function dropSchema(db: D1Database): Promise<BatchExecutionResult> {\n  const dropStatements = await getDropTableStatements(db);\n  return executeBatch(db, dropStatements);\n}\n\nexport async function clearSchema(db: D1Database): Promise<BatchExecutionResult> {\n  const clearStatements = await getClearTableStatements(db);\n  return executeBatch(db, clearStatements);\n}\n\n// Table-specific operations\nexport async function clearTable(db: D1Database, tableName: string): Promise<void> {\n  await db.exec(`DELETE FROM \\`${tableName}\\``);\n  await db.exec(`UPDATE sqlite_sequence SET seq = 0 WHERE name = '${tableName}'`);\n}\n\nexport async function seedTable<T extends Record<string, any>>(drizzleDb: DrizzleD1Database<any>, table: SQLiteTable<TableConfig>, data: T[], batchSize = 100): Promise<void> {\n  if (data.length === 0) return;\n\n  // Insert data in batches to avoid hitting limits\n  for (let i = 0; i < data.length; i += batchSize) {\n    const batch = data.slice(i, i + batchSize);\n    await drizzleDb.insert(table).values(batch);\n  }\n}\n\n// Utility functions\nfunction sqlToString(sql: SQL<unknown>): string {\n  return sql.toQuery({\n    escapeName: () => {\n      throw new Error('Escape name not supported for SQL default values');\n    },\n    escapeParam: () => {\n      throw new Error('Escape param not supported for SQL default values');\n    },\n    escapeString: () => {\n      throw new Error('Escape string not supported for SQL default values');\n    },\n    casing: new CasingCache(),\n  }).sql;\n}\n","import type { DrizzleD1Database } from 'drizzle-orm/d1';\nimport type { SQLiteTable, TableConfig } from 'drizzle-orm/sqlite-core';\n\nimport { type BatchExecutionResult, clearSchema, clearTable, dropSchema, migrateSchema, seedTable } from './sqlite-db';\n\n/**\n * Modern database migration utilities\n * All operations return structured results with proper error handling\n */\nexport interface MigrateOperations {\n  migrateSchema(db: D1Database, schema: Record<string, SQLiteTable<TableConfig>>): Promise<BatchExecutionResult>;\n  seedTable<T extends Record<string, any>>(drizzleDb: DrizzleD1Database<any>, table: SQLiteTable<TableConfig>, data: T[]): Promise<void>;\n  clearTable(db: D1Database, tableName: string): Promise<void>;\n  dropSchema(db: D1Database): Promise<BatchExecutionResult>;\n  clearSchema(db: D1Database): Promise<BatchExecutionResult>;\n}\n\nexport const migrate: MigrateOperations = { migrateSchema, seedTable, clearTable, dropSchema, clearSchema };\n","/**\n * Get current timestamp in milliseconds\n */\nexport function getCurrentTimestamp(): number {\n  return Date.now();\n}\n\n/**\n * Add time to current timestamp\n */\nexport function addTimeToNow(timeInSeconds: number): number {\n  return getCurrentTimestamp() + timeInSeconds * 1000;\n}\n\n/**\n * Check if timestamp is expired\n */\nexport function isExpired(expirationTimestamp: number): boolean {\n  return getCurrentTimestamp() > expirationTimestamp;\n}\n","export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","import { sql } from 'drizzle-orm';\nimport { integer, text } from 'drizzle-orm/sqlite-core';\nimport { nanoid } from 'nanoid';\n\nexport const cuid = (name = 'cuid') =>\n  text(name)\n    .notNull()\n    .unique()\n    .$defaultFn(() => nanoid());\n\nexport const timestamp = (name: string) => integer(name, { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`);\nexport const createdAt = timestamp('created_at');\nexport const updatedAt = timestamp('updated_at');\n"],"names":["columns","sql","scopedUrlAlphabet"],"mappings":"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","x_google_ignoreList":[4,5]}