{
  "version": 3,
  "sources": ["../../../src/markdown/server/markdown.$slug.server.tsx", "../../../src/adapters/cloudflare/context.server.ts", "../../../src/markdown/markdown-config.ts", "../../../src/markdown/utils.ts", "../../../src/markdown/markdown-data.ts", "../../../src/markdown/routes/markdown.tsx", "../../../src/markdown/server/markdown.server.ts"],
  "sourcesContent": [
    "import { redirect } from 'react-router';\nimport type { MarkdownLoaderArgs } from '../../@types/markdown.types';\nimport { CloudflareContext } from '../../adapters/cloudflare/context.server';\nimport { getMarkdownDocument } from '../markdown-data';\nimport { ROUTES_TEMPLATE } from '../routes/markdown';\n\n// Enhanced loader for Cloudflare Worker environments\nexport function createMarkdownSlugLoader() {\n  return async function markdownSlugLoader({ params, request, context }: MarkdownLoaderArgs & { params: Record<string, string | undefined> }) {\n    const slug = params['*'];\n\n    // Validate slug\n    if (!slug || typeof slug !== 'string' || slug.trim() === '') {\n      throw new Response('Invalid document slug', { status: 400 });\n    }\n\n    // Sanitize slug to prevent directory traversal (allow forward slashes for folder paths)\n    const sanitizedSlug = slug.replace(/[^a-zA-Z0-9-_/]/g, '');\n    if (sanitizedSlug !== slug) {\n      throw new Response('Invalid document slug format', { status: 400 });\n    }\n\n    // Prevent directory traversal attempts\n    if (sanitizedSlug.includes('..') || sanitizedSlug.startsWith('/') || sanitizedSlug.endsWith('/')) {\n      throw new Response('Invalid document slug format', { status: 400 });\n    }\n\n    // Get ASSETS binding from Cloudflare context\n    if (!context) {\n      throw new Response('Context is required for ASSETS binding', { status: 500 });\n    }\n\n    const contextValue = context.get(CloudflareContext);\n    console.log('markdownSlugLoader: Context check - contextValue:', !!contextValue, 'env:', !!contextValue?.env, 'ASSETS:', !!contextValue?.env?.ASSETS);\n\n    if (!contextValue || !contextValue.env) {\n      throw new Response('CloudflareContext not properly initialized', { status: 500 });\n    }\n\n    const { env } = contextValue;\n    if (!env.ASSETS) {\n      throw new Response('ASSETS binding not available', { status: 500 });\n    }\n\n    const url = new URL(request.url);\n    const isApiCall = url.searchParams.has('api') || request.headers.get('Accept')?.includes('application/json');\n\n    // Check if the document exists\n    const doc = await getMarkdownDocument(sanitizedSlug, env.ASSETS, request);\n    if (!doc) {\n      throw new Response('Document not found', { status: 404 });\n    }\n\n    // If it's an API call, return the document data\n    if (isApiCall) {\n      const enhancedFrontmatter = {\n        ...doc.frontmatter,\n        formattedDate: doc.frontmatter.date ? new Date(doc.frontmatter.date).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) : undefined,\n      };\n\n      return Response.json({ content: doc.content, frontmatter: enhancedFrontmatter, slug: sanitizedSlug });\n    }\n\n    // Otherwise, redirect to main docs page with fragment\n    return redirect(ROUTES_TEMPLATE.docs(sanitizedSlug));\n  };\n}\n",
    "import { unstable_createContext, type unstable_RouterContextProvider } from 'react-router';\n\nexport const CloudflareContext = unstable_createContext<{ env: Cloudflare.Env; ctx: ExecutionContext; cf?: RequestInitCfProperties }>({} as any);\n\nexport function getBindings(context: Readonly<unstable_RouterContextProvider>) {\n  return context.get(CloudflareContext).env;\n}\n\nexport function getExecutionContext(context: Readonly<unstable_RouterContextProvider>): ExecutionContext {\n  return context.get(CloudflareContext).ctx;\n}\n\nexport function getRequestProperties(context: Readonly<unstable_RouterContextProvider>): RequestInitCfProperties | undefined {\n  return context.get(CloudflareContext).cf;\n}\n\nexport function waitUntil<T>(context: Readonly<unstable_RouterContextProvider>, promise: Promise<T>) {\n  return getExecutionContext(context).waitUntil(promise);\n}\n\n",
    "// Central configuration for all markdown defaults and asset paths\nexport const MARKDOWN_CONFIG = {\n  EXTENSION: '.md',\n  CHUNK_BY_FOLDER: true,\n  INCREMENTAL_BY_FOLDER: false,\n  PREFIX: 'markdown',\n  PURIFY_HTML: true,\n  UPDATE_DATE: true,\n  COMPRESS: true,\n  CONCURRENCY: {\n    FOLDERS: 5,\n    FILES: 10,\n  },\n  CACHE: {\n    MAX_AGE: 3600, // 1 hour default\n  },\n} as const;\n\n// Central configuration for asset prefixes - change these to modify where markdown assets are stored/fetched\nexport const ASSET_PREFIX = {\n  build: '/assets/docs',  // Where assets are written during build (relative to /public)\n  fetch: '/assets/docs'   // URL prefix for fetching assets at runtime\n} as const;\n\n// DOMPurify configuration for markdown content\nexport const DOMPURIFY_CONFIG = {\n  ALLOWED_TAGS: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'br', 'strong', 'em', 'u', 's', 'del', 'a', 'img', 'ul', 'ol', 'li', 'blockquote', 'pre', 'code', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'hr', 'div', 'span'] as string[],\n  ALLOWED_ATTR: ['href', 'title', 'alt', 'src', 'class', 'id', 'start', 'type', 'colspan', 'rowspan', 'datetime', 'scope', 'data-*'] as string[],\n  FORBID_TAGS: ['script', 'object', 'embed', 'form', 'input', 'button', 'iframe', 'frame', 'frameset', 'noframes'] as string[],\n  FORBID_ATTR: ['style', 'on*'] as string[],\n  KEEP_CONTENT: true,\n  ALLOW_DATA_ATTR: false,\n};\n\n// Shiki highlighter configuration\nexport const HIGHLIGHTER_CONFIG = {\n  LANGS: ['javascript', 'typescript', 'css', 'html', 'bash', 'yaml', 'json', 'markdown'] as string[],\n  THEMES: ['night-owl'] as string[],\n};\n",
    "import { ASSET_PREFIX, MARKDOWN_CONFIG } from './markdown-config';\n\n/**\n * Determine if a file should use gzip compression based on filename and config\n */\nfunction shouldUseCompression(filename: string): boolean {\n  if (!MARKDOWN_CONFIG.COMPRESS) return false;\n\n  // Only compress content files, not manifest files\n  const isContentFile = filename.includes('content') && !filename.includes('manifest');\n  return isContentFile;\n}\n\n/**\n * Get the asset URL for fetching at runtime\n * @param filename - The filename to get the URL for\n * @param request - Optional request object for absolute URL generation\n * @returns Base URL where the file can be fetched at runtime (fetchContent will handle compression)\n */\nexport function getAssetUrl(filename: string, request?: Request): string {\n  const fetchPrefix = ASSET_PREFIX.fetch.endsWith('/') ? ASSET_PREFIX.fetch.slice(0, -1) : ASSET_PREFIX.fetch;\n\n  // Always return the base .json URL - fetchContent will handle .gz fallback internally\n  const url = `${fetchPrefix}/${filename}`;\n  return request ? new URL(url, request.url).href : url;\n}\n\n/**\n * Get the compressed file path based on compression format\n * @param basePath - The base file path\n * @param compression - The compression format ('brotli' | 'gzip' | null)\n * @returns File path with appropriate compression extension\n */\nexport function getCompressedFilePath(basePath: string, compression: 'brotli' | 'gzip' | null): string {\n  if (!compression) return basePath;\n  const ext = compression === 'brotli' ? '.br' : '.gz';\n  return `${basePath}${ext}`;\n}\n",
    "import type { GlobalManifest, MarkdownContent, MarkdownMeta } from '../@types/markdown.types';\nimport { getAssetUrl } from './utils';\n\n// Cache for loaded data to avoid multiple file reads\nlet manifestCache: MarkdownMeta[] | null = null;\nlet globalManifestCache: GlobalManifest | null = null;\nlet contentCache: Record<string, MarkdownContent> | null = null;\nconst folderContentCache: Map<string, Record<string, MarkdownContent>> = new Map();\n\n/**\n * Fetch JSON content with smart compression fallback\n * @param url - The URL to fetch from (should be the base .json URL)\n * @param assets - Cloudflare ASSETS binding for static asset serving\n * @returns Parsed JSON content\n */\nasync function fetchContent<T>(url: string, assets: Fetcher): Promise<T> {\n  console.log('fetchContent: Starting fetch for URL:', url);\n\n  // Use ASSETS binding for internal asset fetching\n  const fetchFn = (input: RequestInfo | URL, init?: RequestInit) => assets.fetch(input, init);\n\n  // Determine URLs for both compressed and uncompressed versions\n  const baseUrl = url.endsWith('.gz') ? url.replace('.gz', '') : url;\n  const gzUrl = baseUrl + '.gz';\n\n  // Try compressed version first\n  try {\n    console.log('fetchContent: Attempting compressed fetch:', gzUrl);\n    const gzResponse = await fetchFn(gzUrl);\n\n    if (gzResponse.ok) {\n      console.log('fetchContent: Compressed file found, attempting decompression');\n\n      // Decompress using Web Streams API\n      const compressedData = await gzResponse.arrayBuffer();\n      const decompressedStream = new DecompressionStream('gzip');\n      const decompressedResponse = new Response(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue(new Uint8Array(compressedData));\n            controller.close();\n          }\n        }).pipeThrough(decompressedStream)\n      );\n\n      const decompressedText = await decompressedResponse.text();\n      const parsed = JSON.parse(decompressedText) as T;\n      console.log('fetchContent: Successfully decompressed and parsed JSON');\n      return parsed;\n    }\n\n    console.log(`fetchContent: Compressed file not found (${gzResponse.status}), trying uncompressed`);\n\n  } catch (compressionError) {\n    console.warn('fetchContent: Compression attempt failed:', compressionError);\n  }\n\n  // Fallback to uncompressed version\n  try {\n    console.log('fetchContent: Attempting uncompressed fetch:', baseUrl);\n    const response = await fetchFn(baseUrl);\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const parsed = (await response.json()) as T;\n    console.log('fetchContent: Successfully fetched and parsed uncompressed file');\n    return parsed;\n  } catch (uncompressedError) {\n    const errorMsg = `Failed to fetch both compressed (${gzUrl}) and uncompressed (${baseUrl}) versions: ${uncompressedError instanceof Error ? uncompressedError.message : 'Unknown error'}`;\n    console.error('fetchContent: Final error:', errorMsg);\n    throw new Error(errorMsg);\n  }\n}\n\n/**\n * Get global manifest data which includes documents and chunking info\n */\nasync function getGlobalManifest(assets: Fetcher, request?: Request): Promise<GlobalManifest> {\n  if (globalManifestCache) {\n    return globalManifestCache;\n  }\n\n  try {\n    const manifestUrl = getAssetUrl('markdown-manifest.json', request);\n    console.log('Fetching global manifest from URL:', manifestUrl);\n    const globalManifest = await fetchContent<GlobalManifest>(manifestUrl, assets);\n    console.log('Successfully loaded global manifest with', globalManifest.documents.length, 'documents');\n    globalManifestCache = globalManifest;\n    return globalManifest;\n  } catch (error) {\n    console.error('Failed to load global manifest:', error);\n    return { documents: [], _buildMode: 'single' };\n  }\n}\n\n/**\n * Get markdown manifest data from generated JSON file\n * This reads from the consumer app's generated manifest file\n */\nexport async function getMarkdownManifest(assets: Fetcher, request?: Request): Promise<MarkdownMeta[]> {\n  if (manifestCache) {\n    return manifestCache;\n  }\n\n  const globalManifest = await getGlobalManifest(assets, request);\n\n  // Filter out build metadata for runtime use\n  const cleanManifest = globalManifest.documents.map(({ _mtime, _size, ...item }) => item);\n\n  manifestCache = cleanManifest;\n  return cleanManifest;\n}\n\n/**\n * Get markdown content data from generated JSON file\n * This reads from the consumer app's generated content file or folder chunks\n */\nexport async function getMarkdownContent(assets: Fetcher, request?: Request): Promise<Record<string, MarkdownContent>> {\n  const globalManifest = await getGlobalManifest(assets, request);\n\n  // In folder chunk mode, we don't preload all content\n  if (globalManifest._buildMode === 'chunked') {\n    // console.warn('getMarkdownContent() called in folder chunk mode. Use getMarkdownDocument() or loadFolderContent() instead.');\n    return {};\n  }\n\n  if (contentCache) {\n    return contentCache;\n  }\n\n  try {\n    const contentUrl = getAssetUrl('markdown-content.json', request);\n    const content = await fetchContent<Record<string, MarkdownContent>>(contentUrl, assets);\n    contentCache = content;\n    return content;\n  } catch (_error) {\n    // console.warn('Failed to load markdown content:', error);\n    return {};\n  }\n}\n\n/**\n * Load content for a specific folder (lazy loading)\n */\nexport async function loadFolderContent(folder: string, assets: Fetcher, request?: Request): Promise<Record<string, MarkdownContent>> {\n  console.log('loadFolderContent: Loading content for folder:', folder);\n\n  // Check cache first\n  if (folderContentCache.has(folder)) {\n    const cachedContent = folderContentCache.get(folder);\n    if (cachedContent) {\n      console.log('loadFolderContent: Found cached content for folder:', folder);\n      return cachedContent;\n    }\n  }\n\n  try {\n    const folderKey = folder.replace(/[/\\\\]/g, '-');\n    const contentUrl = getAssetUrl(`markdown-content-${folderKey}.json`, request);\n    console.log('loadFolderContent: Generated content URL:', contentUrl, 'for folder:', folder);\n\n    const content = await fetchContent<Record<string, MarkdownContent>>(contentUrl, assets);\n    console.log('loadFolderContent: Successfully loaded content with', Object.keys(content).length, 'documents for folder:', folder);\n    folderContentCache.set(folder, content);\n    return content;\n  } catch (error) {\n    console.error(`loadFolderContent: Failed to load folder content for ${folder}:`, error);\n    return {};\n  }\n}\n\n/**\n * Get all documents for a specific folder\n */\nexport async function getFolderDocuments(folder: string, assets: Fetcher, request?: Request): Promise<MarkdownContent[]> {\n  const content = await loadFolderContent(folder, assets, request);\n  return Object.values(content);\n}\n\n/**\n * Get a specific markdown document by slug\n */\nexport async function getMarkdownDocument(slug: string, assets: Fetcher, request?: Request): Promise<MarkdownContent | null> {\n  const globalManifest = await getGlobalManifest(assets, request);\n\n  // In folder chunk mode, we need to determine which folder the document is in\n  if (globalManifest._buildMode === 'chunked') {\n    const manifest = await getMarkdownManifest(assets, request);\n    const docMeta = manifest.find(doc => doc.slug === slug);\n\n    if (!docMeta || !docMeta.folder) {\n      return null;\n    }\n\n    const folderContent = await loadFolderContent(docMeta.folder, assets, request);\n    return folderContent[slug] || null;\n  }\n\n  // Fallback to traditional mode\n  const content = await getMarkdownContent(assets, request);\n  return content[slug] || null;\n}\n\n/**\n * Clear the cache (useful for testing or hot reload)\n */\nexport function clearMarkdownCache(): void {\n  manifestCache = null;\n  globalManifestCache = null;\n  contentCache = null;\n  folderContentCache.clear();\n}\n\n/**\n * Clear cache for a specific folder\n */\nexport function clearFolderCache(folder: string): void {\n  folderContentCache.delete(folder);\n}\n\n/**\n * Preload content for multiple folders\n */\nexport async function preloadFolders(folders: string[], assets: Fetcher, request?: Request): Promise<void> {\n  await Promise.all(folders.map(folder => loadFolderContent(folder, assets, request)));\n}\n\n/**\n * Check if a document exists by slug\n */\nexport async function hasMarkdownDocument(slug: string, assets: Fetcher, request?: Request): Promise<boolean> {\n  const globalManifest = await getGlobalManifest(assets, request);\n\n  if (globalManifest._buildMode === 'chunked') {\n    const manifest = await getMarkdownManifest(assets, request);\n    return manifest.some(doc => doc.slug === slug);\n  }\n\n  const content = await getMarkdownContent(assets, request);\n  return slug in content;\n}\n\n/**\n * Get documents by folder with pagination support\n */\nexport async function getFolderDocumentsPaginated(folder: string, offset = 0, limit = 10, assets: Fetcher, request?: Request): Promise<{ documents: MarkdownMeta[]; total: number; hasMore: boolean }> {\n  const manifest = await getMarkdownManifest(assets, request);\n  const folderDocs = manifest.filter(doc => doc.folder === folder);\n  const total = folderDocs.length;\n  const paginatedDocs = folderDocs.slice(offset, offset + limit);\n\n  return {\n    documents: paginatedDocs,\n    total,\n    hasMore: offset + limit < total,\n  };\n}\n\n/**\n * Get all unique folders from manifest\n */\nexport async function getAllFolders(assets: Fetcher, request?: Request): Promise<string[]> {\n  const manifest = await getMarkdownManifest(assets, request);\n  const folders = new Set<string>();\n\n  manifest.forEach(doc => {\n    if (doc.folder) {\n      folders.add(doc.folder);\n    }\n  });\n\n  return Array.from(folders).sort();\n}\n\n/**\n * Get the current build mode from the manifest\n */\nexport async function getBuildMode(assets: Fetcher, request?: Request): Promise<'single' | 'chunked'> {\n  const globalManifest = await getGlobalManifest(assets, request);\n  return globalManifest._buildMode;\n}\n",
    "/** biome-ignore-all lint/a11y/noSvgWithoutTitle: acceptable */\nimport { SpriteIcon } from '@ycore/componentry/images';\nimport type { Themes } from '@ycore/componentry/impetus';\nimport { LoadingBar, ThemeSwitch } from '@ycore/componentry/impetus';\nimport { type IconName, Link } from '@ycore/componentry/shadcn-ui';\nimport clsx from 'clsx';\nimport { memo, useCallback, useEffect, useState } from 'react';\nimport { useFetcher, useLocation } from 'react-router';\nimport type { DocContent, EnhancedMarkdownMeta, MarkdownPageProps } from '../../@types/markdown.types';\nimport { Markdown } from '../markdown-loader';\n\n// Type guard\nconst isDocContent = (data: unknown): data is DocContent => {\n  return typeof data === 'object' && data !== null && 'content' in data && 'frontmatter' in data && 'slug' in data;\n};\n\nexport const ROUTES_TEMPLATE = {\n  docs: (slug: string) => `/docs#${slug}`,\n  docsApi: (slug: string) => `/docs/${slug}?api`,\n};\n\n// Client-side React component for displaying markdown documentation\n\nexport function MarkdownPage({ loaderData, spriteUrl, themeContext }: MarkdownPageProps) {\n  const docs = loaderData;\n  const location = useLocation();\n  const [selectedDoc, setSelectedDoc] = useState<string | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);\n  const [mounted, setMounted] = useState(false);\n  const fetcher = useFetcher();\n\n  useEffect(() => setMounted(true), []);\n\n  const handleDocSelect = useCallback(\n    (slug: string) => {\n      if (selectedDoc === slug) return;\n      setSelectedDoc(slug);\n      setError(null);\n      fetcher.load(ROUTES_TEMPLATE.docsApi(slug));\n      window.history.replaceState(null, '', ROUTES_TEMPLATE.docs(slug));\n    },\n    [fetcher.load, selectedDoc]\n  );\n\n  // Initialize from URL hash on mount only\n  useEffect(() => {\n    const hash = location.hash.slice(1);\n    if (hash && docs.find((doc: EnhancedMarkdownMeta) => doc.slug === hash) && !selectedDoc) {\n      setSelectedDoc(hash);\n      fetcher.load(ROUTES_TEMPLATE.docsApi(hash));\n    }\n  }, [docs, fetcher.load, selectedDoc, location.hash.slice]);\n\n  // Handle browser back/forward navigation\n  useEffect(() => {\n    const handlePopState = () => {\n      const hash = window.location.hash.slice(1);\n      if (hash && docs.find((doc: EnhancedMarkdownMeta) => doc.slug === hash)) {\n        setSelectedDoc(hash);\n        setError(null);\n        fetcher.load(ROUTES_TEMPLATE.docsApi(hash));\n      } else {\n        setSelectedDoc(null);\n        setError(null);\n      }\n    };\n\n    window.addEventListener('popstate', handlePopState);\n    return () => window.removeEventListener('popstate', handlePopState);\n  }, [docs, fetcher.load]);\n\n  // Handle fetch errors\n  useEffect(() => {\n    if (fetcher.state === 'idle' && fetcher.data && !isDocContent(fetcher.data)) {\n      setError('Failed to load document');\n    }\n  }, [fetcher.state, fetcher.data]);\n\n  const currentDoc = isDocContent(fetcher.data) ? fetcher.data : undefined;\n\n  return (\n    <div className=\"min-h-screen bg-white transition-colors dark:bg-gray-900\">\n      <div className=\"flex\">\n        {/* Sidebar */}\n        <aside\n          className={`fixed inset-y-0 top-0 left-0 z-20 overflow-y-auto border-gray-200 border-r bg-white transition-transform duration-300 dark:border-gray-800 dark:bg-gray-900 ${sidebarCollapsed ? '-translate-x-full' : 'translate-x-0'} w-80`}\n        >\n          <div className=\"p-6\">\n            <div className=\"mb-6 flex items-center justify-between\">\n              <h2 className=\"font-semibold text-gray-900 text-lg dark:text-white\">Documentation</h2>\n              <div>\n                <button type=\"button\" onClick={() => setSidebarCollapsed(!sidebarCollapsed)} className=\"rounded-md p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200\">\n                  <SpriteIcon<IconName> url={spriteUrl} id=\"ChevronLeft\" className=\"h-5 w-5\" />\n                </button>\n              </div>\n            </div>\n            <nav className=\"space-y-1\" aria-label=\"Documentation navigation\">\n              {docs.length === 0 ? <DocListEmpty /> : <DocList docs={docs} selectedDoc={selectedDoc} onDocSelect={handleDocSelect} spriteUrl={spriteUrl} />}\n            </nav>\n            <div className=\"fixed right-4 bottom-4 z-10 flex items-center justify-between gap-x-4\">\n              <Link href=\"/\">\n                <SpriteIcon<IconName> url={spriteUrl} id=\"House\" className=\"size-5 text-accent-foreground\" viewBox=\"0 0 24 24\" />\n              </Link>\n              {!mounted ? (\n                <div className=\"size-5\" />\n              ) : (\n                <ThemeSwitch spriteUrl={spriteUrl}>\n                  {themeContext\n                    ? ({ theme }: { theme: Themes }) => (\n                      <button\n                        type=\"button\"\n                        className=\"size-5 hover:animate-rotate\"\n                        aria-label=\"theme switch\"\n                        onClick={() => {\n                          themeContext.setTheme(themeContext.resolvedTheme === theme.theme.dark ? theme.theme.light : theme.theme.dark);\n                        }}\n                      >\n                        {themeContext.resolvedTheme === theme.theme.dark ? <SpriteIcon url={spriteUrl} id=\"Moon\" className=\"size-5\" /> : <SpriteIcon url={spriteUrl} id=\"Sun\" className=\"size-5\" />}\n                      </button>\n                    )\n                    : undefined}\n                </ThemeSwitch>\n              )}\n            </div>\n          </div>\n        </aside>\n\n        {/* Sidebar toggle button - visible when sidebar is collapsed */}\n        <button\n          type=\"button\"\n          onClick={() => setSidebarCollapsed(false)}\n          className={`fixed top-4 left-4 z-30 rounded-md border border-gray-200 bg-white p-2 text-gray-500 shadow-sm transition-opacity duration-300 hover:text-gray-700 dark:border-gray-800 dark:bg-gray-900 dark:text-gray-400 dark:hover:text-gray-200 ${sidebarCollapsed ? 'opacity-100' : 'pointer-events-none opacity-0'}`}\n        >\n          <SpriteIcon<IconName> url={spriteUrl} id=\"EllipsisVertical\" className=\"h-5 w-5\" />\n        </button>\n\n        {/* Main content */}\n        <main className={`flex-1 transition-all duration-300 ${sidebarCollapsed ? 'pl-0' : 'pl-64'} min-w-0`}>\n          <div className=\"mx-auto min-w-0 max-w-4xl px-4 md:px-8\">\n            {!selectedDoc ? (\n              <div className=\"flex h-96 items-center justify-center\">\n                <div className=\"text-center\">\n                  <div className=\"mb-4 text-gray-400 dark:text-gray-500\">\n                    <SpriteIcon<IconName> url={spriteUrl} id=\"CircleAlert\" className=\"h-8 w-8\" />\n                  </div>\n                  <h3 className=\"mb-2 font-medium text-gray-900 text-lg dark:text-white\">Select a document</h3>\n                  <p className=\"text-gray-500 dark:text-gray-400\">Choose a document from the sidebar to view its content.</p>\n                </div>\n              </div>\n            ) : fetcher.state === 'loading' ? (\n              <LoadingBar />\n            ) : error ? (\n              <DocumentNotFound spriteUrl={spriteUrl} />\n            ) : currentDoc ? (\n              <article className=\"markdown-content min-w-0 py-8 md:py-12\">\n                <DocumentHeader frontmatter={currentDoc.frontmatter} />\n                <Markdown className=\"min-w-0 max-w-none\">{currentDoc.content}</Markdown>\n              </article>\n            ) : (\n              <DocumentNotFound spriteUrl={spriteUrl} />\n            )}\n          </div>\n        </main>\n      </div>\n    </div>\n  );\n}\n\nconst DocListEmpty = () => {\n  return <p className=\"text-gray-500 text-sm dark:text-gray-400\">No documentation found.</p>;\n};\n\n// Memoized components\n// const LoadingBar = memo(() => <div className=\"loading-bar\" />);\n\nconst DocumentNotFound = memo(({ spriteUrl }: { spriteUrl: string }) => (\n  <div className=\"flex h-96 items-center justify-center\">\n    <div className=\"text-center\">\n      <div className=\"mb-4 text-red-400 dark:text-red-500\">\n        <SpriteIcon<IconName> url={spriteUrl} id=\"CircleAlert\" className=\"mx-auto h-8 w-8\" />\n      </div>\n      <h3 className=\"mb-2 font-medium text-gray-900 text-lg dark:text-white\">Document not found</h3>\n      <p className=\"text-gray-500 dark:text-gray-400\">The selected document could not be loaded.</p>\n    </div>\n  </div>\n));\n\nconst DocumentHeader = memo(({ frontmatter }: { frontmatter: Record<string, any> }) => (\n  <header className=\"mb-8\">\n    {frontmatter.title && <h1 className=\"mb-4 font-bold font-serif text-3xl text-gray-900 dark:text-white\">{frontmatter.title}</h1>}\n    {frontmatter.description && <p className=\"mb-4 font-serif text-gray-600 text-lg dark:text-gray-300\">{frontmatter.description}</p>}\n    {(frontmatter.formattedDate || frontmatter.version) && (\n      <div className=\"flex items-center justify-between text-gray-500 text-sm dark:text-gray-400\">\n        {frontmatter.formattedDate && (\n          <time className=\"font-sans\" dateTime={frontmatter.date}>\n            {frontmatter.formattedDate}\n          </time>\n        )}\n        {frontmatter.version && <span className=\"px-2 py-1 font-mono text-gray-300 text-xs italic dark:text-gray-600\">{frontmatter.version}</span>}\n      </div>\n    )}\n  </header>\n));\n\nconst DocList = memo(({ docs, selectedDoc, onDocSelect, spriteUrl }: { docs: EnhancedMarkdownMeta[]; selectedDoc: string | null; onDocSelect: (slug: string) => void; spriteUrl: string }) => {\n  // Group documents by folder and track which is first in each folder\n  const groupedDocs = useCallback(() => {\n    const groups: { [folder: string]: EnhancedMarkdownMeta[] } = {};\n\n    for (const doc of docs) {\n      const folder = doc.folder || '';\n      if (!groups[folder]) {\n        groups[folder] = [];\n      }\n      groups[folder].push(doc);\n    }\n\n    return groups;\n  }, [docs]);\n\n  const groups = groupedDocs();\n\n  return (\n    <div className=\"space-y-1\">\n      {Object.entries(groups).map(([folder, folderDocs]) => {\n        const isRootLevel = folder === '';\n        const folderId = `folder-${folder.replace(/[^a-zA-Z0-9]/g, '-')}`;\n\n        return (\n          <div key={folder || 'root'}>\n            {!isRootLevel && (\n              <div className=\"relative\">\n                <input type=\"checkbox\" id={folderId} className=\"peer hidden\" defaultChecked={true} />\n                <label htmlFor={folderId} className=\"flex w-full cursor-pointer items-center px-3 py-2 text-left text-gray-600 text-sm transition-colors hover:bg-gray-50 dark:text-gray-400 dark:hover:bg-gray-800/50\">\n                  <SpriteIcon<IconName> url={spriteUrl} id=\"ChevronRight\" className=\"mr-2 h-3 w-3 transition-transform duration-200 peer-checked:rotate-90\" />\n                  <span className=\"font-medium capitalize\">{folder}</span>\n                </label>\n\n                <div className=\"ml-6 max-h-0 space-y-0.5 overflow-hidden transition-all duration-300 peer-checked:max-h-96\">\n                  {folderDocs.map(doc => (\n                    <button\n                      key={doc.slug}\n                      type=\"button\"\n                      onClick={() => onDocSelect(doc.slug)}\n                      className={clsx(\n                        'w-full px-3 py-2 text-left text-sm transition-colors focus:outline-none',\n                        selectedDoc === doc.slug\n                          ? 'border-blue-500 border-r-2 bg-blue-50 text-blue-900 dark:border-blue-400 dark:bg-blue-900/20 dark:text-blue-100'\n                          : 'text-gray-700 hover:bg-gray-50 dark:text-gray-300 dark:hover:bg-gray-800/50'\n                      )}\n                    >\n                      <div className=\"flex items-center\">\n                        <div className=\"flex-1\">\n                          <div className=\"font-medium\">{doc.title || doc.slug}</div>\n                        </div>\n                      </div>\n                    </button>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {isRootLevel && (\n              <div className=\"space-y-0.5\">\n                {folderDocs.map(doc => (\n                  <button\n                    key={doc.slug}\n                    type=\"button\"\n                    onClick={() => onDocSelect(doc.slug)}\n                    className={clsx(\n                      'w-full px-3 py-2 text-left text-sm transition-colors focus:outline-none',\n                      selectedDoc === doc.slug\n                        ? 'border-blue-500 border-r-2 bg-blue-50 text-blue-900 dark:border-blue-400 dark:bg-blue-900/20 dark:text-blue-100'\n                        : 'text-gray-700 hover:bg-gray-50 dark:text-gray-300 dark:hover:bg-gray-800/50'\n                    )}\n                  >\n                    <div className=\"font-medium\">{doc.title || doc.slug}</div>\n                  </button>\n                ))}\n              </div>\n            )}\n          </div>\n        );\n      })}\n    </div>\n  );\n});\n",
    "import type { EnhancedMarkdownMeta, MarkdownLoaderArgs } from '../../@types/markdown.types';\nimport { CloudflareContext } from '../../adapters/cloudflare/context.server';\nimport { getMarkdownManifest } from '../markdown-data';\n\n// Enhanced loader for Cloudflare Worker environments\nexport function createMarkdownLoader() {\n  return async function markdownLoader({ request, context }: MarkdownLoaderArgs): Promise<EnhancedMarkdownMeta[]> {\n    try {\n      console.log('markdownLoader: Starting manifest fetch for request URL:', request.url);\n\n      // Get ASSETS binding from Cloudflare context\n      if (!context) {\n        throw new Error('Context is required for ASSETS binding');\n      }\n\n      const contextValue = context.get(CloudflareContext);\n      console.log('markdownLoader: Context check - contextValue:', !!contextValue, 'env:', !!contextValue?.env, 'ASSETS:', !!contextValue?.env?.ASSETS);\n      \n      if (!contextValue || !contextValue.env) {\n        throw new Error('CloudflareContext not properly initialized');\n      }\n      \n      const { env } = contextValue;\n      if (!env.ASSETS) {\n        throw new Error('ASSETS binding not available');\n      }\n\n      console.log('markdownLoader: Using ASSETS binding for asset fetching');\n      const manifest = await getMarkdownManifest(env.ASSETS, request);\n      console.log('markdownLoader: Successfully loaded manifest with', manifest.length, 'documents');\n      return manifest as EnhancedMarkdownMeta[];\n    } catch (error) {\n      console.error('markdownLoader: Failed to load manifest:', error);\n      console.error('markdownLoader: Request URL was:', request.url);\n      // Return empty array so the UI can show \"No documentation found\" instead of crashing\n      return [];\n    }\n  };\n}"
  ],
  "mappings": "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",
  "debugId": "E9E487A70AEF51E964756E2164756E21",
  "names": []
}