var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js
import * as React63 from "react";
var require_use_sync_external_store_shim_production = __commonJS((exports) => {
  function is(x2, y) {
    return x2 === y && (x2 !== 0 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
  }
  var objectIs = typeof Object.is === "function" ? Object.is : is;
  var useState18 = React63.useState;
  var useEffect32 = React63.useEffect;
  var useLayoutEffect5 = React63.useLayoutEffect;
  var useDebugValue = React63.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState18({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    useLayoutEffect5(function() {
      inst.value = value;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceUpdate({ inst });
    }, [subscribe, value, getSnapshot]);
    useEffect32(function() {
      checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      return subscribe(function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      });
    }, [subscribe]);
    useDebugValue(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim = typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined" ? useSyncExternalStore$1 : useSyncExternalStore$2;
  exports.useSyncExternalStore = React63.useSyncExternalStore !== undefined ? React63.useSyncExternalStore : shim;
});

// ../../node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS((exports, module) => {
  if (true) {
    module.exports = require_use_sync_external_store_shim_production();
  } else {}
});

// ../componentry/dist/images/index.js
import clsx22 from "clsx";
import React2 from "react";
import { Await as Await2 } from "react-router";
import clsx3 from "clsx";

// ../componentry/src/images/LazyImage.tsx
import clsx2 from "clsx";
import React from "react";
import { Await } from "react-router";

// ../componentry/src/shadcn-ui/components/spinner.tsx
import clsx from "clsx";

// ../componentry/src/vibrant/components/svg-icon.tsx
var SvgIcon = createSpriteIcon("lucide");

// ../componentry/src/shadcn-ui/components/spinner.tsx
import { jsx } from "react/jsx-runtime";

// ../componentry/src/images/LazyImage.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
// ../componentry/src/images/SpriteIconProvider.tsx
import { createContext, useContext } from "react";
import { jsx as jsx3 } from "react/jsx-runtime";
var SpriteIconContext = createContext(null);
function useSpriteIcon(spriteKey) {
  const config = useContext(SpriteIconContext);
  if (!config) {
    throw new Error("useSpriteIcon must be used within a SpriteIconProvider. " + "Wrap your app with <SpriteIconProvider sprites={{...}}>.");
  }
  if (!config[spriteKey]) {
    throw new Error(`Sprite key "${spriteKey}" not found in SpriteIconProvider. ` + `Available keys: ${Object.keys(config).join(", ")}`);
  }
  return config[spriteKey];
}

// ../componentry/src/images/SpriteIcon.tsx
import { jsx as jsx4 } from "react/jsx-runtime";
function SpriteIcon({ spriteUrl, iconId, ...props }) {
  return /* @__PURE__ */ jsx4("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    ...props,
    children: iconId ? /* @__PURE__ */ jsx4("use", {
      href: `${spriteUrl}#${iconId}`
    }) : /* @__PURE__ */ jsx4("use", {
      href: `${spriteUrl}`
    })
  });
}
function createSpriteIcon(spriteKey) {
  return function SpriteIconComponent({ iconId, ...props }) {
    const spriteUrl = useSpriteIcon(spriteKey);
    return /* @__PURE__ */ jsx4(SpriteIcon, {
      spriteUrl,
      iconId,
      ...props
    });
  };
}
// ../componentry/dist/images/index.js
import { jsx as jsx5 } from "react/jsx-runtime";
import { jsx as jsx22 } from "react/jsx-runtime";
import { createContext as createContext2, useContext as useContext2 } from "react";
import { jsx as jsx32 } from "react/jsx-runtime";
import { jsx as jsx42 } from "react/jsx-runtime";
var SvgIcon2 = createSpriteIcon("lucide");
var SpriteIconContext2 = createContext2(null);
function SpriteIcon2({ spriteUrl, iconId, ...props }) {
  return /* @__PURE__ */ jsx42("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    ...props,
    children: iconId ? /* @__PURE__ */ jsx42("use", {
      href: `${spriteUrl}#${iconId}`
    }) : /* @__PURE__ */ jsx42("use", {
      href: `${spriteUrl}`
    })
  });
}

// ../componentry/dist/impetus/index.js
import * as React8 from "react";
import { href, isRouteErrorResponse, Link, useRouteError } from "react-router";
import { jsx as jsx6, jsxs } from "react/jsx-runtime";
import clsx5 from "clsx";
import { memo } from "react";
import { jsx as jsx23 } from "react/jsx-runtime";
import clsx52 from "clsx";
import { createContext as createContext6, useState as useState16 } from "react";
import { useLocation } from "react-router";
import * as React22 from "react";
import * as React3 from "react";
import { Fragment as Fragment2, jsx as jsx33 } from "react/jsx-runtime";

// ../../node_modules/class-variance-authority/dist/index.mjs
import { clsx as clsx4 } from "clsx";
var falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
var cx = clsx4;
var cva = (base, config) => (props) => {
  var _config_compoundVariants;
  if ((config === null || config === undefined ? undefined : config.variants) == null)
    return cx(base, props === null || props === undefined ? undefined : props.class, props === null || props === undefined ? undefined : props.className);
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === undefined ? undefined : props[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === undefined ? undefined : defaultVariants[variant];
    if (variantProp === null)
      return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
    let [key, value] = param;
    if (value === undefined) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config === null || config === undefined ? undefined : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === undefined ? undefined : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value] = param2;
      return Array.isArray(value) ? value.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === undefined ? undefined : props.class, props === null || props === undefined ? undefined : props.className);
};

// ../componentry/dist/impetus/index.js
import clsx23 from "clsx";
import { jsx as jsx43 } from "react/jsx-runtime";
import * as React35 from "react";
import React4 from "react";
import * as React32 from "react";
import { jsx as jsx52 } from "react/jsx-runtime";
import { jsx as jsx62 } from "react/jsx-runtime";
import React222 from "react";
import { jsx as jsx222 } from "react/jsx-runtime";
import * as React5 from "react";
import { jsx as jsx7 } from "react/jsx-runtime";
import * as React7 from "react";
import * as React6 from "react";
import * as React34 from "react";
import * as React12 from "react";
import * as React9 from "react";
import { jsx as jsx8 } from "react/jsx-runtime";
import * as React10 from "react";
import * as React11 from "react";
import { jsx as jsx9 } from "react/jsx-runtime";
import * as React13 from "react";
import * as React14 from "react";
import { jsx as jsx10 } from "react/jsx-runtime";
import * as React18 from "react";
import * as React15 from "react";
import { useLayoutEffect as useLayoutEffect3 } from "react";
import * as React16 from "react";
import { jsx as jsx11 } from "react/jsx-runtime";
import * as React17 from "react";
import { jsx as jsx12 } from "react/jsx-runtime";
import * as React19 from "react";
import { jsx as jsx13 } from "react/jsx-runtime";
import * as React23 from "react";
import * as React20 from "react";
import * as React25 from "react";
import * as React21 from "react";
import * as React24 from "react";
import { jsx as jsx14 } from "react/jsx-runtime";
import * as React33 from "react";
import * as React29 from "react";
import { useState as useState112 } from "react";
import * as React27 from "react";
import * as React28 from "react";
import * as React322 from "react";
import * as React31 from "react";
import * as React30 from "react";
import { jsx as jsx15 } from "react/jsx-runtime";
import { jsx as jsx16 } from "react/jsx-runtime";
import clsx32 from "clsx";
import { jsx as jsx17, jsxs as jsxs2 } from "react/jsx-runtime";
import * as React36 from "react";
import { Fragment as Fragment7, jsx as jsx18, jsxs as jsxs3 } from "react/jsx-runtime";
import clsx42 from "clsx";
import { jsx as jsx19, jsxs as jsxs4 } from "react/jsx-runtime";
import React37 from "react";
import { Link as RouterLink } from "react-router";
import { jsx as jsx20 } from "react/jsx-runtime";
import { jsx as jsx21, jsxs as jsxs5, Fragment as Fragment8 } from "react/jsx-runtime";
import clsx6 from "clsx";
import { jsx as jsx232 } from "react/jsx-runtime";
var __create2 = Object.create;
var __getProtoOf2 = Object.getPrototypeOf;
var __defProp2 = Object.defineProperty;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var exports_react_dom_production = {};
__export2(exports_react_dom_production, {
  version: () => $version,
  useFormStatus: () => $useFormStatus,
  useFormState: () => $useFormState,
  unstable_batchedUpdates: () => $unstable_batchedUpdates,
  requestFormReset: () => $requestFormReset,
  preloadModule: () => $preloadModule,
  preload: () => $preload,
  preinitModule: () => $preinitModule,
  preinit: () => $preinit,
  prefetchDNS: () => $prefetchDNS,
  preconnect: () => $preconnect,
  flushSync: () => $flushSync,
  createPortal: () => $createPortal,
  __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: () => $__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
});
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2;i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function noop() {}
function createPortal$1(children, containerInfo, implementation) {
  var key = 3 < arguments.length && arguments[3] !== undefined ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : "" + key,
    children,
    containerInfo,
    implementation
  };
}
function getCrossOriginStringAs(as, input) {
  if (as === "font")
    return "";
  if (typeof input === "string")
    return input === "use-credentials" ? input : "";
}
var Internals;
var REACT_PORTAL_TYPE;
var ReactSharedInternals;
var $__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
var $createPortal = function(children, container) {
  var key = 2 < arguments.length && arguments[2] !== undefined ? arguments[2] : null;
  if (!container || container.nodeType !== 1 && container.nodeType !== 9 && container.nodeType !== 11)
    throw Error(formatProdErrorMessage(299));
  return createPortal$1(children, container, null, key);
};
var $flushSync = function(fn) {
  var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
  try {
    if (ReactSharedInternals.T = null, Internals.p = 2, fn)
      return fn();
  } finally {
    ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
  }
};
var $preconnect = function(href2, options) {
  typeof href2 === "string" && (options ? (options = options.crossOrigin, options = typeof options === "string" ? options === "use-credentials" ? options : "" : undefined) : options = null, Internals.d.C(href2, options));
};
var $prefetchDNS = function(href2) {
  typeof href2 === "string" && Internals.d.D(href2);
};
var $preinit = function(href2, options) {
  if (typeof href2 === "string" && options && typeof options.as === "string") {
    var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = typeof options.integrity === "string" ? options.integrity : undefined, fetchPriority = typeof options.fetchPriority === "string" ? options.fetchPriority : undefined;
    as === "style" ? Internals.d.S(href2, typeof options.precedence === "string" ? options.precedence : undefined, {
      crossOrigin,
      integrity,
      fetchPriority
    }) : as === "script" && Internals.d.X(href2, {
      crossOrigin,
      integrity,
      fetchPriority,
      nonce: typeof options.nonce === "string" ? options.nonce : undefined
    });
  }
};
var $preinitModule = function(href2, options) {
  if (typeof href2 === "string")
    if (typeof options === "object" && options !== null) {
      if (options.as == null || options.as === "script") {
        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
        Internals.d.M(href2, {
          crossOrigin,
          integrity: typeof options.integrity === "string" ? options.integrity : undefined,
          nonce: typeof options.nonce === "string" ? options.nonce : undefined
        });
      }
    } else
      options == null && Internals.d.M(href2);
};
var $preload = function(href2, options) {
  if (typeof href2 === "string" && typeof options === "object" && options !== null && typeof options.as === "string") {
    var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
    Internals.d.L(href2, as, {
      crossOrigin,
      integrity: typeof options.integrity === "string" ? options.integrity : undefined,
      nonce: typeof options.nonce === "string" ? options.nonce : undefined,
      type: typeof options.type === "string" ? options.type : undefined,
      fetchPriority: typeof options.fetchPriority === "string" ? options.fetchPriority : undefined,
      referrerPolicy: typeof options.referrerPolicy === "string" ? options.referrerPolicy : undefined,
      imageSrcSet: typeof options.imageSrcSet === "string" ? options.imageSrcSet : undefined,
      imageSizes: typeof options.imageSizes === "string" ? options.imageSizes : undefined,
      media: typeof options.media === "string" ? options.media : undefined
    });
  }
};
var $preloadModule = function(href2, options) {
  if (typeof href2 === "string")
    if (options) {
      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
      Internals.d.m(href2, {
        as: typeof options.as === "string" && options.as !== "script" ? options.as : undefined,
        crossOrigin,
        integrity: typeof options.integrity === "string" ? options.integrity : undefined
      });
    } else
      Internals.d.m(href2);
};
var $requestFormReset = function(form) {
  Internals.d.r(form);
};
var $unstable_batchedUpdates = function(fn, a) {
  return fn(a);
};
var $useFormState = function(action, initialState, permalink) {
  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
};
var $useFormStatus = function() {
  return ReactSharedInternals.H.useHostTransitionStatus();
};
var $version = "19.2.0";
var init_react_dom_production = __esm(() => {
  Internals = {
    d: {
      f: noop,
      r: function() {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  };
  REACT_PORTAL_TYPE = Symbol.for("react.portal");
  ReactSharedInternals = React8.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  $__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
});
var require_react_dom = __commonJS2((exports, module) => {
  init_react_dom_production();
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    if (false) {}
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  if (true) {
    checkDCE();
    module.exports = exports_react_dom_production;
  } else {}
});
var LoadingBar = memo(({ className }) => /* @__PURE__ */ jsx23("div", {
  className: clsx5("loading-bar", className)
}));
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== undefined) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0;i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React3.useCallback(composeRefs(...refs), refs);
}
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = React22.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React22.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React22.Children.count(newElement) > 1)
            return React22.Children.only(null);
          return React22.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsx33(SlotClone, { ...slotProps, ref: forwardedRef, children: React22.isValidElement(newElement) ? React22.cloneElement(newElement, undefined, newChildren) : null });
    }
    return /* @__PURE__ */ jsx33(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
function createSlotClone(ownerName) {
  const SlotClone = React22.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React22.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React22.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React22.cloneElement(children, props2);
    }
    return React22.Children.count(children) > 1 ? React22.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable(child) {
  return React22.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var buttonVariants = cva("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", {
  variants: {
    variant: {
      default: "bg-primary text-primary-foreground hover:bg-primary/90",
      destructive: "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
      outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
      secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
      ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
      link: "text-primary underline-offset-4 hover:underline"
    },
    size: {
      default: "h-9 px-4 py-2 has-[>svg]:px-3",
      sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
      lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
      icon: "size-9",
      "icon-sm": "size-8",
      "icon-lg": "size-10"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "default"
  }
});
function createContext22(rootComponentName, defaultContext) {
  const Context = React32.createContext(defaultContext);
  const Provider = (props) => {
    const { children, ...context } = props;
    const value = React32.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsx52(Context.Provider, { value, children });
  };
  Provider.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React32.useContext(Context);
    if (context)
      return context;
    if (defaultContext !== undefined)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React32.createContext(defaultContext);
    const index = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName]?.[index] || BaseContext;
      const value = React32.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsx52(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      const Context = scope?.[scopeName]?.[index] || BaseContext;
      const context = React32.useContext(Context);
      if (context)
        return context;
      if (defaultContext !== undefined)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React32.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return React32.useMemo(() => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }), [scope, contexts]);
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React32.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function createCollection(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React4.useRef(null);
    const itemMap = React4.useRef(/* @__PURE__ */ new Map).current;
    return /* @__PURE__ */ jsx62(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = React4.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ jsx62(CollectionSlotImpl, { ref: composedRefs, children });
  });
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = React4.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = React4.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    React4.useEffect(() => {
      context.itemMap.set(ref, { ref, ...itemData });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ jsx62(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
  });
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React4.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort((a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current));
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection,
    createCollectionScope
  ];
}
var __instanciated = /* @__PURE__ */ new WeakMap;
var OrderedDict = class _OrderedDict extends Map {
  #keys;
  constructor(entries) {
    super(entries);
    this.#keys = [...super.keys()];
    __instanciated.set(this, true);
  }
  set(key, value) {
    if (__instanciated.get(this)) {
      if (this.has(key)) {
        this.#keys[this.#keys.indexOf(key)] = key;
      } else {
        this.#keys.push(key);
      }
    }
    super.set(key, value);
    return this;
  }
  insert(index, key, value) {
    const has = this.has(key);
    const length = this.#keys.length;
    const relativeIndex = toSafeInteger(index);
    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
    if (safeIndex === this.size || has && safeIndex === this.size - 1 || safeIndex === -1) {
      this.set(key, value);
      return this;
    }
    const size = this.size + (has ? 0 : 1);
    if (relativeIndex < 0) {
      actualIndex++;
    }
    const keys = [...this.#keys];
    let nextValue;
    let shouldSkip = false;
    for (let i = actualIndex;i < size; i++) {
      if (actualIndex === i) {
        let nextKey = keys[i];
        if (keys[i] === key) {
          nextKey = keys[i + 1];
        }
        if (has) {
          this.delete(key);
        }
        nextValue = this.get(nextKey);
        this.set(key, value);
      } else {
        if (!shouldSkip && keys[i - 1] === key) {
          shouldSkip = true;
        }
        const currentKey = keys[shouldSkip ? i : i - 1];
        const currentValue = nextValue;
        nextValue = this.get(currentKey);
        this.delete(currentKey);
        this.set(currentKey, currentValue);
      }
    }
    return this;
  }
  with(index, key, value) {
    const copy = new _OrderedDict(this);
    copy.insert(index, key, value);
    return copy;
  }
  before(key) {
    const index = this.#keys.indexOf(key) - 1;
    if (index < 0) {
      return;
    }
    return this.entryAt(index);
  }
  setBefore(key, newKey, value) {
    const index = this.#keys.indexOf(key);
    if (index === -1) {
      return this;
    }
    return this.insert(index, newKey, value);
  }
  after(key) {
    let index = this.#keys.indexOf(key);
    index = index === -1 || index === this.size - 1 ? -1 : index + 1;
    if (index === -1) {
      return;
    }
    return this.entryAt(index);
  }
  setAfter(key, newKey, value) {
    const index = this.#keys.indexOf(key);
    if (index === -1) {
      return this;
    }
    return this.insert(index + 1, newKey, value);
  }
  first() {
    return this.entryAt(0);
  }
  last() {
    return this.entryAt(-1);
  }
  clear() {
    this.#keys = [];
    return super.clear();
  }
  delete(key) {
    const deleted = super.delete(key);
    if (deleted) {
      this.#keys.splice(this.#keys.indexOf(key), 1);
    }
    return deleted;
  }
  deleteAt(index) {
    const key = this.keyAt(index);
    if (key !== undefined) {
      return this.delete(key);
    }
    return false;
  }
  at(index) {
    const key = at(this.#keys, index);
    if (key !== undefined) {
      return this.get(key);
    }
  }
  entryAt(index) {
    const key = at(this.#keys, index);
    if (key !== undefined) {
      return [key, this.get(key)];
    }
  }
  indexOf(key) {
    return this.#keys.indexOf(key);
  }
  keyAt(index) {
    return at(this.#keys, index);
  }
  from(key, offset) {
    const index = this.indexOf(key);
    if (index === -1) {
      return;
    }
    let dest = index + offset;
    if (dest < 0)
      dest = 0;
    if (dest >= this.size)
      dest = this.size - 1;
    return this.at(dest);
  }
  keyFrom(key, offset) {
    const index = this.indexOf(key);
    if (index === -1) {
      return;
    }
    let dest = index + offset;
    if (dest < 0)
      dest = 0;
    if (dest >= this.size)
      dest = this.size - 1;
    return this.keyAt(dest);
  }
  find(predicate, thisArg) {
    let index = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {
        return entry;
      }
      index++;
    }
    return;
  }
  findIndex(predicate, thisArg) {
    let index = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {
        return index;
      }
      index++;
    }
    return -1;
  }
  filter(predicate, thisArg) {
    const entries = [];
    let index = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {
        entries.push(entry);
      }
      index++;
    }
    return new _OrderedDict(entries);
  }
  map(callbackfn, thisArg) {
    const entries = [];
    let index = 0;
    for (const entry of this) {
      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);
      index++;
    }
    return new _OrderedDict(entries);
  }
  reduce(...args) {
    const [callbackfn, initialValue] = args;
    let index = 0;
    let accumulator = initialValue ?? this.at(0);
    for (const entry of this) {
      if (index === 0 && args.length === 1) {
        accumulator = entry;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);
      }
      index++;
    }
    return accumulator;
  }
  reduceRight(...args) {
    const [callbackfn, initialValue] = args;
    let accumulator = initialValue ?? this.at(-1);
    for (let index = this.size - 1;index >= 0; index--) {
      const entry = this.at(index);
      if (index === this.size - 1 && args.length === 1) {
        accumulator = entry;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);
      }
    }
    return accumulator;
  }
  toSorted(compareFn) {
    const entries = [...this.entries()].sort(compareFn);
    return new _OrderedDict(entries);
  }
  toReversed() {
    const reversed = new _OrderedDict;
    for (let index = this.size - 1;index >= 0; index--) {
      const key = this.keyAt(index);
      const element = this.get(key);
      reversed.set(key, element);
    }
    return reversed;
  }
  toSpliced(...args) {
    const entries = [...this.entries()];
    entries.splice(...args);
    return new _OrderedDict(entries);
  }
  slice(start, end) {
    const result = new _OrderedDict;
    let stop = this.size - 1;
    if (start === undefined) {
      return result;
    }
    if (start < 0) {
      start = start + this.size;
    }
    if (end !== undefined && end > 0) {
      stop = end - 1;
    }
    for (let index = start;index <= stop; index++) {
      const key = this.keyAt(index);
      const element = this.get(key);
      result.set(key, element);
    }
    return result;
  }
  every(predicate, thisArg) {
    let index = 0;
    for (const entry of this) {
      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {
        return false;
      }
      index++;
    }
    return true;
  }
  some(predicate, thisArg) {
    let index = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {
        return true;
      }
      index++;
    }
    return false;
  }
};
function at(array, index) {
  if ("at" in Array.prototype) {
    return Array.prototype.at.call(array, index);
  }
  const actualIndex = toSafeIndex(array, index);
  return actualIndex === -1 ? undefined : array[actualIndex];
}
function toSafeIndex(array, index) {
  const length = array.length;
  const relativeIndex = toSafeInteger(index);
  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
}
function toSafeInteger(number) {
  return number !== number || number === 0 ? 0 : Math.trunc(number);
}
var DirectionContext = React5.createContext(undefined);
function useDirection(localDir) {
  const globalDir = React5.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
var useLayoutEffect22 = globalThis?.document ? React6.useLayoutEffect : () => {};
var useReactId = React7[" useId ".trim().toString()] || (() => {
  return;
});
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React7.useState(useReactId());
  useLayoutEffect22(() => {
    if (!deterministicId)
      setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}
var ReactDOM = __toESM2(require_react_dom(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = createSlot(`Primitive.${node}`);
  const Node2 = React9.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsx8(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target)
    ReactDOM.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef(callback) {
  const callbackRef = React10.useRef(callback);
  React10.useEffect(() => {
    callbackRef.current = callback;
  });
  return React10.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React11.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React12.createContext({
  layers: /* @__PURE__ */ new Set,
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set,
  branches: /* @__PURE__ */ new Set
});
var DismissableLayer = React12.forwardRef((props, forwardedRef) => {
  const {
    disableOutsidePointerEvents = false,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss,
    ...layerProps
  } = props;
  const context = React12.useContext(DismissableLayerContext);
  const [node, setNode] = React12.useState(null);
  const ownerDocument = node?.ownerDocument ?? globalThis?.document;
  const [, force] = React12.useState({});
  const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index = node ? layers.indexOf(node) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside?.(event);
    onInteractOutside?.(event);
    if (!event.defaultPrevented)
      onDismiss?.();
  }, ownerDocument);
  const focusOutside = useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
    if (isFocusInBranch)
      return;
    onFocusOutside?.(event);
    onInteractOutside?.(event);
    if (!event.defaultPrevented)
      onDismiss?.();
  }, ownerDocument);
  useEscapeKeydown((event) => {
    const isHighestLayer = index === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown?.(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  React12.useEffect(() => {
    if (!node)
      return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node);
    }
    context.layers.add(node);
    dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
        ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
      }
    };
  }, [node, ownerDocument, disableOutsidePointerEvents, context]);
  React12.useEffect(() => {
    return () => {
      if (!node)
        return;
      context.layers.delete(node);
      context.layersWithOutsidePointerEventsDisabled.delete(node);
      dispatchUpdate();
    };
  }, [node, context]);
  React12.useEffect(() => {
    const handleUpdate = () => force({});
    document.addEventListener(CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ jsx9(Primitive.div, {
    ...layerProps,
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : undefined,
      ...props.style
    },
    onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  });
});
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React12.forwardRef((props, forwardedRef) => {
  const context = React12.useContext(DismissableLayerContext);
  const ref = React12.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React12.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsx9(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React12.useRef(false);
  const handleClickRef = React12.useRef(() => {});
  React12.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, { discrete: true });
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React12.useRef(false);
  React12.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var count2 = 0;
function useFocusGuards() {
  React13.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React14.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React14.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React14.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React14.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React14.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React14.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React14.useCallback((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container2 = event.currentTarget;
      const [first, last] = getTabbableEdges(container2);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container2)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop)
            focus(first, { select: true });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop)
            focus(last, { select: true });
        }
      }
    }
  }, [loop, trapped, focusScope.paused]);
  return /* @__PURE__ */ jsx10(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== undefined && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var sides = ["top", "right", "bottom", "left"];
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === undefined) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0;i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === undefined) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? undefined : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? undefined : platform.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? undefined : platform.getOffsetParent(elements.floating));
  const offsetScale = await (platform.isElement == null ? undefined : platform.isElement(offsetParent)) ? await (platform.getScale == null ? undefined : platform.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? undefined : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform.isElement == null ? undefined : platform.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? undefined : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? undefined : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? undefined : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? undefined : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === undefined) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? undefined : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? undefined : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? undefined : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? undefined : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? undefined : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === undefined) {
    list = [];
  }
  if (traverseIframes === undefined) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? undefined : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === undefined) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === undefined) {
    includeScale = false;
  }
  if (isFixedStrategy === undefined) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === undefined) {
      skip = false;
    }
    if (threshold === undefined) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 0.0000001);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === undefined) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = new Map;
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var ReactDOM2 = __toESM2(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop2 = function noop3() {};
var index = isClient ? useLayoutEffect3 : noop2;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length)
        return false;
      for (i = length;i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length;i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length;i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React15.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === undefined) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React15.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React15.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React15.useState(null);
  const [_floating, _setFloating] = React15.useState(null);
  const setReference = React15.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React15.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React15.useRef(null);
  const floatingRef = React15.useRef(null);
  const dataRef = React15.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React15.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM2.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React15.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React15.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React15.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React15.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React15.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME = "Arrow";
var Arrow = React16.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsx11(Primitive.svg, {
    ...arrowProps,
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none",
    children: props.asChild ? children : /* @__PURE__ */ jsx11("polygon", { points: "0,0 30,0 15,10" })
  });
});
Arrow.displayName = NAME;
var Root = Arrow;
function useSize(element) {
  const [size4, setSize] = React17.useState(undefined);
  useLayoutEffect22(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(undefined);
    }
  }, [element]);
  return size4;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React18.useState(null);
  return /* @__PURE__ */ jsx12(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React18.forwardRef((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context = usePopperContext(ANCHOR_NAME, __scopePopper);
  const ref = React18.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const anchorRef = React18.useRef(null);
  React18.useEffect(() => {
    const previousAnchor = anchorRef.current;
    anchorRef.current = virtualRef?.current || ref.current;
    if (previousAnchor !== anchorRef.current) {
      context.onAnchorChange(anchorRef.current);
    }
  });
  return virtualRef ? null : /* @__PURE__ */ jsx12(Primitive.div, { ...anchorProps, ref: composedRefs });
});
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React18.forwardRef((props, forwardedRef) => {
  const {
    __scopePopper,
    side = "bottom",
    sideOffset = 0,
    align = "center",
    alignOffset = 0,
    arrowPadding = 0,
    avoidCollisions = true,
    collisionBoundary = [],
    collisionPadding: collisionPaddingProp = 0,
    sticky = "partial",
    hideWhenDetached = false,
    updatePositionStrategy = "optimized",
    onPlaced,
    ...contentProps
  } = props;
  const context = usePopperContext(CONTENT_NAME, __scopePopper);
  const [content, setContent] = React18.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const [arrow4, setArrow] = React18.useState(null);
  const arrowSize = useSize(arrow4);
  const arrowWidth = arrowSize?.width ?? 0;
  const arrowHeight = arrowSize?.height ?? 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter(isNotNull),
    altBoundary: hasExplicitBoundaries
  };
  const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: (...args) => {
      const cleanup = autoUpdate(...args, {
        animationFrame: updatePositionStrategy === "always"
      });
      return cleanup;
    },
    elements: {
      reference: context.anchor
    },
    middleware: [
      offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
      avoidCollisions && shift3({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? limitShift3() : undefined,
        ...detectOverflowOptions
      }),
      avoidCollisions && flip3({ ...detectOverflowOptions }),
      size3({
        ...detectOverflowOptions,
        apply: ({ elements, rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          const contentStyle = elements.floating.style;
          contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
          contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
          contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
          contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
        }
      }),
      arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
      transformOrigin({ arrowWidth, arrowHeight }),
      hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
    ]
  });
  const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
  const handlePlaced = useCallbackRef(onPlaced);
  useLayoutEffect22(() => {
    if (isPositioned) {
      handlePlaced?.();
    }
  }, [isPositioned, handlePlaced]);
  const arrowX = middlewareData.arrow?.x;
  const arrowY = middlewareData.arrow?.y;
  const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
  const [contentZIndex, setContentZIndex] = React18.useState();
  useLayoutEffect22(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  return /* @__PURE__ */ jsx12("div", {
    ref: refs.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...floatingStyles,
      transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        middlewareData.transformOrigin?.x,
        middlewareData.transformOrigin?.y
      ].join(" "),
      ...middlewareData.hide?.referenceHidden && {
        visibility: "hidden",
        pointerEvents: "none"
      }
    },
    dir: props.dir,
    children: /* @__PURE__ */ jsx12(PopperContentProvider, {
      scope: __scopePopper,
      placedSide,
      onArrowChange: setArrow,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow,
      children: /* @__PURE__ */ jsx12(Primitive.div, {
        "data-side": placedSide,
        "data-align": placedAlign,
        ...contentProps,
        ref: composedRefs,
        style: {
          ...contentProps.style,
          animation: !isPositioned ? "none" : undefined
        }
      })
    })
  });
});
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React18.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return /* @__PURE__ */ jsx12("span", {
    ref: contentContext.onArrowChange,
    style: {
      position: "absolute",
      left: contentContext.arrowX,
      top: contentContext.arrowY,
      [baseSide]: 0,
      transformOrigin: {
        top: "",
        right: "0 0",
        bottom: "center 0",
        left: "100% 0"
      }[contentContext.placedSide],
      transform: {
        top: "translateY(100%)",
        right: "translateY(50%) rotate(90deg) translateX(-50%)",
        bottom: `rotate(180deg)`,
        left: "translateY(50%) rotate(-90deg) translateX(50%)"
      }[contentContext.placedSide],
      visibility: contentContext.shouldHideArrow ? "hidden" : undefined
    },
    children: /* @__PURE__ */ jsx12(Root, {
      ...arrowProps,
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        display: "block"
      }
    })
  });
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;
var import_react_dom2 = __toESM2(require_react_dom(), 1);
var PORTAL_NAME = "Portal";
var Portal = React19.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React19.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? import_react_dom2.default.createPortal(/* @__PURE__ */ jsx13(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;
function useStateMachine(initialState, machine) {
  return React20.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React23.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React23.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React23.useState();
  const stylesRef = React23.useRef(null);
  const prevPresentRef = React23.useRef(present);
  const prevAnimationNameRef = React23.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React23.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React23.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef2(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var useInsertionEffect = React21[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {},
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== undefined;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React21.useRef(prop !== undefined);
    React21.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(`${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`);
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React21.useCallback((nextValue) => {
    if (isControlled) {
      const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
      if (value2 !== prop) {
        onChangeRef.current?.(value2);
      }
    } else {
      setUncontrolledProp(nextValue);
    }
  }, [isControlled, prop, setUncontrolledProp, onChangeRef]);
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React21.useState(defaultProp);
  const prevValueRef = React21.useRef(value);
  const onChangeRef = React21.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React21.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var GROUP_NAME = "RovingFocusGroup";
var [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(GROUP_NAME, [createCollectionScope]);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
var RovingFocusGroup = React25.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsx14(Collection.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx14(Collection.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx14(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
});
RovingFocusGroup.displayName = GROUP_NAME;
var RovingFocusGroupImpl = React25.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React25.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React25.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = React25.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React25.useState(0);
  React25.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsx14(RovingFocusProvider, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction,
    loop,
    currentTabStopId,
    onItemFocus: React25.useCallback((tabStopId) => setCurrentTabStopId(tabStopId), [setCurrentTabStopId]),
    onItemShiftTab: React25.useCallback(() => setIsTabbingBackOut(true), []),
    onFocusableItemAdd: React25.useCallback(() => setFocusableItemsCount((prevCount) => prevCount + 1), []),
    onFocusableItemRemove: React25.useCallback(() => setFocusableItemsCount((prevCount) => prevCount - 1), []),
    children: /* @__PURE__ */ jsx14(Primitive.div, {
      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
      "data-orientation": orientation,
      ...groupProps,
      ref: composedRefs,
      style: { outline: "none", ...props.style },
      onMouseDown: composeEventHandlers(props.onMouseDown, () => {
        isClickFocusRef.current = true;
      }),
      onFocus: composeEventHandlers(props.onFocus, (event) => {
        const isKeyboardFocus = !isClickFocusRef.current;
        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
          const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
          event.currentTarget.dispatchEvent(entryFocusEvent);
          if (!entryFocusEvent.defaultPrevented) {
            const items = getItems().filter((item) => item.focusable);
            const activeItem = items.find((item) => item.active);
            const currentItem = items.find((item) => item.id === currentTabStopId);
            const candidateItems = [activeItem, currentItem, ...items].filter(Boolean);
            const candidateNodes = candidateItems.map((item) => item.ref.current);
            focusFirst2(candidateNodes, preventScrollOnEntryFocus);
          }
        }
        isClickFocusRef.current = false;
      }),
      onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
    })
  });
});
var ITEM_NAME = "RovingFocusGroupItem";
var RovingFocusGroupItem = React25.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    focusable = true,
    active = false,
    tabStopId,
    children,
    ...itemProps
  } = props;
  const autoId = useId();
  const id = tabStopId || autoId;
  const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = useCollection(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
  React25.useEffect(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
  return /* @__PURE__ */ jsx14(Collection.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id,
    focusable,
    active,
    children: /* @__PURE__ */ jsx14(Primitive.span, {
      tabIndex: isCurrentTabStop ? 0 : -1,
      "data-orientation": context.orientation,
      ...itemProps,
      ref: forwardedRef,
      onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
        if (!focusable)
          event.preventDefault();
        else
          context.onItemFocus(id);
      }),
      onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
      onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
        if (event.key === "Tab" && event.shiftKey) {
          context.onItemShiftTab();
          return;
        }
        if (event.target !== event.currentTarget)
          return;
        const focusIntent = getFocusIntent(event, context.orientation, context.dir);
        if (focusIntent !== undefined) {
          if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)
            return;
          event.preventDefault();
          const items = getItems().filter((item) => item.focusable);
          let candidateNodes = items.map((item) => item.ref.current);
          if (focusIntent === "last")
            candidateNodes.reverse();
          else if (focusIntent === "prev" || focusIntent === "next") {
            if (focusIntent === "prev")
              candidateNodes.reverse();
            const currentIndex = candidateNodes.indexOf(event.currentTarget);
            candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
          }
          setTimeout(() => focusFirst2(candidateNodes));
        }
      }),
      children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
    })
  });
});
RovingFocusGroupItem.displayName = ITEM_NAME;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root3 = RovingFocusGroup;
var Item = RovingFocusGroupItem;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = new WeakMap;
var uncontrolledNodes = new WeakMap;
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = new WeakMap;
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = new Set;
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = new WeakMap;
      counterMap = new WeakMap;
      uncontrolledNodes = new WeakMap;
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === undefined) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign = function() {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length;i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar;i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef2(initialValue, callback) {
  var ref = useState112(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React27.useLayoutEffect : React27.useEffect;
var currentValues = new WeakMap;
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === undefined) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === undefined) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React28.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = React29.forwardRef(function(props, parentRef) {
  var ref = React29.useRef(null);
  var _a = React29.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var { forwardProps, children, className, removeScrollBar, enabled, shards, sideCar, noRelative, noIsolation, inert, allowPinchZoom, as: _b } = props, Container = _b === undefined ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React29.createElement(React29.Fragment, null, enabled && React29.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }), forwardProps ? React29.cloneElement(React29.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React29.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children));
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React30.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var { styles, dynamic } = _a;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === undefined) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var { left, top, right, gap } = _a;
  if (gapMode === undefined) {
    gapMode = "margin";
  }
  return `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && `
    padding-left: `.concat(left, `px;
    padding-top: `).concat(top, `px;
    padding-right: `).concat(right, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(gap, `px;
  }
`);
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React31.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var { noRelative, noImportant, gapMode: _b } = _a, gapMode = _b === undefined ? "margin" : _b;
  useLockAttribute();
  var gap = React31.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React31.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible");
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var { scrollTop, scrollHeight, clientHeight } = _a;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var { scrollLeft, scrollWidth, clientWidth } = _a;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return `
  .block-interactivity-`.concat(id, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id, ` {pointer-events: all;}
`);
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React322.useRef([]);
  var touchStartRef = React322.useRef([0, 0]);
  var activeAxis = React322.useRef();
  var id = React322.useState(idCounter++)[0];
  var Style2 = React322.useState(styleSingleton)[0];
  var lastProps = React322.useRef(props);
  React322.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React322.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React322.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React322.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React322.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React322.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = undefined;
  }, []);
  var scrollWheel = React322.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React322.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React322.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var { removeScrollBar, inert } = props;
  return React322.createElement(React322.Fragment, null, inert ? React322.createElement(Style2, { styles: generateStyle(id) }) : null, removeScrollBar ? React322.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null);
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React33.forwardRef(function(props, ref) {
  return React33.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope = createPopperScope();
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope(__scopeMenu);
  const [content, setContent] = React34.useState(null);
  const isUsingKeyboardRef = React34.useRef(false);
  const handleOpenChange = useCallbackRef(onOpenChange);
  const direction = useDirection(dir);
  React34.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsx15(Root2, { ...popperScope, children: /* @__PURE__ */ jsx15(MenuProvider, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent,
    children: /* @__PURE__ */ jsx15(MenuRootProvider, {
      scope: __scopeMenu,
      onClose: React34.useCallback(() => handleOpenChange(false), [handleOpenChange]),
      isUsingKeyboardRef,
      dir: direction,
      modal,
      children
    })
  }) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME2 = "MenuAnchor";
var MenuAnchor = React34.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...anchorProps } = props;
  const popperScope = usePopperScope(__scopeMenu);
  return /* @__PURE__ */ jsx15(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
});
MenuAnchor.displayName = ANCHOR_NAME2;
var PORTAL_NAME2 = "MenuPortal";
var [PortalProvider, usePortalContext] = createMenuContext(PORTAL_NAME2, {
  forceMount: undefined
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME2, __scopeMenu);
  return /* @__PURE__ */ jsx15(PortalProvider, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsx15(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx15(Portal, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME2;
var CONTENT_NAME2 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME2);
var MenuContent = React34.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext(CONTENT_NAME2, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = useMenuContext(CONTENT_NAME2, props.__scopeMenu);
  const rootContext = useMenuRootContext(CONTENT_NAME2, props.__scopeMenu);
  return /* @__PURE__ */ jsx15(Collection2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsx15(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx15(Collection2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsx15(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx15(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
});
var MenuRootContentModal = React34.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME2, props.__scopeMenu);
  const ref = React34.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React34.useEffect(() => {
    const content = ref.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ jsx15(MenuContentImpl, {
    ...props,
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: context.open,
    disableOutsideScroll: true,
    onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => event.preventDefault(), { checkForDefaultPrevented: false }),
    onDismiss: () => context.onOpenChange(false)
  });
});
var MenuRootContentNonModal = React34.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME2, props.__scopeMenu);
  return /* @__PURE__ */ jsx15(MenuContentImpl, {
    ...props,
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    onDismiss: () => context.onOpenChange(false)
  });
});
var Slot2 = createSlot("MenuContent.ScrollLock");
var MenuContentImpl = React34.forwardRef((props, forwardedRef) => {
  const {
    __scopeMenu,
    loop = false,
    trapFocus,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    onEntryFocus,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss,
    disableOutsideScroll,
    ...contentProps
  } = props;
  const context = useMenuContext(CONTENT_NAME2, __scopeMenu);
  const rootContext = useMenuRootContext(CONTENT_NAME2, __scopeMenu);
  const popperScope = usePopperScope(__scopeMenu);
  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
  const getItems = useCollection2(__scopeMenu);
  const [currentItemId, setCurrentItemId] = React34.useState(null);
  const contentRef = React34.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
  const timerRef = React34.useRef(0);
  const searchRef = React34.useRef("");
  const pointerGraceTimerRef = React34.useRef(0);
  const pointerGraceIntentRef = React34.useRef(null);
  const pointerDirRef = React34.useRef("right");
  const lastPointerXRef = React34.useRef(0);
  const ScrollLockWrapper = disableOutsideScroll ? Combination_default : React34.Fragment;
  const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot2, allowPinchZoom: true } : undefined;
  const handleTypeaheadSearch = (key) => {
    const search = searchRef.current + key;
    const items = getItems().filter((item) => !item.disabled);
    const currentItem = document.activeElement;
    const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;
    const values = items.map((item) => item.textValue);
    const nextMatch = getNextMatch(values, search, currentMatch);
    const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;
    (function updateSearch(value) {
      searchRef.current = value;
      window.clearTimeout(timerRef.current);
      if (value !== "")
        timerRef.current = window.setTimeout(() => updateSearch(""), 1000);
    })(search);
    if (newItem) {
      setTimeout(() => newItem.focus());
    }
  };
  React34.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  useFocusGuards();
  const isPointerMovingToSubmenu = React34.useCallback((event) => {
    const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;
    return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);
  }, []);
  return /* @__PURE__ */ jsx15(MenuContentProvider, {
    scope: __scopeMenu,
    searchRef,
    onItemEnter: React34.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [isPointerMovingToSubmenu]),
    onItemLeave: React34.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        return;
      contentRef.current?.focus();
      setCurrentItemId(null);
    }, [isPointerMovingToSubmenu]),
    onTriggerLeave: React34.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [isPointerMovingToSubmenu]),
    pointerGraceTimerRef,
    onPointerGraceIntentChange: React34.useCallback((intent) => {
      pointerGraceIntentRef.current = intent;
    }, []),
    children: /* @__PURE__ */ jsx15(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsx15(FocusScope, {
      asChild: true,
      trapped: trapFocus,
      onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
        event.preventDefault();
        contentRef.current?.focus({ preventScroll: true });
      }),
      onUnmountAutoFocus: onCloseAutoFocus,
      children: /* @__PURE__ */ jsx15(DismissableLayer, {
        asChild: true,
        disableOutsidePointerEvents,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        children: /* @__PURE__ */ jsx15(Root3, {
          asChild: true,
          ...rovingFocusGroupScope,
          dir: rootContext.dir,
          orientation: "vertical",
          loop,
          currentTabStopId: currentItemId,
          onCurrentTabStopIdChange: setCurrentItemId,
          onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
            if (!rootContext.isUsingKeyboardRef.current)
              event.preventDefault();
          }),
          preventScrollOnEntryFocus: true,
          children: /* @__PURE__ */ jsx15(Content, {
            role: "menu",
            "aria-orientation": "vertical",
            "data-state": getOpenState(context.open),
            "data-radix-menu-content": "",
            dir: rootContext.dir,
            ...popperScope,
            ...contentProps,
            ref: composedRefs,
            style: { outline: "none", ...contentProps.style },
            onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
              const target = event.target;
              const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
              const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
              const isCharacterKey = event.key.length === 1;
              if (isKeyDownInside) {
                if (event.key === "Tab")
                  event.preventDefault();
                if (!isModifierKey && isCharacterKey)
                  handleTypeaheadSearch(event.key);
              }
              const content = contentRef.current;
              if (event.target !== content)
                return;
              if (!FIRST_LAST_KEYS.includes(event.key))
                return;
              event.preventDefault();
              const items = getItems().filter((item) => !item.disabled);
              const candidateNodes = items.map((item) => item.ref.current);
              if (LAST_KEYS.includes(event.key))
                candidateNodes.reverse();
              focusFirst3(candidateNodes);
            }),
            onBlur: composeEventHandlers(props.onBlur, (event) => {
              if (!event.currentTarget.contains(event.target)) {
                window.clearTimeout(timerRef.current);
                searchRef.current = "";
              }
            }),
            onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse((event) => {
              const target = event.target;
              const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
              if (event.currentTarget.contains(target) && pointerXHasChanged) {
                const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                pointerDirRef.current = newDir;
                lastPointerXRef.current = event.clientX;
              }
            }))
          })
        })
      })
    }) })
  });
});
MenuContent.displayName = CONTENT_NAME2;
var GROUP_NAME2 = "MenuGroup";
var MenuGroup = React34.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...groupProps } = props;
  return /* @__PURE__ */ jsx15(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
});
MenuGroup.displayName = GROUP_NAME2;
var LABEL_NAME = "MenuLabel";
var MenuLabel = React34.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...labelProps } = props;
  return /* @__PURE__ */ jsx15(Primitive.div, { ...labelProps, ref: forwardedRef });
});
MenuLabel.displayName = LABEL_NAME;
var ITEM_NAME2 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React34.forwardRef((props, forwardedRef) => {
  const { disabled = false, onSelect, ...itemProps } = props;
  const ref = React34.useRef(null);
  const rootContext = useMenuRootContext(ITEM_NAME2, props.__scopeMenu);
  const contentContext = useMenuContentContext(ITEM_NAME2, props.__scopeMenu);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const isPointerDownRef = React34.useRef(false);
  const handleSelect = () => {
    const menuItem = ref.current;
    if (!disabled && menuItem) {
      const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
      menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });
      dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
      if (itemSelectEvent.defaultPrevented) {
        isPointerDownRef.current = false;
      } else {
        rootContext.onClose();
      }
    }
  };
  return /* @__PURE__ */ jsx15(MenuItemImpl, {
    ...itemProps,
    ref: composedRefs,
    disabled,
    onClick: composeEventHandlers(props.onClick, handleSelect),
    onPointerDown: (event) => {
      props.onPointerDown?.(event);
      isPointerDownRef.current = true;
    },
    onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
      if (!isPointerDownRef.current)
        event.currentTarget?.click();
    }),
    onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (disabled || isTypingAhead && event.key === " ")
        return;
      if (SELECTION_KEYS.includes(event.key)) {
        event.currentTarget.click();
        event.preventDefault();
      }
    })
  });
});
MenuItem.displayName = ITEM_NAME2;
var MenuItemImpl = React34.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
  const contentContext = useMenuContentContext(ITEM_NAME2, __scopeMenu);
  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
  const ref = React34.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [isFocused, setIsFocused] = React34.useState(false);
  const [textContent, setTextContent] = React34.useState("");
  React34.useEffect(() => {
    const menuItem = ref.current;
    if (menuItem) {
      setTextContent((menuItem.textContent ?? "").trim());
    }
  }, [itemProps.children]);
  return /* @__PURE__ */ jsx15(Collection2.ItemSlot, {
    scope: __scopeMenu,
    disabled,
    textValue: textValue ?? textContent,
    children: /* @__PURE__ */ jsx15(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsx15(Primitive.div, {
      role: "menuitem",
      "data-highlighted": isFocused ? "" : undefined,
      "aria-disabled": disabled || undefined,
      "data-disabled": disabled ? "" : undefined,
      ...itemProps,
      ref: composedRefs,
      onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse((event) => {
        if (disabled) {
          contentContext.onItemLeave(event);
        } else {
          contentContext.onItemEnter(event);
          if (!event.defaultPrevented) {
            const item = event.currentTarget;
            item.focus({ preventScroll: true });
          }
        }
      })),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse((event) => contentContext.onItemLeave(event))),
      onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
      onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
    }) })
  });
});
var CHECKBOX_ITEM_NAME = "MenuCheckboxItem";
var MenuCheckboxItem = React34.forwardRef((props, forwardedRef) => {
  const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
  return /* @__PURE__ */ jsx15(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsx15(MenuItem, {
    role: "menuitemcheckbox",
    "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
    ...checkboxItemProps,
    ref: forwardedRef,
    "data-state": getCheckedState(checked),
    onSelect: composeEventHandlers(checkboxItemProps.onSelect, () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked), { checkForDefaultPrevented: false })
  }) });
});
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(RADIO_GROUP_NAME, { value: undefined, onValueChange: () => {} });
var MenuRadioGroup = React34.forwardRef((props, forwardedRef) => {
  const { value, onValueChange, ...groupProps } = props;
  const handleValueChange = useCallbackRef(onValueChange);
  return /* @__PURE__ */ jsx15(RadioGroupProvider, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsx15(MenuGroup, { ...groupProps, ref: forwardedRef }) });
});
MenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "MenuRadioItem";
var MenuRadioItem = React34.forwardRef((props, forwardedRef) => {
  const { value, ...radioItemProps } = props;
  const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);
  const checked = value === context.value;
  return /* @__PURE__ */ jsx15(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsx15(MenuItem, {
    role: "menuitemradio",
    "aria-checked": checked,
    ...radioItemProps,
    ref: forwardedRef,
    "data-state": getCheckedState(checked),
    onSelect: composeEventHandlers(radioItemProps.onSelect, () => context.onValueChange?.(value), { checkForDefaultPrevented: false })
  }) });
});
MenuRadioItem.displayName = RADIO_ITEM_NAME;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(ITEM_INDICATOR_NAME, { checked: false });
var MenuItemIndicator = React34.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
  const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
  return /* @__PURE__ */ jsx15(Presence, {
    present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
    children: /* @__PURE__ */ jsx15(Primitive.span, {
      ...itemIndicatorProps,
      ref: forwardedRef,
      "data-state": getCheckedState(indicatorContext.checked)
    })
  });
});
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME = "MenuSeparator";
var MenuSeparator = React34.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...separatorProps } = props;
  return /* @__PURE__ */ jsx15(Primitive.div, {
    role: "separator",
    "aria-orientation": "horizontal",
    ...separatorProps,
    ref: forwardedRef
  });
});
MenuSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME2 = "MenuArrow";
var MenuArrow = React34.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...arrowProps } = props;
  const popperScope = usePopperScope(__scopeMenu);
  return /* @__PURE__ */ jsx15(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
});
MenuArrow.displayName = ARROW_NAME2;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);
  const popperScope = usePopperScope(__scopeMenu);
  const [trigger, setTrigger] = React34.useState(null);
  const [content, setContent] = React34.useState(null);
  const handleOpenChange = useCallbackRef(onOpenChange);
  React34.useEffect(() => {
    if (parentMenuContext.open === false)
      handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return /* @__PURE__ */ jsx15(Root2, { ...popperScope, children: /* @__PURE__ */ jsx15(MenuProvider, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent,
    children: /* @__PURE__ */ jsx15(MenuSubProvider, {
      scope: __scopeMenu,
      contentId: useId(),
      triggerId: useId(),
      trigger,
      onTriggerChange: setTrigger,
      children
    })
  }) });
};
MenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME = "MenuSubTrigger";
var MenuSubTrigger = React34.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);
  const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);
  const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);
  const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);
  const openTimerRef = React34.useRef(null);
  const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
  const scope = { __scopeMenu: props.__scopeMenu };
  const clearOpenTimer = React34.useCallback(() => {
    if (openTimerRef.current)
      window.clearTimeout(openTimerRef.current);
    openTimerRef.current = null;
  }, []);
  React34.useEffect(() => clearOpenTimer, [clearOpenTimer]);
  React34.useEffect(() => {
    const pointerGraceTimer = pointerGraceTimerRef.current;
    return () => {
      window.clearTimeout(pointerGraceTimer);
      onPointerGraceIntentChange(null);
    };
  }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
  return /* @__PURE__ */ jsx15(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsx15(MenuItemImpl, {
    id: subContext.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open,
    "aria-controls": subContext.contentId,
    "data-state": getOpenState(context.open),
    ...props,
    ref: composeRefs(forwardedRef, subContext.onTriggerChange),
    onClick: (event) => {
      props.onClick?.(event);
      if (props.disabled || event.defaultPrevented)
        return;
      event.currentTarget.focus();
      if (!context.open)
        context.onOpenChange(true);
    },
    onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse((event) => {
      contentContext.onItemEnter(event);
      if (event.defaultPrevented)
        return;
      if (!props.disabled && !context.open && !openTimerRef.current) {
        contentContext.onPointerGraceIntentChange(null);
        openTimerRef.current = window.setTimeout(() => {
          context.onOpenChange(true);
          clearOpenTimer();
        }, 100);
      }
    })),
    onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse((event) => {
      clearOpenTimer();
      const contentRect = context.content?.getBoundingClientRect();
      if (contentRect) {
        const side = context.content?.dataset.side;
        const rightSide = side === "right";
        const bleed = rightSide ? -5 : 5;
        const contentNearEdge = contentRect[rightSide ? "left" : "right"];
        const contentFarEdge = contentRect[rightSide ? "right" : "left"];
        contentContext.onPointerGraceIntentChange({
          area: [
            { x: event.clientX + bleed, y: event.clientY },
            { x: contentNearEdge, y: contentRect.top },
            { x: contentFarEdge, y: contentRect.top },
            { x: contentFarEdge, y: contentRect.bottom },
            { x: contentNearEdge, y: contentRect.bottom }
          ],
          side
        });
        window.clearTimeout(pointerGraceTimerRef.current);
        pointerGraceTimerRef.current = window.setTimeout(() => contentContext.onPointerGraceIntentChange(null), 300);
      } else {
        contentContext.onTriggerLeave(event);
        if (event.defaultPrevented)
          return;
        contentContext.onPointerGraceIntentChange(null);
      }
    })),
    onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (props.disabled || isTypingAhead && event.key === " ")
        return;
      if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
        context.onOpenChange(true);
        context.content?.focus();
        event.preventDefault();
      }
    })
  }) });
});
MenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "MenuSubContent";
var MenuSubContent = React34.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext(CONTENT_NAME2, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...subContentProps } = props;
  const context = useMenuContext(CONTENT_NAME2, props.__scopeMenu);
  const rootContext = useMenuRootContext(CONTENT_NAME2, props.__scopeMenu);
  const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);
  const ref = React34.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  return /* @__PURE__ */ jsx15(Collection2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsx15(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx15(Collection2.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsx15(MenuContentImpl, {
    id: subContext.contentId,
    "aria-labelledby": subContext.triggerId,
    ...subContentProps,
    ref: composedRefs,
    align: "start",
    side: rootContext.dir === "rtl" ? "left" : "right",
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    trapFocus: false,
    onOpenAutoFocus: (event) => {
      if (rootContext.isUsingKeyboardRef.current)
        ref.current?.focus();
      event.preventDefault();
    },
    onCloseAutoFocus: (event) => event.preventDefault(),
    onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
      if (event.target !== subContext.trigger)
        context.onOpenChange(false);
    }),
    onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
      rootContext.onClose();
      event.preventDefault();
    }),
    onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
      const isKeyDownInside = event.currentTarget.contains(event.target);
      const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
      if (isKeyDownInside && isCloseKey) {
        context.onOpenChange(false);
        subContext.trigger?.focus();
        event.preventDefault();
      }
    })
  }) }) }) });
});
MenuSubContent.displayName = SUB_CONTENT_NAME;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst3(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray2(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray2(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find((value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));
  return nextMatch !== currentMatch ? nextMatch : undefined;
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1;i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : undefined;
}
var Root32 = Menu;
var Anchor2 = MenuAnchor;
var Portal2 = MenuPortal;
var Content2 = MenuContent;
var Group = MenuGroup;
var Label = MenuLabel;
var Item2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow22 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
var MENUBAR_NAME = "Menubar";
var [Collection3, useCollection3, createCollectionScope3] = createCollection(MENUBAR_NAME);
var [createMenubarContext, createMenubarScope] = createContextScope(MENUBAR_NAME, [
  createCollectionScope3,
  createRovingFocusGroupScope
]);
var useMenuScope = createMenuScope();
var useRovingFocusGroupScope2 = createRovingFocusGroupScope();
var [MenubarContextProvider, useMenubarContext] = createMenubarContext(MENUBAR_NAME);
var Menubar = React35.forwardRef((props, forwardedRef) => {
  const {
    __scopeMenubar,
    value: valueProp,
    onValueChange,
    defaultValue,
    loop = true,
    dir,
    ...menubarProps
  } = props;
  const direction = useDirection(dir);
  const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeMenubar);
  const [value, setValue] = useControllableState({
    prop: valueProp,
    onChange: onValueChange,
    defaultProp: defaultValue ?? "",
    caller: MENUBAR_NAME
  });
  const [currentTabStopId, setCurrentTabStopId] = React35.useState(null);
  return /* @__PURE__ */ jsx16(MenubarContextProvider, {
    scope: __scopeMenubar,
    value,
    onMenuOpen: React35.useCallback((value2) => {
      setValue(value2);
      setCurrentTabStopId(value2);
    }, [setValue]),
    onMenuClose: React35.useCallback(() => setValue(""), [setValue]),
    onMenuToggle: React35.useCallback((value2) => {
      setValue((prevValue) => prevValue ? "" : value2);
      setCurrentTabStopId(value2);
    }, [setValue]),
    dir: direction,
    loop,
    children: /* @__PURE__ */ jsx16(Collection3.Provider, { scope: __scopeMenubar, children: /* @__PURE__ */ jsx16(Collection3.Slot, { scope: __scopeMenubar, children: /* @__PURE__ */ jsx16(Root3, {
      asChild: true,
      ...rovingFocusGroupScope,
      orientation: "horizontal",
      loop,
      dir: direction,
      currentTabStopId,
      onCurrentTabStopIdChange: setCurrentTabStopId,
      children: /* @__PURE__ */ jsx16(Primitive.div, { role: "menubar", ...menubarProps, ref: forwardedRef })
    }) }) })
  });
});
Menubar.displayName = MENUBAR_NAME;
var MENU_NAME2 = "MenubarMenu";
var [MenubarMenuProvider, useMenubarMenuContext] = createMenubarContext(MENU_NAME2);
var MenubarMenu = (props) => {
  const { __scopeMenubar, value: valueProp, ...menuProps } = props;
  const autoValue = useId();
  const value = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
  const context = useMenubarContext(MENU_NAME2, __scopeMenubar);
  const menuScope = useMenuScope(__scopeMenubar);
  const triggerRef = React35.useRef(null);
  const wasKeyboardTriggerOpenRef = React35.useRef(false);
  const open = context.value === value;
  React35.useEffect(() => {
    if (!open)
      wasKeyboardTriggerOpenRef.current = false;
  }, [open]);
  return /* @__PURE__ */ jsx16(MenubarMenuProvider, {
    scope: __scopeMenubar,
    value,
    triggerId: useId(),
    triggerRef,
    contentId: useId(),
    wasKeyboardTriggerOpenRef,
    children: /* @__PURE__ */ jsx16(Root32, {
      ...menuScope,
      open,
      onOpenChange: (open2) => {
        if (!open2)
          context.onMenuClose();
      },
      modal: false,
      dir: context.dir,
      ...menuProps
    })
  });
};
MenubarMenu.displayName = MENU_NAME2;
var TRIGGER_NAME = "MenubarTrigger";
var MenubarTrigger = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, disabled = false, ...triggerProps } = props;
  const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeMenubar);
  const menuScope = useMenuScope(__scopeMenubar);
  const context = useMenubarContext(TRIGGER_NAME, __scopeMenubar);
  const menuContext = useMenubarMenuContext(TRIGGER_NAME, __scopeMenubar);
  const ref = React35.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref, menuContext.triggerRef);
  const [isFocused, setIsFocused] = React35.useState(false);
  const open = context.value === menuContext.value;
  return /* @__PURE__ */ jsx16(Collection3.ItemSlot, { scope: __scopeMenubar, value: menuContext.value, disabled, children: /* @__PURE__ */ jsx16(Item, {
    asChild: true,
    ...rovingFocusGroupScope,
    focusable: !disabled,
    tabStopId: menuContext.value,
    children: /* @__PURE__ */ jsx16(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsx16(Primitive.button, {
      type: "button",
      role: "menuitem",
      id: menuContext.triggerId,
      "aria-haspopup": "menu",
      "aria-expanded": open,
      "aria-controls": open ? menuContext.contentId : undefined,
      "data-highlighted": isFocused ? "" : undefined,
      "data-state": open ? "open" : "closed",
      "data-disabled": disabled ? "" : undefined,
      disabled,
      ...triggerProps,
      ref: composedRefs,
      onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
        if (!disabled && event.button === 0 && event.ctrlKey === false) {
          context.onMenuOpen(menuContext.value);
          if (!open)
            event.preventDefault();
        }
      }),
      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => {
        const menubarOpen = Boolean(context.value);
        if (menubarOpen && !open) {
          context.onMenuOpen(menuContext.value);
          ref.current?.focus();
        }
      }),
      onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
        if (disabled)
          return;
        if (["Enter", " "].includes(event.key))
          context.onMenuToggle(menuContext.value);
        if (event.key === "ArrowDown")
          context.onMenuOpen(menuContext.value);
        if (["Enter", " ", "ArrowDown"].includes(event.key)) {
          menuContext.wasKeyboardTriggerOpenRef.current = true;
          event.preventDefault();
        }
      }),
      onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
      onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
    }) })
  }) });
});
MenubarTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME3 = "MenubarPortal";
var MenubarPortal = (props) => {
  const { __scopeMenubar, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(Portal2, { ...menuScope, ...portalProps });
};
MenubarPortal.displayName = PORTAL_NAME3;
var CONTENT_NAME3 = "MenubarContent";
var MenubarContent = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, align = "start", ...contentProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  const context = useMenubarContext(CONTENT_NAME3, __scopeMenubar);
  const menuContext = useMenubarMenuContext(CONTENT_NAME3, __scopeMenubar);
  const getItems = useCollection3(__scopeMenubar);
  const hasInteractedOutsideRef = React35.useRef(false);
  return /* @__PURE__ */ jsx16(Content2, {
    id: menuContext.contentId,
    "aria-labelledby": menuContext.triggerId,
    "data-radix-menubar-content": "",
    ...menuScope,
    ...contentProps,
    ref: forwardedRef,
    align,
    onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
      const menubarOpen = Boolean(context.value);
      if (!menubarOpen && !hasInteractedOutsideRef.current) {
        menuContext.triggerRef.current?.focus();
      }
      hasInteractedOutsideRef.current = false;
      event.preventDefault();
    }),
    onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
      const target = event.target;
      const isMenubarTrigger = getItems().some((item) => item.ref.current?.contains(target));
      if (isMenubarTrigger)
        event.preventDefault();
    }),
    onInteractOutside: composeEventHandlers(props.onInteractOutside, () => {
      hasInteractedOutsideRef.current = true;
    }),
    onEntryFocus: (event) => {
      if (!menuContext.wasKeyboardTriggerOpenRef.current)
        event.preventDefault();
    },
    onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
      if (["ArrowRight", "ArrowLeft"].includes(event.key)) {
        const target = event.target;
        const targetIsSubTrigger = target.hasAttribute("data-radix-menubar-subtrigger");
        const isKeyDownInsideSubMenu = target.closest("[data-radix-menubar-content]") !== event.currentTarget;
        const prevMenuKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
        const isPrevKey = prevMenuKey === event.key;
        const isNextKey = !isPrevKey;
        if (isNextKey && targetIsSubTrigger)
          return;
        if (isKeyDownInsideSubMenu && isPrevKey)
          return;
        const items = getItems().filter((item) => !item.disabled);
        let candidateValues = items.map((item) => item.value);
        if (isPrevKey)
          candidateValues.reverse();
        const currentIndex = candidateValues.indexOf(menuContext.value);
        candidateValues = context.loop ? wrapArray3(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
        const [nextValue] = candidateValues;
        if (nextValue)
          context.onMenuOpen(nextValue);
      }
    }, { checkForDefaultPrevented: false }),
    style: {
      ...props.style,
      ...{
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
MenubarContent.displayName = CONTENT_NAME3;
var GROUP_NAME3 = "MenubarGroup";
var MenubarGroup = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...groupProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
});
MenubarGroup.displayName = GROUP_NAME3;
var LABEL_NAME2 = "MenubarLabel";
var MenubarLabel = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...labelProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
});
MenubarLabel.displayName = LABEL_NAME2;
var ITEM_NAME3 = "MenubarItem";
var MenubarItem = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...itemProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
});
MenubarItem.displayName = ITEM_NAME3;
var CHECKBOX_ITEM_NAME2 = "MenubarCheckboxItem";
var MenubarCheckboxItem = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
MenubarCheckboxItem.displayName = CHECKBOX_ITEM_NAME2;
var RADIO_GROUP_NAME2 = "MenubarRadioGroup";
var MenubarRadioGroup = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
MenubarRadioGroup.displayName = RADIO_GROUP_NAME2;
var RADIO_ITEM_NAME2 = "MenubarRadioItem";
var MenubarRadioItem = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
MenubarRadioItem.displayName = RADIO_ITEM_NAME2;
var INDICATOR_NAME = "MenubarItemIndicator";
var MenubarItemIndicator = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
MenubarItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME2 = "MenubarSeparator";
var MenubarSeparator = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
MenubarSeparator.displayName = SEPARATOR_NAME2;
var ARROW_NAME3 = "MenubarArrow";
var MenubarArrow = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...arrowProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(Arrow22, { ...menuScope, ...arrowProps, ref: forwardedRef });
});
MenubarArrow.displayName = ARROW_NAME3;
var SUB_NAME2 = "MenubarSub";
var MenubarSub = (props) => {
  const { __scopeMenubar, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SUB_NAME2
  });
  return /* @__PURE__ */ jsx16(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
MenubarSub.displayName = SUB_NAME2;
var SUB_TRIGGER_NAME2 = "MenubarSubTrigger";
var MenubarSubTrigger = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(SubTrigger, {
    "data-radix-menubar-subtrigger": "",
    ...menuScope,
    ...subTriggerProps,
    ref: forwardedRef
  });
});
MenubarSubTrigger.displayName = SUB_TRIGGER_NAME2;
var SUB_CONTENT_NAME2 = "MenubarSubContent";
var MenubarSubContent = React35.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsx16(SubContent, {
    ...menuScope,
    "data-radix-menubar-content": "",
    ...subContentProps,
    ref: forwardedRef,
    style: {
      ...props.style,
      ...{
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
MenubarSubContent.displayName = SUB_CONTENT_NAME2;
function wrapArray3(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var SvgIcon3 = createSpriteIcon("lucide");
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React36.useRef(null);
  const contentRef = React36.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return /* @__PURE__ */ jsx18(DialogProvider, {
    scope: __scopeDialog,
    triggerRef,
    contentRef,
    contentId: useId(),
    titleId: useId(),
    descriptionId: useId(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: React36.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
    modal,
    children
  });
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME2 = "DialogTrigger";
var DialogTrigger = React36.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...triggerProps } = props;
  const context = useDialogContext(TRIGGER_NAME2, __scopeDialog);
  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
  return /* @__PURE__ */ jsx18(Primitive.button, {
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": getState(context.open),
    ...triggerProps,
    ref: composedTriggerRef,
    onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
  });
});
DialogTrigger.displayName = TRIGGER_NAME2;
var PORTAL_NAME4 = "DialogPortal";
var [PortalProvider2, usePortalContext2] = createDialogContext(PORTAL_NAME4, {
  forceMount: undefined
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME4, __scopeDialog);
  return /* @__PURE__ */ jsx18(PortalProvider2, { scope: __scopeDialog, forceMount, children: React36.Children.map(children, (child) => /* @__PURE__ */ jsx18(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx18(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME4;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React36.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext2(OVERLAY_NAME, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...overlayProps } = props;
  const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
  return context.modal ? /* @__PURE__ */ jsx18(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsx18(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
});
DialogOverlay.displayName = OVERLAY_NAME;
var Slot3 = createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = React36.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...overlayProps } = props;
  const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
  return /* @__PURE__ */ jsx18(Combination_default, { as: Slot3, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsx18(Primitive.div, {
    "data-state": getState(context.open),
    ...overlayProps,
    ref: forwardedRef,
    style: { pointerEvents: "auto", ...overlayProps.style }
  }) });
});
var CONTENT_NAME4 = "DialogContent";
var DialogContent = React36.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext2(CONTENT_NAME4, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = useDialogContext(CONTENT_NAME4, props.__scopeDialog);
  return /* @__PURE__ */ jsx18(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsx18(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx18(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
});
DialogContent.displayName = CONTENT_NAME4;
var DialogContentModal = React36.forwardRef((props, forwardedRef) => {
  const context = useDialogContext(CONTENT_NAME4, props.__scopeDialog);
  const contentRef = React36.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
  React36.useEffect(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ jsx18(DialogContentImpl, {
    ...props,
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
      event.preventDefault();
      context.triggerRef.current?.focus();
    }),
    onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (isRightClick)
        event.preventDefault();
    }),
    onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => event.preventDefault())
  });
});
var DialogContentNonModal = React36.forwardRef((props, forwardedRef) => {
  const context = useDialogContext(CONTENT_NAME4, props.__scopeDialog);
  const hasInteractedOutsideRef = React36.useRef(false);
  const hasPointerDownOutsideRef = React36.useRef(false);
  return /* @__PURE__ */ jsx18(DialogContentImpl, {
    ...props,
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      props.onCloseAutoFocus?.(event);
      if (!event.defaultPrevented) {
        if (!hasInteractedOutsideRef.current)
          context.triggerRef.current?.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      props.onInteractOutside?.(event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown") {
          hasPointerDownOutsideRef.current = true;
        }
      }
      const target = event.target;
      const targetIsTrigger = context.triggerRef.current?.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
        event.preventDefault();
      }
    }
  });
});
var DialogContentImpl = React36.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
  const context = useDialogContext(CONTENT_NAME4, __scopeDialog);
  const contentRef = React36.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, contentRef);
  useFocusGuards();
  return /* @__PURE__ */ jsxs3(Fragment7, { children: [
    /* @__PURE__ */ jsx18(FocusScope, {
      asChild: true,
      loop: true,
      trapped: trapFocus,
      onMountAutoFocus: onOpenAutoFocus,
      onUnmountAutoFocus: onCloseAutoFocus,
      children: /* @__PURE__ */ jsx18(DismissableLayer, {
        role: "dialog",
        id: context.contentId,
        "aria-describedby": context.descriptionId,
        "aria-labelledby": context.titleId,
        "data-state": getState(context.open),
        ...contentProps,
        ref: composedRefs,
        onDismiss: () => context.onOpenChange(false)
      })
    }),
    /* @__PURE__ */ jsxs3(Fragment7, { children: [
      /* @__PURE__ */ jsx18(TitleWarning, { titleId: context.titleId }),
      /* @__PURE__ */ jsx18(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
    ] })
  ] });
});
var TITLE_NAME = "DialogTitle";
var DialogTitle = React36.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...titleProps } = props;
  const context = useDialogContext(TITLE_NAME, __scopeDialog);
  return /* @__PURE__ */ jsx18(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
});
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React36.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...descriptionProps } = props;
  const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
  return /* @__PURE__ */ jsx18(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
});
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React36.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...closeProps } = props;
  const context = useDialogContext(CLOSE_NAME, __scopeDialog);
  return /* @__PURE__ */ jsx18(Primitive.button, {
    type: "button",
    ...closeProps,
    ref: forwardedRef,
    onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
  });
});
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME4,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React36.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React36.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Link2 = React37.forwardRef(function Link3(props, ref) {
  return /* @__PURE__ */ jsx20(RouterLink, {
    ...props,
    to: props.href,
    ref
  });
});
var MenubarContext = createContext6(null);

// ../componentry/dist/impetus/theme/index.js
import clsx7 from "clsx";
import { useEffect as useEffect18, useState as useState17 } from "react";

// ../../node_modules/next-themes/dist/index.mjs
import * as t from "react";
"use client";
var M = (e, i, s, u, m, a, l, h) => {
  let d = document.documentElement, w = ["light", "dark"];
  function p(n) {
    (Array.isArray(e) ? e : [e]).forEach((y) => {
      let k = y === "class", S = k && a ? m.map((f) => a[f] || f) : m;
      k ? (d.classList.remove(...S), d.classList.add(a && a[n] ? a[n] : n)) : d.setAttribute(y, n);
    }), R(n);
  }
  function R(n) {
    h && w.includes(n) && (d.style.colorScheme = n);
  }
  function c() {
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  }
  if (u)
    p(u);
  else
    try {
      let n = localStorage.getItem(i) || s, y = l && n === "system" ? c() : n;
      p(y);
    } catch (n) {}
};
var x = t.createContext(undefined);
var U = { setTheme: (e) => {}, themes: [] };
var z = () => {
  var e;
  return (e = t.useContext(x)) != null ? e : U;
};
var _ = t.memo(({ forcedTheme: e, storageKey: i, attribute: s, enableSystem: u, enableColorScheme: m, defaultTheme: a, value: l, themes: h, nonce: d, scriptProps: w }) => {
  let p = JSON.stringify([s, i, a, e, h, l, u, m]).slice(1, -1);
  return t.createElement("script", { ...w, suppressHydrationWarning: true, nonce: typeof window == "undefined" ? d : "", dangerouslySetInnerHTML: { __html: `(${M.toString()})(${p})` } });
});

// ../componentry/dist/impetus/theme/index.js
import { jsx as jsx24 } from "react/jsx-runtime";
var useTheme = z;
var THEME_OPTIONS = { theme: { light: "light", dark: "dark" } };
var ThemeSwitchButton = ({ themeContext, theme, spriteUrl, className, classTheme }) => {
  const [mounted, setMounted] = useState17(false);
  useEffect18(() => setMounted(true), []);
  const resolvedTheme = themeContext?.resolvedTheme;
  const setTheme = themeContext?.setTheme;
  if (!mounted)
    return null;
  return /* @__PURE__ */ jsx24("button", {
    type: "button",
    className: clsx7("size-5 hover:animate-rotate", classTheme),
    onClick: (e) => {
      if (!setTheme)
        return;
      setTheme(resolvedTheme === theme.theme.dark ? theme.theme.light : theme.theme.dark);
      e.preventDefault();
      e.stopPropagation();
    },
    "aria-label": "theme switch",
    children: resolvedTheme === theme.theme.dark ? /* @__PURE__ */ jsx24(SpriteIcon, {
      spriteUrl,
      iconId: "Moon",
      className: clsx7("size-5", className)
    }) : /* @__PURE__ */ jsx24(SpriteIcon, {
      spriteUrl,
      iconId: "Sun",
      className: clsx7("size-5", className)
    })
  });
};
var ThemeSwitch = ({ theme = THEME_OPTIONS, spriteUrl, className, classTheme, children }) => {
  const nextThemeContext = useTheme();
  const themeContext = nextThemeContext ? { resolvedTheme: nextThemeContext.resolvedTheme, setTheme: nextThemeContext.setTheme } : null;
  if (children) {
    return children({ themeContext, theme, spriteUrl, className, classTheme });
  }
  return /* @__PURE__ */ jsx24(ThemeSwitchButton, {
    themeContext,
    theme,
    spriteUrl,
    className,
    classTheme
  });
};

// ../componentry/dist/vibrant/index.js
import * as React39 from "react";
import * as React432 from "react";
import clsx24 from "clsx";
import * as React214 from "react";
import * as React68 from "react";
import { Fragment as Fragment23, jsx as jsx40 } from "react/jsx-runtime";
import clsx9 from "clsx";
import { jsx as jsx210 } from "react/jsx-runtime";
import { jsx as jsx35, jsxs as jsxs8 } from "react/jsx-runtime";
import * as React332 from "react";
import React510 from "react";
import * as React410 from "react";
import { jsx as jsx44 } from "react/jsx-runtime";
import { jsx as jsx53 } from "react/jsx-runtime";
import React223 from "react";
import { jsx as jsx223 } from "react/jsx-runtime";
import * as React69 from "react";
import { jsx as jsx63 } from "react/jsx-runtime";
import * as React102 from "react";
import * as React72 from "react";
import { jsx as jsx72 } from "react/jsx-runtime";
import * as React82 from "react";
import * as React92 from "react";
import { jsx as jsx82 } from "react/jsx-runtime";
import * as React112 from "react";
import * as React122 from "react";
import { jsx as jsx92 } from "react/jsx-runtime";
import * as React142 from "react";
import * as React132 from "react";
import * as React182 from "react";
import * as React152 from "react";
import { useLayoutEffect as useLayoutEffect32 } from "react";
import * as React162 from "react";
import { jsx as jsx102 } from "react/jsx-runtime";
import * as React172 from "react";
import { jsx as jsx112 } from "react/jsx-runtime";
import * as React192 from "react";
import { jsx as jsx122 } from "react/jsx-runtime";
import * as React202 from "react";
import * as React232 from "react";
import * as React215 from "react";
import * as React242 from "react";
import { jsx as jsx132 } from "react/jsx-runtime";
import * as React323 from "react";
import * as React282 from "react";
import { useState as useState92 } from "react";
import * as React262 from "react";
import * as React272 from "react";
import * as React312 from "react";
import * as React302 from "react";
import * as React292 from "react";
import { Fragment as Fragment62, jsx as jsx142, jsxs as jsxs22 } from "react/jsx-runtime";
import clsx33 from "clsx";
import { jsx as jsx152, jsxs as jsxs32 } from "react/jsx-runtime";
import { jsx as jsx162, jsxs as jsxs42, Fragment as Fragment72 } from "react/jsx-runtime";
import clsx43 from "clsx";

// ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
import * as React40 from "react";
import * as ReactDOM3 from "react-dom";

// ../../node_modules/@radix-ui/react-slot/dist/index.mjs
import * as React38 from "react";

// ../../node_modules/@radix-ui/react-compose-refs/dist/index.mjs
import * as React26 from "react";
function setRef2(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== undefined) {
    ref.current = value;
  }
}
function composeRefs2(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef2(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0;i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef2(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs2(...refs) {
  return React26.useCallback(composeRefs2(...refs), refs);
}

// ../../node_modules/@radix-ui/react-slot/dist/index.mjs
import { Fragment as Fragment22, jsx as jsx26 } from "react/jsx-runtime";
function createSlot2(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone2(ownerName);
  const Slot22 = React38.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React38.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable2);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React38.Children.count(newElement) > 1)
            return React38.Children.only(null);
          return React38.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsx26(SlotClone, { ...slotProps, ref: forwardedRef, children: React38.isValidElement(newElement) ? React38.cloneElement(newElement, undefined, newChildren) : null });
    }
    return /* @__PURE__ */ jsx26(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
function createSlotClone2(ownerName) {
  const SlotClone = React38.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React38.isValidElement(children)) {
      const childrenRef = getElementRef3(children);
      const props2 = mergeProps2(slotProps, children.props);
      if (children.type !== React38.Fragment) {
        props2.ref = forwardedRef ? composeRefs2(forwardedRef, childrenRef) : childrenRef;
      }
      return React38.cloneElement(children, props2);
    }
    return React38.Children.count(children) > 1 ? React38.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER2 = Symbol("radix.slottable");
function isSlottable2(child) {
  return React38.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER2;
}
function mergeProps2(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef3(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
import { jsx as jsx27 } from "react/jsx-runtime";
var NODES2 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive2 = NODES2.reduce((primitive, node) => {
  const Slot = createSlot2(`Primitive.${node}`);
  const Node2 = React40.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsx27(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent2(target, event) {
  if (target)
    ReactDOM3.flushSync(() => target.dispatchEvent(event));
}
var Root4 = Primitive2;

// ../../node_modules/@radix-ui/react-context/dist/index.mjs
import * as React41 from "react";
import { jsx as jsx28 } from "react/jsx-runtime";
function createContext23(rootComponentName, defaultContext) {
  const Context = React41.createContext(defaultContext);
  const Provider = (props) => {
    const { children, ...context } = props;
    const value = React41.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsx28(Context.Provider, { value, children });
  };
  Provider.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React41.useContext(Context);
    if (context)
      return context;
    if (defaultContext !== undefined)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext22];
}
function createContextScope2(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React41.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const value = React41.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsx28(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const context = React41.useContext(Context);
      if (context)
        return context;
      if (defaultContext !== undefined)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React41.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return React41.useMemo(() => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }), [scope, contexts]);
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes2(createScope, ...createContextScopeDeps)];
}
function composeContextScopes2(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React41.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// ../../node_modules/@radix-ui/react-collection/dist/index.mjs
import React42 from "react";
import { jsx as jsx29 } from "react/jsx-runtime";
import React210 from "react";
import { jsx as jsx25 } from "react/jsx-runtime";
"use client";
function createCollection2(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope4] = createContextScope2(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React42.useRef(null);
    const itemMap = React42.useRef(/* @__PURE__ */ new Map).current;
    return /* @__PURE__ */ jsx29(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot2(COLLECTION_SLOT_NAME);
  const CollectionSlot = React42.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = useComposedRefs2(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ jsx29(CollectionSlotImpl, { ref: composedRefs, children });
  });
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot2(ITEM_SLOT_NAME);
  const CollectionItemSlot = React42.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = React42.useRef(null);
    const composedRefs = useComposedRefs2(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    React42.useEffect(() => {
      context.itemMap.set(ref, { ref, ...itemData });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ jsx29(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
  });
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection4(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React42.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort((a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current));
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection4,
    createCollectionScope4
  ];
}
var __instanciated2 = /* @__PURE__ */ new WeakMap;
var OrderedDict2 = class _OrderedDict2 extends Map {
  #keys;
  constructor(entries) {
    super(entries);
    this.#keys = [...super.keys()];
    __instanciated2.set(this, true);
  }
  set(key, value) {
    if (__instanciated2.get(this)) {
      if (this.has(key)) {
        this.#keys[this.#keys.indexOf(key)] = key;
      } else {
        this.#keys.push(key);
      }
    }
    super.set(key, value);
    return this;
  }
  insert(index2, key, value) {
    const has = this.has(key);
    const length = this.#keys.length;
    const relativeIndex = toSafeInteger2(index2);
    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
    if (safeIndex === this.size || has && safeIndex === this.size - 1 || safeIndex === -1) {
      this.set(key, value);
      return this;
    }
    const size4 = this.size + (has ? 0 : 1);
    if (relativeIndex < 0) {
      actualIndex++;
    }
    const keys = [...this.#keys];
    let nextValue;
    let shouldSkip = false;
    for (let i = actualIndex;i < size4; i++) {
      if (actualIndex === i) {
        let nextKey = keys[i];
        if (keys[i] === key) {
          nextKey = keys[i + 1];
        }
        if (has) {
          this.delete(key);
        }
        nextValue = this.get(nextKey);
        this.set(key, value);
      } else {
        if (!shouldSkip && keys[i - 1] === key) {
          shouldSkip = true;
        }
        const currentKey = keys[shouldSkip ? i : i - 1];
        const currentValue = nextValue;
        nextValue = this.get(currentKey);
        this.delete(currentKey);
        this.set(currentKey, currentValue);
      }
    }
    return this;
  }
  with(index2, key, value) {
    const copy = new _OrderedDict2(this);
    copy.insert(index2, key, value);
    return copy;
  }
  before(key) {
    const index2 = this.#keys.indexOf(key) - 1;
    if (index2 < 0) {
      return;
    }
    return this.entryAt(index2);
  }
  setBefore(key, newKey, value) {
    const index2 = this.#keys.indexOf(key);
    if (index2 === -1) {
      return this;
    }
    return this.insert(index2, newKey, value);
  }
  after(key) {
    let index2 = this.#keys.indexOf(key);
    index2 = index2 === -1 || index2 === this.size - 1 ? -1 : index2 + 1;
    if (index2 === -1) {
      return;
    }
    return this.entryAt(index2);
  }
  setAfter(key, newKey, value) {
    const index2 = this.#keys.indexOf(key);
    if (index2 === -1) {
      return this;
    }
    return this.insert(index2 + 1, newKey, value);
  }
  first() {
    return this.entryAt(0);
  }
  last() {
    return this.entryAt(-1);
  }
  clear() {
    this.#keys = [];
    return super.clear();
  }
  delete(key) {
    const deleted = super.delete(key);
    if (deleted) {
      this.#keys.splice(this.#keys.indexOf(key), 1);
    }
    return deleted;
  }
  deleteAt(index2) {
    const key = this.keyAt(index2);
    if (key !== undefined) {
      return this.delete(key);
    }
    return false;
  }
  at(index2) {
    const key = at2(this.#keys, index2);
    if (key !== undefined) {
      return this.get(key);
    }
  }
  entryAt(index2) {
    const key = at2(this.#keys, index2);
    if (key !== undefined) {
      return [key, this.get(key)];
    }
  }
  indexOf(key) {
    return this.#keys.indexOf(key);
  }
  keyAt(index2) {
    return at2(this.#keys, index2);
  }
  from(key, offset4) {
    const index2 = this.indexOf(key);
    if (index2 === -1) {
      return;
    }
    let dest = index2 + offset4;
    if (dest < 0)
      dest = 0;
    if (dest >= this.size)
      dest = this.size - 1;
    return this.at(dest);
  }
  keyFrom(key, offset4) {
    const index2 = this.indexOf(key);
    if (index2 === -1) {
      return;
    }
    let dest = index2 + offset4;
    if (dest < 0)
      dest = 0;
    if (dest >= this.size)
      dest = this.size - 1;
    return this.keyAt(dest);
  }
  find(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return entry;
      }
      index2++;
    }
    return;
  }
  findIndex(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return index2;
      }
      index2++;
    }
    return -1;
  }
  filter(predicate, thisArg) {
    const entries = [];
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        entries.push(entry);
      }
      index2++;
    }
    return new _OrderedDict2(entries);
  }
  map(callbackfn, thisArg) {
    const entries = [];
    let index2 = 0;
    for (const entry of this) {
      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index2, this])]);
      index2++;
    }
    return new _OrderedDict2(entries);
  }
  reduce(...args) {
    const [callbackfn, initialValue] = args;
    let index2 = 0;
    let accumulator = initialValue ?? this.at(0);
    for (const entry of this) {
      if (index2 === 0 && args.length === 1) {
        accumulator = entry;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index2, this]);
      }
      index2++;
    }
    return accumulator;
  }
  reduceRight(...args) {
    const [callbackfn, initialValue] = args;
    let accumulator = initialValue ?? this.at(-1);
    for (let index2 = this.size - 1;index2 >= 0; index2--) {
      const entry = this.at(index2);
      if (index2 === this.size - 1 && args.length === 1) {
        accumulator = entry;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index2, this]);
      }
    }
    return accumulator;
  }
  toSorted(compareFn) {
    const entries = [...this.entries()].sort(compareFn);
    return new _OrderedDict2(entries);
  }
  toReversed() {
    const reversed = new _OrderedDict2;
    for (let index2 = this.size - 1;index2 >= 0; index2--) {
      const key = this.keyAt(index2);
      const element = this.get(key);
      reversed.set(key, element);
    }
    return reversed;
  }
  toSpliced(...args) {
    const entries = [...this.entries()];
    entries.splice(...args);
    return new _OrderedDict2(entries);
  }
  slice(start, end) {
    const result = new _OrderedDict2;
    let stop = this.size - 1;
    if (start === undefined) {
      return result;
    }
    if (start < 0) {
      start = start + this.size;
    }
    if (end !== undefined && end > 0) {
      stop = end - 1;
    }
    for (let index2 = start;index2 <= stop; index2++) {
      const key = this.keyAt(index2);
      const element = this.get(key);
      result.set(key, element);
    }
    return result;
  }
  every(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (!Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return false;
      }
      index2++;
    }
    return true;
  }
  some(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return true;
      }
      index2++;
    }
    return false;
  }
};
function at2(array, index2) {
  if ("at" in Array.prototype) {
    return Array.prototype.at.call(array, index2);
  }
  const actualIndex = toSafeIndex2(array, index2);
  return actualIndex === -1 ? undefined : array[actualIndex];
}
function toSafeIndex2(array, index2) {
  const length = array.length;
  const relativeIndex = toSafeInteger2(index2);
  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
}
function toSafeInteger2(number) {
  return number !== number || number === 0 ? 0 : Math.trunc(number);
}
function createCollection22(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope4] = createContextScope2(PROVIDER_NAME);
  const [CollectionContextProvider, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
    collectionElement: null,
    collectionRef: { current: null },
    collectionRefObject: { current: null },
    itemMap: new OrderedDict2,
    setItemMap: () => {
      return;
    }
  });
  const CollectionProvider = ({ state, ...props }) => {
    return state ? /* @__PURE__ */ jsx25(CollectionProviderImpl, { ...props, state }) : /* @__PURE__ */ jsx25(CollectionInit, { ...props });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const CollectionInit = (props) => {
    const state = useInitCollection();
    return /* @__PURE__ */ jsx25(CollectionProviderImpl, { ...props, state });
  };
  CollectionInit.displayName = PROVIDER_NAME + "Init";
  const CollectionProviderImpl = (props) => {
    const { scope, children, state } = props;
    const ref = React210.useRef(null);
    const [collectionElement, setCollectionElement] = React210.useState(null);
    const composeRefs3 = useComposedRefs2(ref, setCollectionElement);
    const [itemMap, setItemMap] = state;
    React210.useEffect(() => {
      if (!collectionElement)
        return;
      const observer = getChildListObserver(() => {});
      observer.observe(collectionElement, {
        childList: true,
        subtree: true
      });
      return () => {
        observer.disconnect();
      };
    }, [collectionElement]);
    return /* @__PURE__ */ jsx25(CollectionContextProvider, {
      scope,
      itemMap,
      setItemMap,
      collectionRef: composeRefs3,
      collectionRefObject: ref,
      collectionElement,
      children
    });
  };
  CollectionProviderImpl.displayName = PROVIDER_NAME + "Impl";
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot2(COLLECTION_SLOT_NAME);
  const CollectionSlot = React210.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = useComposedRefs2(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ jsx25(CollectionSlotImpl, { ref: composedRefs, children });
  });
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot2(ITEM_SLOT_NAME);
  const CollectionItemSlot = React210.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = React210.useRef(null);
    const [element, setElement] = React210.useState(null);
    const composedRefs = useComposedRefs2(forwardedRef, ref, setElement);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    const { setItemMap } = context;
    const itemDataRef = React210.useRef(itemData);
    if (!shallowEqual(itemDataRef.current, itemData)) {
      itemDataRef.current = itemData;
    }
    const memoizedItemData = itemDataRef.current;
    React210.useEffect(() => {
      const itemData2 = memoizedItemData;
      setItemMap((map) => {
        if (!element) {
          return map;
        }
        if (!map.has(element)) {
          map.set(element, { ...itemData2, element });
          return map.toSorted(sortByDocumentPosition);
        }
        return map.set(element, { ...itemData2, element }).toSorted(sortByDocumentPosition);
      });
      return () => {
        setItemMap((map) => {
          if (!element || !map.has(element)) {
            return map;
          }
          map.delete(element);
          return new OrderedDict2(map);
        });
      };
    }, [element, memoizedItemData, setItemMap]);
    return /* @__PURE__ */ jsx25(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
  });
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useInitCollection() {
    return React210.useState(new OrderedDict2);
  }
  function useCollection4(scope) {
    const { itemMap } = useCollectionContext(name + "CollectionConsumer", scope);
    return itemMap;
  }
  const functions = {
    createCollectionScope: createCollectionScope4,
    useCollection: useCollection4,
    useInitCollection
  };
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    functions
  ];
}
function shallowEqual(a, b) {
  if (a === b)
    return true;
  if (typeof a !== "object" || typeof b !== "object")
    return false;
  if (a == null || b == null)
    return false;
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length)
    return false;
  for (const key of keysA) {
    if (!Object.prototype.hasOwnProperty.call(b, key))
      return false;
    if (a[key] !== b[key])
      return false;
  }
  return true;
}
function isElementPreceding(a, b) {
  return !!(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function sortByDocumentPosition(a, b) {
  return !a[1].element || !b[1].element ? 0 : isElementPreceding(a[1].element, b[1].element) ? -1 : 1;
}
function getChildListObserver(callback) {
  const observer = new MutationObserver((mutationsList) => {
    for (const mutation of mutationsList) {
      if (mutation.type === "childList") {
        callback();
        return;
      }
    }
  });
  return observer;
}

// ../../node_modules/@radix-ui/primitive/dist/index.mjs
var canUseDOM2 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function composeEventHandlers2(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
import * as React45 from "react";

// ../../node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
import * as React43 from "react";
var useLayoutEffect23 = globalThis?.document ? React43.useLayoutEffect : () => {};

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
import * as React212 from "react";

// ../../node_modules/@radix-ui/react-use-effect-event/dist/index.mjs
import * as React44 from "react";
var useReactEffectEvent = React44[" useEffectEvent ".trim().toString()];
var useReactInsertionEffect = React44[" useInsertionEffect ".trim().toString()];
function useEffectEvent(callback) {
  if (typeof useReactEffectEvent === "function") {
    return useReactEffectEvent(callback);
  }
  const ref = React44.useRef(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  if (typeof useReactInsertionEffect === "function") {
    useReactInsertionEffect(() => {
      ref.current = callback;
    });
  } else {
    useLayoutEffect23(() => {
      ref.current = callback;
    });
  }
  return React44.useMemo(() => (...args) => ref.current?.(...args), []);
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var useInsertionEffect2 = React45[" useInsertionEffect ".trim().toString()] || useLayoutEffect23;
function useControllableState2({
  prop,
  defaultProp,
  onChange = () => {},
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState2({
    defaultProp,
    onChange
  });
  const isControlled = prop !== undefined;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React45.useRef(prop !== undefined);
    React45.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(`${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`);
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React45.useCallback((nextValue) => {
    if (isControlled) {
      const value2 = isFunction2(nextValue) ? nextValue(prop) : nextValue;
      if (value2 !== prop) {
        onChangeRef.current?.(value2);
      }
    } else {
      setUncontrolledProp(nextValue);
    }
  }, [isControlled, prop, setUncontrolledProp, onChangeRef]);
  return [value, setValue];
}
function useUncontrolledState2({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React45.useState(defaultProp);
  const prevValueRef = React45.useRef(value);
  const onChangeRef = React45.useRef(onChange);
  useInsertionEffect2(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React45.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction2(value) {
  return typeof value === "function";
}
var SYNC_STATE2 = Symbol("RADIX:SYNC_STATE");

// ../../node_modules/@radix-ui/react-presence/dist/index.mjs
import * as React213 from "react";
import * as React46 from "react";
"use client";
function useStateMachine2(initialState, machine) {
  return React46.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence2 = (props) => {
  const { present, children } = props;
  const presence = usePresence2(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React213.Children.only(children);
  const ref = useComposedRefs2(presence.ref, getElementRef5(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React213.cloneElement(child, { ref }) : null;
};
Presence2.displayName = "Presence";
function usePresence2(present) {
  const [node, setNode] = React213.useState();
  const stylesRef = React213.useRef(null);
  const prevPresentRef = React213.useRef(present);
  const prevAnimationNameRef = React213.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine2(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React213.useEffect(() => {
    const currentAnimationName = getAnimationName2(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect23(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName2(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect23(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName2(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName2(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React213.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName2(styles) {
  return styles?.animationName || "none";
}
function getElementRef5(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/@radix-ui/react-id/dist/index.mjs
import * as React47 from "react";
var useReactId2 = React47[" useId ".trim().toString()] || (() => {
  return;
});
var count3 = 0;
function useId2(deterministicId) {
  const [id, setId] = React47.useState(useReactId2());
  useLayoutEffect23(() => {
    if (!deterministicId)
      setId((reactId) => reactId ?? String(count3++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../../node_modules/@radix-ui/react-direction/dist/index.mjs
import * as React48 from "react";
import { jsx as jsx30 } from "react/jsx-runtime";
var DirectionContext2 = React48.createContext(undefined);
function useDirection2(localDir) {
  const globalDir = React48.useContext(DirectionContext2);
  return localDir || globalDir || "ltr";
}

// ../../node_modules/@radix-ui/react-dialog/dist/index.mjs
import * as React62 from "react";

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
import * as React51 from "react";

// ../../node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
import * as React49 from "react";
function useCallbackRef3(callback) {
  const callbackRef = React49.useRef(callback);
  React49.useEffect(() => {
    callbackRef.current = callback;
  });
  return React49.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}

// ../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
import * as React50 from "react";
function useEscapeKeydown2(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef3(onEscapeKeyDownProp);
  React50.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
import { jsx as jsx31 } from "react/jsx-runtime";
"use client";
var DISMISSABLE_LAYER_NAME2 = "DismissableLayer";
var CONTEXT_UPDATE2 = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE2 = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE2 = "dismissableLayer.focusOutside";
var originalBodyPointerEvents2;
var DismissableLayerContext2 = React51.createContext({
  layers: /* @__PURE__ */ new Set,
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set,
  branches: /* @__PURE__ */ new Set
});
var DismissableLayer2 = React51.forwardRef((props, forwardedRef) => {
  const {
    disableOutsidePointerEvents = false,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss,
    ...layerProps
  } = props;
  const context = React51.useContext(DismissableLayerContext2);
  const [node, setNode] = React51.useState(null);
  const ownerDocument = node?.ownerDocument ?? globalThis?.document;
  const [, force] = React51.useState({});
  const composedRefs = useComposedRefs2(forwardedRef, (node2) => setNode(node2));
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node ? layers.indexOf(node) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = usePointerDownOutside2((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside?.(event);
    onInteractOutside?.(event);
    if (!event.defaultPrevented)
      onDismiss?.();
  }, ownerDocument);
  const focusOutside = useFocusOutside2((event) => {
    const target = event.target;
    const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
    if (isFocusInBranch)
      return;
    onFocusOutside?.(event);
    onInteractOutside?.(event);
    if (!event.defaultPrevented)
      onDismiss?.();
  }, ownerDocument);
  useEscapeKeydown2((event) => {
    const isHighestLayer = index2 === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown?.(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  React51.useEffect(() => {
    if (!node)
      return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        originalBodyPointerEvents2 = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node);
    }
    context.layers.add(node);
    dispatchUpdate2();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
        ownerDocument.body.style.pointerEvents = originalBodyPointerEvents2;
      }
    };
  }, [node, ownerDocument, disableOutsidePointerEvents, context]);
  React51.useEffect(() => {
    return () => {
      if (!node)
        return;
      context.layers.delete(node);
      context.layersWithOutsidePointerEventsDisabled.delete(node);
      dispatchUpdate2();
    };
  }, [node, context]);
  React51.useEffect(() => {
    const handleUpdate = () => force({});
    document.addEventListener(CONTEXT_UPDATE2, handleUpdate);
    return () => document.removeEventListener(CONTEXT_UPDATE2, handleUpdate);
  }, []);
  return /* @__PURE__ */ jsx31(Primitive2.div, {
    ...layerProps,
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : undefined,
      ...props.style
    },
    onFocusCapture: composeEventHandlers2(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: composeEventHandlers2(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: composeEventHandlers2(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  });
});
DismissableLayer2.displayName = DISMISSABLE_LAYER_NAME2;
var BRANCH_NAME2 = "DismissableLayerBranch";
var DismissableLayerBranch2 = React51.forwardRef((props, forwardedRef) => {
  const context = React51.useContext(DismissableLayerContext2);
  const ref = React51.useRef(null);
  const composedRefs = useComposedRefs2(forwardedRef, ref);
  React51.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsx31(Primitive2.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch2.displayName = BRANCH_NAME2;
function usePointerDownOutside2(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef3(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React51.useRef(false);
  const handleClickRef = React51.useRef(() => {});
  React51.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent2(POINTER_DOWN_OUTSIDE2, handlePointerDownOutside, eventDetail, { discrete: true });
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside2(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef3(onFocusOutside);
  const isFocusInsideReactTreeRef = React51.useRef(false);
  React51.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent2(FOCUS_OUTSIDE2, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate2() {
  const event = new CustomEvent(CONTEXT_UPDATE2);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent2(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent2(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// ../../node_modules/@radix-ui/react-focus-scope/dist/index.mjs
import * as React52 from "react";
import { jsx as jsx34 } from "react/jsx-runtime";
"use client";
var AUTOFOCUS_ON_MOUNT2 = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT2 = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS3 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME2 = "FocusScope";
var FocusScope2 = React52.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React52.useState(null);
  const onMountAutoFocus = useCallbackRef3(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef3(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React52.useRef(null);
  const composedRefs = useComposedRefs2(forwardedRef, (node) => setContainer(node));
  const focusScope = React52.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React52.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus2(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus2(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus2(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React52.useEffect(() => {
    if (container) {
      focusScopesStack2.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT2, EVENT_OPTIONS3);
        container.addEventListener(AUTOFOCUS_ON_MOUNT2, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst4(removeLinks2(getTabbableCandidates2(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus2(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT2, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT2, EVENT_OPTIONS3);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT2, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus2(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT2, onUnmountAutoFocus);
          focusScopesStack2.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React52.useCallback((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container2 = event.currentTarget;
      const [first, last] = getTabbableEdges2(container2);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container2)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop)
            focus2(first, { select: true });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop)
            focus2(last, { select: true });
        }
      }
    }
  }, [loop, trapped, focusScope.paused]);
  return /* @__PURE__ */ jsx34(Primitive2.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope2.displayName = FOCUS_SCOPE_NAME2;
function focusFirst4(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus2(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges2(container) {
  const candidates = getTabbableCandidates2(container);
  const first = findVisible2(candidates, container);
  const last = findVisible2(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates2(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible2(elements, container) {
  for (const element of elements) {
    if (!isHidden2(element, { upTo: container }))
      return element;
  }
}
function isHidden2(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== undefined && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput2(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus2(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput2(element) && select)
      element.select();
  }
}
var focusScopesStack2 = createFocusScopesStack2();
function createFocusScopesStack2() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove2(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove2(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove2(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks2(items) {
  return items.filter((item) => item.tagName !== "A");
}

// ../../node_modules/@radix-ui/react-portal/dist/index.mjs
import * as React53 from "react";
import ReactDOM5 from "react-dom";
import { jsx as jsx36 } from "react/jsx-runtime";
"use client";
var PORTAL_NAME5 = "Portal";
var Portal3 = React53.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React53.useState(false);
  useLayoutEffect23(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? ReactDOM5.createPortal(/* @__PURE__ */ jsx36(Primitive2.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal3.displayName = PORTAL_NAME5;

// ../../node_modules/@radix-ui/react-focus-guards/dist/index.mjs
import * as React54 from "react";
"use client";
var count5 = 0;
function useFocusGuards2() {
  React54.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard2());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard2());
    count5++;
    return () => {
      if (count5 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count5--;
    };
  }, []);
}
function createFocusGuard2() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// ../../node_modules/tslib/tslib.es6.mjs
var __assign2 = function() {
  __assign2 = Object.assign || function __assign(t2) {
    for (var s, i = 1, n = arguments.length;i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
}
function __spreadArray2(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar;i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
import * as React61 from "react";

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
import * as React57 from "react";

// ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName2 = "right-scroll-bar-position";
var fullWidthClassName2 = "width-before-scroll-bar";
var noScrollbarsClassName2 = "with-scroll-bars-hidden";
var removedBarSizeVariable2 = "--removed-body-scroll-bar-size";

// ../../node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef2(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../../node_modules/use-callback-ref/dist/es2015/useRef.js
import { useState as useState25 } from "react";
function useCallbackRef5(initialValue, callback) {
  var ref = useState25(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
import * as React55 from "react";
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? React55.useLayoutEffect : React55.useEffect;
var currentValues2 = new WeakMap;
function useMergeRefs2(refs, defaultValue) {
  var callbackRef = useCallbackRef5(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef2(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect2(function() {
    var oldValue = currentValues2.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef2(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef2(ref, current_1);
        }
      });
    }
    currentValues2.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
// ../../node_modules/use-sidecar/dist/es2015/medium.js
function ItoI2(a) {
  return a;
}
function innerCreateMedium2(defaults, middleware) {
  if (middleware === undefined) {
    middleware = ItoI2;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium2(options2) {
  if (options2 === undefined) {
    options2 = {};
  }
  var medium = innerCreateMedium2(null);
  medium.options = __assign2({ async: true, ssr: false }, options2);
  return medium;
}
// ../../node_modules/use-sidecar/dist/es2015/exports.js
import * as React56 from "react";
var SideCar2 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest2(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React56.createElement(Target, __assign2({}, rest));
};
SideCar2.isSideCarExport = true;
function exportSidecar2(medium, exported) {
  medium.useMedium(exported);
  return SideCar2;
}
// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar2 = createSidecarMedium2();

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing2 = function() {
  return;
};
var RemoveScroll2 = React57.forwardRef(function(props, parentRef) {
  var ref = React57.useRef(null);
  var _a = React57.useState({
    onScrollCapture: nothing2,
    onWheelCapture: nothing2,
    onTouchMoveCapture: nothing2
  }), callbacks = _a[0], setCallbacks = _a[1];
  var { forwardProps, children, className, removeScrollBar, enabled, shards, sideCar, noRelative, noIsolation, inert, allowPinchZoom, as: _b } = props, Container = _b === undefined ? "div" : _b, gapMode = props.gapMode, rest = __rest2(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar3 = sideCar;
  var containerRef = useMergeRefs2([ref, parentRef]);
  var containerProps = __assign2(__assign2({}, rest), callbacks);
  return React57.createElement(React57.Fragment, null, enabled && React57.createElement(SideCar3, { sideCar: effectCar2, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }), forwardProps ? React57.cloneElement(React57.Children.only(children), __assign2(__assign2({}, containerProps), { ref: containerRef })) : React57.createElement(Container, __assign2({}, containerProps, { className, ref: containerRef }), children));
});
RemoveScroll2.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll2.classNames = {
  fullWidth: fullWidthClassName2,
  zeroRight: zeroRightClassName2
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
import * as React60 from "react";

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
import * as React59 from "react";

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
import * as React58 from "react";

// ../../node_modules/get-nonce/dist/es2015/index.js
var currentNonce2;
var getNonce2 = function() {
  if (currentNonce2) {
    return currentNonce2;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return;
};

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag2() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce2();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles2(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag2(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton2 = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag2()) {
          injectStyles2(stylesheet, style);
          insertStyleTag2(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton2 = function() {
  var sheet = stylesheetSingleton2();
  return function(styles, isDynamic) {
    React58.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton2 = function() {
  var useStyle = styleHookSingleton2();
  var Sheet = function(_a) {
    var { styles, dynamic } = _a;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
// ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap2 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset2 = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left), parse2(top), parse2(right)];
};
var getGapWidth2 = function(gapMode) {
  if (gapMode === undefined) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap2;
  }
  var offsets = getOffset2(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style2 = styleSingleton2();
var lockAttribute2 = "data-scroll-locked";
var getStyles2 = function(_a, allowRelative, gapMode, important) {
  var { left, top, right, gap } = _a;
  if (gapMode === undefined) {
    gapMode = "margin";
  }
  return `
  .`.concat(noScrollbarsClassName2, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute2, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && `
    padding-left: `.concat(left, `px;
    padding-top: `).concat(top, `px;
    padding-right: `).concat(right, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName2, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName2, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName2, " .").concat(zeroRightClassName2, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName2, " .").concat(fullWidthClassName2, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute2, `] {
    `).concat(removedBarSizeVariable2, ": ").concat(gap, `px;
  }
`);
};
var getCurrentUseCounter2 = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute2) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute2 = function() {
  React59.useEffect(function() {
    document.body.setAttribute(lockAttribute2, (getCurrentUseCounter2() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter2() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute2);
      } else {
        document.body.setAttribute(lockAttribute2, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar2 = function(_a) {
  var { noRelative, noImportant, gapMode: _b } = _a, gapMode = _b === undefined ? "margin" : _b;
  useLockAttribute2();
  var gap = React59.useMemo(function() {
    return getGapWidth2(gapMode);
  }, [gapMode]);
  return React59.createElement(Style2, { styles: getStyles2(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported2 = false;
if (typeof window !== "undefined") {
  try {
    options2 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported2 = true;
        return true;
      }
    });
    window.addEventListener("test", options2, options2);
    window.removeEventListener("test", options2, options2);
  } catch (err) {
    passiveSupported2 = false;
  }
}
var options2;
var nonPassive2 = passiveSupported2 ? { passive: false } : false;

// ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll2 = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled2 = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll2(node) && styles[overflow] === "visible");
};
var elementCouldBeVScrolled2 = function(node) {
  return elementCanBeScrolled2(node, "overflowY");
};
var elementCouldBeHScrolled2 = function(node) {
  return elementCanBeScrolled2(node, "overflowX");
};
var locationCouldBeScrolled2 = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled2(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables2(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables2 = function(_a) {
  var { scrollTop, scrollHeight, clientHeight } = _a;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables2 = function(_a) {
  var { scrollLeft, scrollWidth, clientWidth } = _a;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled2 = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled2(node) : elementCouldBeHScrolled2(node);
};
var getScrollVariables2 = function(axis, node) {
  return axis === "v" ? getVScrollVariables2(node) : getHScrollVariables2(node);
};
var getDirectionFactor2 = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll2 = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor2(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a = getScrollVariables2(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled2(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY2 = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY2 = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef2 = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare2 = function(x2, y) {
  return x2[0] === y[0] && x2[1] === y[1];
};
var generateStyle2 = function(id) {
  return `
  .block-interactivity-`.concat(id, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id, ` {pointer-events: all;}
`);
};
var idCounter2 = 0;
var lockStack2 = [];
function RemoveScrollSideCar2(props) {
  var shouldPreventQueue = React60.useRef([]);
  var touchStartRef = React60.useRef([0, 0]);
  var activeAxis = React60.useRef();
  var id = React60.useState(idCounter2++)[0];
  var Style3 = React60.useState(styleSingleton2)[0];
  var lastProps = React60.useRef(props);
  React60.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React60.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray2([props.lockRef.current], (props.shards || []).map(extractRef2), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React60.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY2(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled2(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled2(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll2(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React60.useCallback(function(_event) {
    var event = _event;
    if (!lockStack2.length || lockStack2[lockStack2.length - 1] !== Style3) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY2(event) : getTouchXY2(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare2(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef2).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React60.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent2(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React60.useCallback(function(event) {
    touchStartRef.current = getTouchXY2(event);
    activeAxis.current = undefined;
  }, []);
  var scrollWheel = React60.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY2(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React60.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY2(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React60.useEffect(function() {
    lockStack2.push(Style3);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive2);
    document.addEventListener("touchmove", shouldPrevent, nonPassive2);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive2);
    return function() {
      lockStack2 = lockStack2.filter(function(inst) {
        return inst !== Style3;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive2);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive2);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive2);
    };
  }, []);
  var { removeScrollBar, inert } = props;
  return React60.createElement(React60.Fragment, null, inert ? React60.createElement(Style3, { styles: generateStyle2(id) }) : null, removeScrollBar ? React60.createElement(RemoveScrollBar2, { noRelative: props.noRelative, gapMode: props.gapMode }) : null);
}
function getOutermostShadowParent2(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default2 = exportSidecar2(effectCar2, RemoveScrollSideCar2);

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll2 = React61.forwardRef(function(props, ref) {
  return React61.createElement(RemoveScroll2, __assign2({}, props, { ref, sideCar: sidecar_default2 }));
});
ReactRemoveScroll2.classNames = RemoveScroll2.classNames;
var Combination_default2 = ReactRemoveScroll2;

// ../../node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent2 = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap2 = new WeakMap;
var uncontrolledNodes2 = new WeakMap;
var markerMap2 = {};
var lockCount2 = 0;
var unwrapHost2 = function(node) {
  return node && (node.host || unwrapHost2(node.parentNode));
};
var correctTargets2 = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost2(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers2 = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets2(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap2[markerName]) {
    markerMap2[markerName] = new WeakMap;
  }
  var markerCounter = markerMap2[markerName];
  var hiddenNodes = [];
  var elementsToKeep = new Set;
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap2.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap2.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes2.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount2++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap2.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap2.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes2.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes2.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount2--;
    if (!lockCount2) {
      counterMap2 = new WeakMap;
      counterMap2 = new WeakMap;
      uncontrolledNodes2 = new WeakMap;
      markerMap2 = {};
    }
  };
};
var hideOthers2 = function(originalTarget, parentNode, markerName) {
  if (markerName === undefined) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent2(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers2(targets, activeParentNode, markerName, "aria-hidden");
};

// ../../node_modules/@radix-ui/react-dialog/dist/index.mjs
import { Fragment as Fragment14, jsx as jsx37, jsxs as jsxs6 } from "react/jsx-runtime";
"use client";
var DIALOG_NAME2 = "Dialog";
var [createDialogContext2, createDialogScope2] = createContextScope2(DIALOG_NAME2);
var [DialogProvider2, useDialogContext2] = createDialogContext2(DIALOG_NAME2);
var Dialog2 = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React62.useRef(null);
  const contentRef = React62.useRef(null);
  const [open, setOpen] = useControllableState2({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME2
  });
  return /* @__PURE__ */ jsx37(DialogProvider2, {
    scope: __scopeDialog,
    triggerRef,
    contentRef,
    contentId: useId2(),
    titleId: useId2(),
    descriptionId: useId2(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: React62.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
    modal,
    children
  });
};
Dialog2.displayName = DIALOG_NAME2;
var TRIGGER_NAME3 = "DialogTrigger";
var DialogTrigger2 = React62.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...triggerProps } = props;
  const context = useDialogContext2(TRIGGER_NAME3, __scopeDialog);
  const composedTriggerRef = useComposedRefs2(forwardedRef, context.triggerRef);
  return /* @__PURE__ */ jsx37(Primitive2.button, {
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": getState2(context.open),
    ...triggerProps,
    ref: composedTriggerRef,
    onClick: composeEventHandlers2(props.onClick, context.onOpenToggle)
  });
});
DialogTrigger2.displayName = TRIGGER_NAME3;
var PORTAL_NAME7 = "DialogPortal";
var [PortalProvider3, usePortalContext3] = createDialogContext2(PORTAL_NAME7, {
  forceMount: undefined
});
var DialogPortal2 = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext2(PORTAL_NAME7, __scopeDialog);
  return /* @__PURE__ */ jsx37(PortalProvider3, { scope: __scopeDialog, forceMount, children: React62.Children.map(children, (child) => /* @__PURE__ */ jsx37(Presence2, { present: forceMount || context.open, children: /* @__PURE__ */ jsx37(Portal3, { asChild: true, container, children: child }) })) });
};
DialogPortal2.displayName = PORTAL_NAME7;
var OVERLAY_NAME2 = "DialogOverlay";
var DialogOverlay2 = React62.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext3(OVERLAY_NAME2, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...overlayProps } = props;
  const context = useDialogContext2(OVERLAY_NAME2, props.__scopeDialog);
  return context.modal ? /* @__PURE__ */ jsx37(Presence2, { present: forceMount || context.open, children: /* @__PURE__ */ jsx37(DialogOverlayImpl2, { ...overlayProps, ref: forwardedRef }) }) : null;
});
DialogOverlay2.displayName = OVERLAY_NAME2;
var Slot = createSlot2("DialogOverlay.RemoveScroll");
var DialogOverlayImpl2 = React62.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...overlayProps } = props;
  const context = useDialogContext2(OVERLAY_NAME2, __scopeDialog);
  return /* @__PURE__ */ jsx37(Combination_default2, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsx37(Primitive2.div, {
    "data-state": getState2(context.open),
    ...overlayProps,
    ref: forwardedRef,
    style: { pointerEvents: "auto", ...overlayProps.style }
  }) });
});
var CONTENT_NAME5 = "DialogContent";
var DialogContent2 = React62.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext3(CONTENT_NAME5, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = useDialogContext2(CONTENT_NAME5, props.__scopeDialog);
  return /* @__PURE__ */ jsx37(Presence2, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsx37(DialogContentModal2, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx37(DialogContentNonModal2, { ...contentProps, ref: forwardedRef }) });
});
DialogContent2.displayName = CONTENT_NAME5;
var DialogContentModal2 = React62.forwardRef((props, forwardedRef) => {
  const context = useDialogContext2(CONTENT_NAME5, props.__scopeDialog);
  const contentRef = React62.useRef(null);
  const composedRefs = useComposedRefs2(forwardedRef, context.contentRef, contentRef);
  React62.useEffect(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers2(content);
  }, []);
  return /* @__PURE__ */ jsx37(DialogContentImpl2, {
    ...props,
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: composeEventHandlers2(props.onCloseAutoFocus, (event) => {
      event.preventDefault();
      context.triggerRef.current?.focus();
    }),
    onPointerDownOutside: composeEventHandlers2(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (isRightClick)
        event.preventDefault();
    }),
    onFocusOutside: composeEventHandlers2(props.onFocusOutside, (event) => event.preventDefault())
  });
});
var DialogContentNonModal2 = React62.forwardRef((props, forwardedRef) => {
  const context = useDialogContext2(CONTENT_NAME5, props.__scopeDialog);
  const hasInteractedOutsideRef = React62.useRef(false);
  const hasPointerDownOutsideRef = React62.useRef(false);
  return /* @__PURE__ */ jsx37(DialogContentImpl2, {
    ...props,
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      props.onCloseAutoFocus?.(event);
      if (!event.defaultPrevented) {
        if (!hasInteractedOutsideRef.current)
          context.triggerRef.current?.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      props.onInteractOutside?.(event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown") {
          hasPointerDownOutsideRef.current = true;
        }
      }
      const target = event.target;
      const targetIsTrigger = context.triggerRef.current?.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
        event.preventDefault();
      }
    }
  });
});
var DialogContentImpl2 = React62.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
  const context = useDialogContext2(CONTENT_NAME5, __scopeDialog);
  const contentRef = React62.useRef(null);
  const composedRefs = useComposedRefs2(forwardedRef, contentRef);
  useFocusGuards2();
  return /* @__PURE__ */ jsxs6(Fragment14, { children: [
    /* @__PURE__ */ jsx37(FocusScope2, {
      asChild: true,
      loop: true,
      trapped: trapFocus,
      onMountAutoFocus: onOpenAutoFocus,
      onUnmountAutoFocus: onCloseAutoFocus,
      children: /* @__PURE__ */ jsx37(DismissableLayer2, {
        role: "dialog",
        id: context.contentId,
        "aria-describedby": context.descriptionId,
        "aria-labelledby": context.titleId,
        "data-state": getState2(context.open),
        ...contentProps,
        ref: composedRefs,
        onDismiss: () => context.onOpenChange(false)
      })
    }),
    /* @__PURE__ */ jsxs6(Fragment14, { children: [
      /* @__PURE__ */ jsx37(TitleWarning2, { titleId: context.titleId }),
      /* @__PURE__ */ jsx37(DescriptionWarning2, { contentRef, descriptionId: context.descriptionId })
    ] })
  ] });
});
var TITLE_NAME2 = "DialogTitle";
var DialogTitle2 = React62.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...titleProps } = props;
  const context = useDialogContext2(TITLE_NAME2, __scopeDialog);
  return /* @__PURE__ */ jsx37(Primitive2.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
});
DialogTitle2.displayName = TITLE_NAME2;
var DESCRIPTION_NAME2 = "DialogDescription";
var DialogDescription2 = React62.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...descriptionProps } = props;
  const context = useDialogContext2(DESCRIPTION_NAME2, __scopeDialog);
  return /* @__PURE__ */ jsx37(Primitive2.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
});
DialogDescription2.displayName = DESCRIPTION_NAME2;
var CLOSE_NAME2 = "DialogClose";
var DialogClose2 = React62.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...closeProps } = props;
  const context = useDialogContext2(CLOSE_NAME2, __scopeDialog);
  return /* @__PURE__ */ jsx37(Primitive2.button, {
    type: "button",
    ...closeProps,
    ref: forwardedRef,
    onClick: composeEventHandlers2(props.onClick, () => context.onOpenChange(false))
  });
});
DialogClose2.displayName = CLOSE_NAME2;
function getState2(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME2 = "DialogTitleWarning";
var [WarningProvider2, useWarningContext2] = createContext23(TITLE_WARNING_NAME2, {
  contentName: CONTENT_NAME5,
  titleName: TITLE_NAME2,
  docsSlug: "dialog"
});
var TitleWarning2 = ({ titleId }) => {
  const titleWarningContext = useWarningContext2(TITLE_WARNING_NAME2);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React62.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME2 = "DialogDescriptionWarning";
var DescriptionWarning2 = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext2(DESCRIPTION_WARNING_NAME2);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React62.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root6 = Dialog2;
var Portal5 = DialogPortal2;
var Overlay = DialogOverlay2;
var Content3 = DialogContent2;

// ../../node_modules/@radix-ui/react-use-is-hydrated/dist/index.mjs
var import_shim = __toESM(require_shim(), 1);
function useIsHydrated() {
  return import_shim.useSyncExternalStore(subscribe, () => true, () => false);
}
function subscribe() {
  return () => {};
}

// ../../node_modules/@radix-ui/react-roving-focus/dist/index.mjs
import * as React64 from "react";
import { jsx as jsx38 } from "react/jsx-runtime";
"use client";
var ENTRY_FOCUS2 = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS5 = { bubbles: false, cancelable: true };
var GROUP_NAME4 = "RovingFocusGroup";
var [Collection4, useCollection4, createCollectionScope4] = createCollection2(GROUP_NAME4);
var [createRovingFocusGroupContext2, createRovingFocusGroupScope2] = createContextScope2(GROUP_NAME4, [createCollectionScope4]);
var [RovingFocusProvider2, useRovingFocusContext2] = createRovingFocusGroupContext2(GROUP_NAME4);
var RovingFocusGroup2 = React64.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsx38(Collection4.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx38(Collection4.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx38(RovingFocusGroupImpl2, { ...props, ref: forwardedRef }) }) });
});
RovingFocusGroup2.displayName = GROUP_NAME4;
var RovingFocusGroupImpl2 = React64.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React64.useRef(null);
  const composedRefs = useComposedRefs2(forwardedRef, ref);
  const direction = useDirection2(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState2({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME4
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React64.useState(false);
  const handleEntryFocus = useCallbackRef3(onEntryFocus);
  const getItems = useCollection4(__scopeRovingFocusGroup);
  const isClickFocusRef = React64.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React64.useState(0);
  React64.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS2, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS2, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsx38(RovingFocusProvider2, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction,
    loop,
    currentTabStopId,
    onItemFocus: React64.useCallback((tabStopId) => setCurrentTabStopId(tabStopId), [setCurrentTabStopId]),
    onItemShiftTab: React64.useCallback(() => setIsTabbingBackOut(true), []),
    onFocusableItemAdd: React64.useCallback(() => setFocusableItemsCount((prevCount) => prevCount + 1), []),
    onFocusableItemRemove: React64.useCallback(() => setFocusableItemsCount((prevCount) => prevCount - 1), []),
    children: /* @__PURE__ */ jsx38(Primitive2.div, {
      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
      "data-orientation": orientation,
      ...groupProps,
      ref: composedRefs,
      style: { outline: "none", ...props.style },
      onMouseDown: composeEventHandlers2(props.onMouseDown, () => {
        isClickFocusRef.current = true;
      }),
      onFocus: composeEventHandlers2(props.onFocus, (event) => {
        const isKeyboardFocus = !isClickFocusRef.current;
        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
          const entryFocusEvent = new CustomEvent(ENTRY_FOCUS2, EVENT_OPTIONS5);
          event.currentTarget.dispatchEvent(entryFocusEvent);
          if (!entryFocusEvent.defaultPrevented) {
            const items = getItems().filter((item) => item.focusable);
            const activeItem = items.find((item) => item.active);
            const currentItem = items.find((item) => item.id === currentTabStopId);
            const candidateItems = [activeItem, currentItem, ...items].filter(Boolean);
            const candidateNodes = candidateItems.map((item) => item.ref.current);
            focusFirst6(candidateNodes, preventScrollOnEntryFocus);
          }
        }
        isClickFocusRef.current = false;
      }),
      onBlur: composeEventHandlers2(props.onBlur, () => setIsTabbingBackOut(false))
    })
  });
});
var ITEM_NAME4 = "RovingFocusGroupItem";
var RovingFocusGroupItem2 = React64.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    focusable = true,
    active = false,
    tabStopId,
    children,
    ...itemProps
  } = props;
  const autoId = useId2();
  const id = tabStopId || autoId;
  const context = useRovingFocusContext2(ITEM_NAME4, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = useCollection4(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
  React64.useEffect(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
  return /* @__PURE__ */ jsx38(Collection4.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id,
    focusable,
    active,
    children: /* @__PURE__ */ jsx38(Primitive2.span, {
      tabIndex: isCurrentTabStop ? 0 : -1,
      "data-orientation": context.orientation,
      ...itemProps,
      ref: forwardedRef,
      onMouseDown: composeEventHandlers2(props.onMouseDown, (event) => {
        if (!focusable)
          event.preventDefault();
        else
          context.onItemFocus(id);
      }),
      onFocus: composeEventHandlers2(props.onFocus, () => context.onItemFocus(id)),
      onKeyDown: composeEventHandlers2(props.onKeyDown, (event) => {
        if (event.key === "Tab" && event.shiftKey) {
          context.onItemShiftTab();
          return;
        }
        if (event.target !== event.currentTarget)
          return;
        const focusIntent = getFocusIntent2(event, context.orientation, context.dir);
        if (focusIntent !== undefined) {
          if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)
            return;
          event.preventDefault();
          const items = getItems().filter((item) => item.focusable);
          let candidateNodes = items.map((item) => item.ref.current);
          if (focusIntent === "last")
            candidateNodes.reverse();
          else if (focusIntent === "prev" || focusIntent === "next") {
            if (focusIntent === "prev")
              candidateNodes.reverse();
            const currentIndex = candidateNodes.indexOf(event.currentTarget);
            candidateNodes = context.loop ? wrapArray4(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
          }
          setTimeout(() => focusFirst6(candidateNodes));
        }
      }),
      children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
    })
  });
});
RovingFocusGroupItem2.displayName = ITEM_NAME4;
var MAP_KEY_TO_FOCUS_INTENT2 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey2(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent2(event, orientation, dir) {
  const key = getDirectionAwareKey2(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return;
  return MAP_KEY_TO_FOCUS_INTENT2[key];
}
function focusFirst6(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray4(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root7 = RovingFocusGroup2;
var Item3 = RovingFocusGroupItem2;

// ../../node_modules/@radix-ui/react-one-time-password-field/dist/index.mjs
var exports_dist = {};
__export(exports_dist, {
  Root: () => OneTimePasswordField,
  OneTimePasswordFieldInput: () => OneTimePasswordFieldInput,
  OneTimePasswordFieldHiddenInput: () => OneTimePasswordFieldHiddenInput,
  OneTimePasswordField: () => OneTimePasswordField,
  Input: () => OneTimePasswordFieldInput,
  HiddenInput: () => OneTimePasswordFieldHiddenInput
});
import * as React65 from "react";
import { flushSync as flushSync2 } from "react-dom";

// ../../node_modules/@radix-ui/number/dist/index.mjs
function clamp2(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}

// ../../node_modules/@radix-ui/react-one-time-password-field/dist/index.mjs
import { jsx as jsx39 } from "react/jsx-runtime";
"use client";
var INPUT_VALIDATION_MAP = {
  numeric: {
    type: "numeric",
    regexp: /[^\d]/g,
    pattern: "\\d{1}",
    inputMode: "numeric"
  },
  alpha: {
    type: "alpha",
    regexp: /[^a-zA-Z]/g,
    pattern: "[a-zA-Z]{1}",
    inputMode: "text"
  },
  alphanumeric: {
    type: "alphanumeric",
    regexp: /[^a-zA-Z0-9]/g,
    pattern: "[a-zA-Z0-9]{1}",
    inputMode: "text"
  },
  none: null
};
var ONE_TIME_PASSWORD_FIELD_NAME = "OneTimePasswordField";
var [Collection6, { useCollection: useCollection6, createCollectionScope: createCollectionScope6, useInitCollection }] = createCollection22(ONE_TIME_PASSWORD_FIELD_NAME);
var [createOneTimePasswordFieldContext] = createContextScope2(ONE_TIME_PASSWORD_FIELD_NAME, [
  createCollectionScope6,
  createRovingFocusGroupScope2
]);
var useRovingFocusGroupScope3 = createRovingFocusGroupScope2();
var [OneTimePasswordFieldContext, useOneTimePasswordFieldContext] = createOneTimePasswordFieldContext(ONE_TIME_PASSWORD_FIELD_NAME);
var OneTimePasswordField = React65.forwardRef(function OneTimePasswordFieldImpl({
  __scopeOneTimePasswordField,
  defaultValue,
  value: valueProp,
  onValueChange,
  autoSubmit = false,
  children,
  onPaste,
  onAutoSubmit,
  disabled = false,
  readOnly = false,
  autoComplete = "one-time-code",
  autoFocus = false,
  form,
  name,
  placeholder,
  type = "text",
  orientation = "horizontal",
  dir,
  validationType = "numeric",
  sanitizeValue: sanitizeValueProp,
  ...domProps
}, forwardedRef) {
  const rovingFocusGroupScope = useRovingFocusGroupScope3(__scopeOneTimePasswordField);
  const direction = useDirection2(dir);
  const collectionState = useInitCollection();
  const [collection] = collectionState;
  const validation = INPUT_VALIDATION_MAP[validationType] ? INPUT_VALIDATION_MAP[validationType] : null;
  const sanitizeValue = React65.useCallback((value2) => {
    if (Array.isArray(value2)) {
      value2 = value2.map(removeWhitespace).join("");
    } else {
      value2 = removeWhitespace(value2);
    }
    if (validation) {
      const regexp = new RegExp(validation.regexp);
      value2 = value2.replace(regexp, "");
    } else if (sanitizeValueProp) {
      value2 = sanitizeValueProp(value2);
    }
    return value2.split("");
  }, [validation, sanitizeValueProp]);
  const controlledValue = React65.useMemo(() => {
    return valueProp != null ? sanitizeValue(valueProp) : undefined;
  }, [valueProp, sanitizeValue]);
  const [value, setValue] = useControllableState2({
    caller: "OneTimePasswordField",
    prop: controlledValue,
    defaultProp: defaultValue != null ? sanitizeValue(defaultValue) : [],
    onChange: React65.useCallback((value2) => onValueChange?.(value2.join("")), [onValueChange])
  });
  const dispatch = useEffectEvent((action) => {
    switch (action.type) {
      case "SET_CHAR": {
        const { index: index2, char } = action;
        const currentTarget = collection.at(index2)?.element;
        if (value[index2] === char) {
          const next = currentTarget && collection.from(currentTarget, 1)?.element;
          focusInput(next);
          return;
        }
        if (char === "") {
          return;
        }
        if (validation) {
          const regexp = new RegExp(validation.regexp);
          const clean = char.replace(regexp, "");
          if (clean !== char) {
            return;
          }
        }
        if (value.length >= collection.size) {
          const newValue2 = [...value];
          newValue2[index2] = char;
          flushSync2(() => setValue(newValue2));
          const next = currentTarget && collection.from(currentTarget, 1)?.element;
          focusInput(next);
          return;
        }
        const newValue = [...value];
        newValue[index2] = char;
        const lastElement = collection.at(-1)?.element;
        flushSync2(() => setValue(newValue));
        if (currentTarget !== lastElement) {
          const next = currentTarget && collection.from(currentTarget, 1)?.element;
          focusInput(next);
        } else {
          currentTarget?.select();
        }
        return;
      }
      case "CLEAR_CHAR": {
        const { index: index2, reason } = action;
        if (!value[index2]) {
          return;
        }
        const newValue = value.filter((_2, i) => i !== index2);
        const currentTarget = collection.at(index2)?.element;
        const previous = currentTarget && collection.from(currentTarget, -1)?.element;
        flushSync2(() => setValue(newValue));
        if (reason === "Backspace") {
          focusInput(previous);
        } else if (reason === "Delete" || reason === "Cut") {
          focusInput(currentTarget);
        }
        return;
      }
      case "CLEAR": {
        if (value.length === 0) {
          return;
        }
        if (action.reason === "Backspace" || action.reason === "Delete") {
          flushSync2(() => setValue([]));
          focusInput(collection.at(0)?.element);
        } else {
          setValue([]);
        }
        return;
      }
      case "PASTE": {
        const { value: pastedValue } = action;
        const value2 = sanitizeValue(pastedValue);
        if (!value2) {
          return;
        }
        flushSync2(() => setValue(value2));
        focusInput(collection.at(value2.length - 1)?.element);
        return;
      }
    }
  });
  const validationTypeRef = React65.useRef(validation);
  React65.useEffect(() => {
    if (!validation) {
      return;
    }
    if (validationTypeRef.current?.type !== validation.type) {
      validationTypeRef.current = validation;
      setValue(sanitizeValue(value.join("")));
    }
  }, [sanitizeValue, setValue, validation, value]);
  const hiddenInputRef = React65.useRef(null);
  const userActionRef = React65.useRef(null);
  const rootRef = React65.useRef(null);
  const composedRefs = useComposedRefs2(forwardedRef, rootRef);
  const firstInput = collection.at(0)?.element;
  const locateForm = React65.useCallback(() => {
    let formElement;
    if (form) {
      const associatedElement = (rootRef.current?.ownerDocument ?? document).getElementById(form);
      if (isFormElement(associatedElement)) {
        formElement = associatedElement;
      }
    } else if (hiddenInputRef.current) {
      formElement = hiddenInputRef.current.form;
    } else if (firstInput) {
      formElement = firstInput.form;
    }
    return formElement ?? null;
  }, [form, firstInput]);
  const attemptSubmit = React65.useCallback(() => {
    const formElement = locateForm();
    formElement?.requestSubmit();
  }, [locateForm]);
  React65.useEffect(() => {
    const form2 = locateForm();
    if (form2) {
      const reset = () => dispatch({ type: "CLEAR", reason: "Reset" });
      form2.addEventListener("reset", reset);
      return () => form2.removeEventListener("reset", reset);
    }
  }, [dispatch, locateForm]);
  const currentValue = value.join("");
  const valueRef = React65.useRef(currentValue);
  const length = collection.size;
  React65.useEffect(() => {
    const previousValue = valueRef.current;
    valueRef.current = currentValue;
    if (previousValue === currentValue) {
      return;
    }
    if (autoSubmit && value.every((char) => char !== "") && value.length === length) {
      onAutoSubmit?.(value.join(""));
      attemptSubmit();
    }
  }, [attemptSubmit, autoSubmit, currentValue, length, onAutoSubmit, value]);
  const isHydrated = useIsHydrated();
  return /* @__PURE__ */ jsx39(OneTimePasswordFieldContext, {
    scope: __scopeOneTimePasswordField,
    value,
    attemptSubmit,
    disabled,
    readOnly,
    autoComplete,
    autoFocus,
    form,
    name,
    placeholder,
    type,
    hiddenInputRef,
    userActionRef,
    dispatch,
    validationType,
    orientation,
    isHydrated,
    sanitizeValue,
    children: /* @__PURE__ */ jsx39(Collection6.Provider, { scope: __scopeOneTimePasswordField, state: collectionState, children: /* @__PURE__ */ jsx39(Collection6.Slot, { scope: __scopeOneTimePasswordField, children: /* @__PURE__ */ jsx39(Root7, {
      asChild: true,
      ...rovingFocusGroupScope,
      orientation,
      dir: direction,
      children: /* @__PURE__ */ jsx39(Root4.div, {
        ...domProps,
        role: "group",
        ref: composedRefs,
        onPaste: composeEventHandlers2(onPaste, (event) => {
          event.preventDefault();
          const pastedValue = event.clipboardData.getData("Text");
          dispatch({ type: "PASTE", value: pastedValue });
        }),
        children
      })
    }) }) })
  });
});
var OneTimePasswordFieldHiddenInput = React65.forwardRef(function OneTimePasswordFieldHiddenInput2({ __scopeOneTimePasswordField, ...props }, forwardedRef) {
  const { value, hiddenInputRef, name } = useOneTimePasswordFieldContext("OneTimePasswordFieldHiddenInput", __scopeOneTimePasswordField);
  const ref = useComposedRefs2(hiddenInputRef, forwardedRef);
  return /* @__PURE__ */ jsx39("input", {
    ref,
    name,
    value: value.join("").trim(),
    autoComplete: "off",
    autoFocus: false,
    autoCapitalize: "off",
    autoCorrect: "off",
    autoSave: "off",
    spellCheck: false,
    ...props,
    type: "hidden",
    readOnly: true
  });
});
var OneTimePasswordFieldInput = React65.forwardRef(function OneTimePasswordFieldInput2({
  __scopeOneTimePasswordField,
  onInvalidChange,
  index: indexProp,
  ...props
}, forwardedRef) {
  const {
    value: _value,
    defaultValue: _defaultValue,
    disabled: _disabled,
    readOnly: _readOnly,
    autoComplete: _autoComplete,
    autoFocus: _autoFocus,
    form: _form,
    name: _name,
    placeholder: _placeholder,
    type: _type,
    ...domProps
  } = props;
  const context = useOneTimePasswordFieldContext("OneTimePasswordFieldInput", __scopeOneTimePasswordField);
  const { dispatch, userActionRef, validationType, isHydrated, disabled } = context;
  const collection = useCollection6(__scopeOneTimePasswordField);
  const rovingFocusGroupScope = useRovingFocusGroupScope3(__scopeOneTimePasswordField);
  const inputRef = React65.useRef(null);
  const [element, setElement] = React65.useState(null);
  const index2 = indexProp ?? (element ? collection.indexOf(element) : -1);
  const canSetPlaceholder = indexProp != null || isHydrated;
  let placeholder;
  if (canSetPlaceholder && context.placeholder && context.value.length === 0) {
    placeholder = context.placeholder[index2];
  }
  const composedInputRef = useComposedRefs2(forwardedRef, inputRef, setElement);
  const char = context.value[index2] ?? "";
  const keyboardActionTimeoutRef = React65.useRef(null);
  React65.useEffect(() => {
    return () => {
      window.clearTimeout(keyboardActionTimeoutRef.current);
    };
  }, []);
  const totalValue = context.value.join("").trim();
  const lastSelectableIndex = clamp2(totalValue.length, [0, collection.size - 1]);
  const isFocusable = index2 <= lastSelectableIndex;
  const validation = validationType in INPUT_VALIDATION_MAP ? INPUT_VALIDATION_MAP[validationType] : undefined;
  return /* @__PURE__ */ jsx39(Collection6.ItemSlot, { scope: __scopeOneTimePasswordField, children: /* @__PURE__ */ jsx39(Item3, {
    ...rovingFocusGroupScope,
    asChild: true,
    focusable: !context.disabled && isFocusable,
    active: index2 === lastSelectableIndex,
    children: ({ hasTabStop, isCurrentTabStop }) => {
      const supportsAutoComplete = hasTabStop ? isCurrentTabStop : index2 === 0;
      return /* @__PURE__ */ jsx39(Root4.input, {
        ref: composedInputRef,
        type: context.type,
        disabled,
        "aria-label": `Character ${index2 + 1} of ${collection.size}`,
        autoComplete: supportsAutoComplete ? context.autoComplete : "off",
        "data-1p-ignore": supportsAutoComplete ? undefined : "true",
        "data-lpignore": supportsAutoComplete ? undefined : "true",
        "data-protonpass-ignore": supportsAutoComplete ? undefined : "true",
        "data-bwignore": supportsAutoComplete ? undefined : "true",
        inputMode: validation?.inputMode,
        maxLength: 1,
        pattern: validation?.pattern,
        readOnly: context.readOnly,
        value: char,
        placeholder,
        "data-radix-otp-input": "",
        "data-radix-index": index2,
        ...domProps,
        onFocus: composeEventHandlers2(props.onFocus, (event) => {
          event.currentTarget.select();
        }),
        onCut: composeEventHandlers2(props.onCut, (event) => {
          const currentValue = event.currentTarget.value;
          if (currentValue !== "") {
            userActionRef.current = {
              type: "cut"
            };
            keyboardActionTimeoutRef.current = window.setTimeout(() => {
              userActionRef.current = null;
            }, 10);
          }
        }),
        onInput: composeEventHandlers2(props.onInput, (event) => {
          const value = event.currentTarget.value;
          if (value.length > 1) {
            event.preventDefault();
            dispatch({ type: "PASTE", value });
          }
        }),
        onChange: composeEventHandlers2(props.onChange, (event) => {
          const value = event.target.value;
          event.preventDefault();
          const action = userActionRef.current;
          userActionRef.current = null;
          if (action) {
            switch (action.type) {
              case "cut":
                dispatch({ type: "CLEAR_CHAR", index: index2, reason: "Cut" });
                return;
              case "keydown": {
                if (action.key === "Char") {
                  return;
                }
                const isClearing = action.key === "Backspace" && (action.metaKey || action.ctrlKey);
                if (action.key === "Clear" || isClearing) {
                  dispatch({ type: "CLEAR", reason: "Backspace" });
                } else {
                  dispatch({ type: "CLEAR_CHAR", index: index2, reason: action.key });
                }
                return;
              }
              default:
                return;
            }
          }
          if (event.target.validity.valid) {
            if (value === "") {
              let reason = "Backspace";
              if (isInputEvent(event.nativeEvent)) {
                const inputType = event.nativeEvent.inputType;
                if (inputType === "deleteContentBackward") {
                  reason = "Backspace";
                } else if (inputType === "deleteByCut") {
                  reason = "Cut";
                }
              }
              dispatch({ type: "CLEAR_CHAR", index: index2, reason });
            } else {
              dispatch({ type: "SET_CHAR", char: value, index: index2, event });
            }
          } else {
            const element2 = event.target;
            onInvalidChange?.(element2.value);
            requestAnimationFrame(() => {
              if (element2.ownerDocument.activeElement === element2) {
                element2.select();
              }
            });
          }
        }),
        onKeyDown: composeEventHandlers2(props.onKeyDown, (event) => {
          switch (event.key) {
            case "Clear":
            case "Delete":
            case "Backspace": {
              const currentValue = event.currentTarget.value;
              if (currentValue === "") {
                if (event.key === "Delete")
                  return;
                const isClearing = event.key === "Clear" || event.metaKey || event.ctrlKey;
                if (isClearing) {
                  dispatch({ type: "CLEAR", reason: "Backspace" });
                } else {
                  const element2 = event.currentTarget;
                  requestAnimationFrame(() => {
                    focusInput(collection.from(element2, -1)?.element);
                  });
                }
              } else {
                userActionRef.current = {
                  type: "keydown",
                  key: event.key,
                  metaKey: event.metaKey,
                  ctrlKey: event.ctrlKey
                };
                keyboardActionTimeoutRef.current = window.setTimeout(() => {
                  userActionRef.current = null;
                }, 10);
              }
              return;
            }
            case "Enter": {
              event.preventDefault();
              context.attemptSubmit();
              return;
            }
            case "ArrowDown":
            case "ArrowUp": {
              if (context.orientation === "horizontal") {
                event.preventDefault();
              }
              return;
            }
            default: {
              if (event.currentTarget.value === event.key) {
                const element2 = event.currentTarget;
                event.preventDefault();
                focusInput(collection.from(element2, 1)?.element);
                return;
              } else if (event.currentTarget.value && !(event.currentTarget.selectionStart === 0 && event.currentTarget.selectionEnd != null && event.currentTarget.selectionEnd > 0)) {
                const attemptedValue = event.key;
                if (event.key.length > 1 || event.key === " ") {
                  return;
                } else {
                  const nextInput = collection.from(event.currentTarget, 1)?.element;
                  const lastInput = collection.at(-1)?.element;
                  if (nextInput !== lastInput && event.currentTarget !== lastInput) {
                    if (event.currentTarget.selectionStart === 0) {
                      dispatch({ type: "SET_CHAR", char: attemptedValue, index: index2, event });
                    } else {
                      dispatch({
                        type: "SET_CHAR",
                        char: attemptedValue,
                        index: index2 + 1,
                        event
                      });
                    }
                    userActionRef.current = {
                      type: "keydown",
                      key: "Char",
                      metaKey: event.metaKey,
                      ctrlKey: event.ctrlKey
                    };
                    keyboardActionTimeoutRef.current = window.setTimeout(() => {
                      userActionRef.current = null;
                    }, 10);
                  }
                }
              }
            }
          }
        }),
        onPointerDown: composeEventHandlers2(props.onPointerDown, (event) => {
          event.preventDefault();
          const indexToFocus = Math.min(index2, lastSelectableIndex);
          const element2 = collection.at(indexToFocus)?.element;
          focusInput(element2);
        })
      });
    }
  }) });
});
function isFormElement(element) {
  return element?.tagName === "FORM";
}
function removeWhitespace(value) {
  return value.replace(/\s/g, "");
}
function focusInput(element) {
  if (!element)
    return;
  if (element.ownerDocument.activeElement === element) {
    window.requestAnimationFrame(() => {
      element.select?.();
    });
  } else {
    element.focus();
  }
}
function isInputEvent(event) {
  return event.type === "input";
}

// ../componentry/dist/vibrant/index.js
import { jsx as jsx172 } from "react/jsx-runtime";
import React342 from "react";
import { Link as RouterLink2 } from "react-router";
import { jsx as jsx182 } from "react/jsx-runtime";
import { useId as useId22 } from "react";
import { createContext as createContext62, useContext as useContext42 } from "react";
import { jsx as jsx192 } from "react/jsx-runtime";
import { jsx as jsx202 } from "react/jsx-runtime";
import clsx53 from "clsx";
import { useEffect as useEffect142, useState as useState132 } from "react";
import { jsx as jsx212 } from "react/jsx-runtime";
import * as React362 from "react";
import * as React252 from "react";
import * as React352 from "react";
import { jsx as jsx233, jsxs as jsxs52 } from "react/jsx-runtime";
import clsx62 from "clsx";
import { jsx as jsx252, jsxs as jsxs62 } from "react/jsx-runtime";
import React382 from "react";
import * as React372 from "react";
import { jsx as jsx262 } from "react/jsx-runtime";
import { jsx as jsx272 } from "react/jsx-runtime";
import clsx72 from "clsx";
import { jsx as jsx282, jsxs as jsxs7 } from "react/jsx-runtime";
import { jsx as jsx292, jsxs as jsxs82 } from "react/jsx-runtime";
import clsx8 from "clsx";
import { jsx as jsx302 } from "react/jsx-runtime";
import { jsx as jsx312, jsxs as jsxs9 } from "react/jsx-runtime";
import { jsx as jsx322, jsxs as jsxs10 } from "react/jsx-runtime";
import * as React402 from "react";
import * as React392 from "react";
import { Fragment as Fragment82, jsx as jsx332, jsxs as jsxs11 } from "react/jsx-runtime";
import { jsx as jsx342, jsxs as jsxs12 } from "react/jsx-runtime";
import clsx92 from "clsx";
import { jsx as jsx352, jsxs as jsxs13 } from "react/jsx-runtime";
import { jsx as jsx362, jsxs as jsxs14 } from "react/jsx-runtime";
import clsx11 from "clsx";
import React412 from "react";
import { Await as Await3 } from "react-router";
import clsx10 from "clsx";
import { jsx as jsx372 } from "react/jsx-runtime";
import { jsx as jsx382 } from "react/jsx-runtime";
import * as React422 from "react";
import { jsx as jsx392 } from "react/jsx-runtime";
import { jsx as jsx402 } from "react/jsx-runtime";
import { jsx as jsx41 } from "react/jsx-runtime";
import * as React442 from "react";
import { jsx as jsx422 } from "react/jsx-runtime";
import clsx12 from "clsx";
import { jsx as jsx432 } from "react/jsx-runtime";
import { jsx as jsx442, jsxs as jsxs15 } from "react/jsx-runtime";
import clsx13 from "clsx";
import { jsx as jsx45 } from "react/jsx-runtime";
import { jsx as jsx46, jsxs as jsxs16 } from "react/jsx-runtime";
import { jsx as jsx47 } from "react/jsx-runtime";
import { jsx as jsx48 } from "react/jsx-runtime";
import { jsx as jsx49 } from "react/jsx-runtime";
import clsx14 from "clsx";
import { jsx as jsx50, jsxs as jsxs17 } from "react/jsx-runtime";
import * as React472 from "react";
import * as React462 from "react";
import * as React452 from "react";
import { jsx as jsx51 } from "react/jsx-runtime";
import { jsx as jsx522 } from "react/jsx-runtime";
import { jsx as jsx532 } from "react/jsx-runtime";
import clsx15 from "clsx";
import { jsx as jsx54, jsxs as jsxs18 } from "react/jsx-runtime";
import { jsx as jsx55, jsxs as jsxs19 } from "react/jsx-runtime";
import { jsx as jsx56, jsxs as jsxs20 } from "react/jsx-runtime";
import { jsx as jsx57, jsxs as jsxs21 } from "react/jsx-runtime";
import { jsx as jsx58, jsxs as jsxs222 } from "react/jsx-runtime";
import { jsx as jsx59, jsxs as jsxs23 } from "react/jsx-runtime";
import { jsx as jsx60 } from "react/jsx-runtime";
import { jsx as jsx61 } from "react/jsx-runtime";
import { jsx as jsx622 } from "react/jsx-runtime";
import { jsx as jsx632 } from "react/jsx-runtime";
import { jsx as jsx64 } from "react/jsx-runtime";
import { jsx as jsx65 } from "react/jsx-runtime";
import { jsx as jsx66, jsxs as jsxs24 } from "react/jsx-runtime";
import { jsx as jsx67 } from "react/jsx-runtime";
import { jsx as jsx68 } from "react/jsx-runtime";
import { jsx as jsx69, jsxs as jsxs25 } from "react/jsx-runtime";
import clsx16 from "clsx";
import { jsx as jsx70 } from "react/jsx-runtime";
import clsx17 from "clsx";
import { jsx as jsx71 } from "react/jsx-runtime";
import * as React482 from "react";
import { jsx as jsx722 } from "react/jsx-runtime";
import clsx18 from "clsx";
import { jsx as jsx73 } from "react/jsx-runtime";
import { jsx as jsx74, jsxs as jsxs26 } from "react/jsx-runtime";
import React492 from "react";
import { jsx as jsx75, jsxs as jsxs27 } from "react/jsx-runtime";
import React512 from "react";
import * as React502 from "react";
import { Fragment as Fragment10, jsx as jsx76, jsxs as jsxs28 } from "react/jsx-runtime";
import clsx19 from "clsx";
import { jsx as jsx77 } from "react/jsx-runtime";
import { jsx as jsx78, jsxs as jsxs29 } from "react/jsx-runtime";
import React522 from "react";
import { jsx as jsx79, jsxs as jsxs30 } from "react/jsx-runtime";
import React532 from "react";

// ../../node_modules/sonner/dist/index.mjs
import React66 from "react";
import ReactDOM6 from "react-dom";
"use client";
function __insertCSS(code) {
  if (!code || typeof document == "undefined")
    return;
  let head = document.head || document.getElementsByTagName("head")[0];
  let style = document.createElement("style");
  style.type = "text/css";
  head.appendChild(style);
  style.styleSheet ? style.styleSheet.cssText = code : style.appendChild(document.createTextNode(code));
}
var bars = Array(12).fill(0);
var toastsCounter = 1;

class Observer {
  constructor() {
    this.subscribe = (subscriber) => {
      this.subscribers.push(subscriber);
      return () => {
        const index2 = this.subscribers.indexOf(subscriber);
        this.subscribers.splice(index2, 1);
      };
    };
    this.publish = (data) => {
      this.subscribers.forEach((subscriber) => subscriber(data));
    };
    this.addToast = (data) => {
      this.publish(data);
      this.toasts = [
        ...this.toasts,
        data
      ];
    };
    this.create = (data) => {
      var _data_id;
      const { message, ...rest } = data;
      const id = typeof (data == null ? undefined : data.id) === "number" || ((_data_id = data.id) == null ? undefined : _data_id.length) > 0 ? data.id : toastsCounter++;
      const alreadyExists = this.toasts.find((toast) => {
        return toast.id === id;
      });
      const dismissible = data.dismissible === undefined ? true : data.dismissible;
      if (this.dismissedToasts.has(id)) {
        this.dismissedToasts.delete(id);
      }
      if (alreadyExists) {
        this.toasts = this.toasts.map((toast) => {
          if (toast.id === id) {
            this.publish({
              ...toast,
              ...data,
              id,
              title: message
            });
            return {
              ...toast,
              ...data,
              id,
              dismissible,
              title: message
            };
          }
          return toast;
        });
      } else {
        this.addToast({
          title: message,
          ...rest,
          dismissible,
          id
        });
      }
      return id;
    };
    this.dismiss = (id) => {
      if (id) {
        this.dismissedToasts.add(id);
        requestAnimationFrame(() => this.subscribers.forEach((subscriber) => subscriber({
          id,
          dismiss: true
        })));
      } else {
        this.toasts.forEach((toast) => {
          this.subscribers.forEach((subscriber) => subscriber({
            id: toast.id,
            dismiss: true
          }));
        });
      }
      return id;
    };
    this.message = (message, data) => {
      return this.create({
        ...data,
        message
      });
    };
    this.error = (message, data) => {
      return this.create({
        ...data,
        message,
        type: "error"
      });
    };
    this.success = (message, data) => {
      return this.create({
        ...data,
        type: "success",
        message
      });
    };
    this.info = (message, data) => {
      return this.create({
        ...data,
        type: "info",
        message
      });
    };
    this.warning = (message, data) => {
      return this.create({
        ...data,
        type: "warning",
        message
      });
    };
    this.loading = (message, data) => {
      return this.create({
        ...data,
        type: "loading",
        message
      });
    };
    this.promise = (promise, data) => {
      if (!data) {
        return;
      }
      let id = undefined;
      if (data.loading !== undefined) {
        id = this.create({
          ...data,
          promise,
          type: "loading",
          message: data.loading,
          description: typeof data.description !== "function" ? data.description : undefined
        });
      }
      const p = Promise.resolve(promise instanceof Function ? promise() : promise);
      let shouldDismiss = id !== undefined;
      let result;
      const originalPromise = p.then(async (response) => {
        result = [
          "resolve",
          response
        ];
        const isReactElementResponse = React66.isValidElement(response);
        if (isReactElementResponse) {
          shouldDismiss = false;
          this.create({
            id,
            type: "default",
            message: response
          });
        } else if (isHttpResponse(response) && !response.ok) {
          shouldDismiss = false;
          const promiseData = typeof data.error === "function" ? await data.error(`HTTP error! status: ${response.status}`) : data.error;
          const description = typeof data.description === "function" ? await data.description(`HTTP error! status: ${response.status}`) : data.description;
          const isExtendedResult = typeof promiseData === "object" && !React66.isValidElement(promiseData);
          const toastSettings = isExtendedResult ? promiseData : {
            message: promiseData
          };
          this.create({
            id,
            type: "error",
            description,
            ...toastSettings
          });
        } else if (response instanceof Error) {
          shouldDismiss = false;
          const promiseData = typeof data.error === "function" ? await data.error(response) : data.error;
          const description = typeof data.description === "function" ? await data.description(response) : data.description;
          const isExtendedResult = typeof promiseData === "object" && !React66.isValidElement(promiseData);
          const toastSettings = isExtendedResult ? promiseData : {
            message: promiseData
          };
          this.create({
            id,
            type: "error",
            description,
            ...toastSettings
          });
        } else if (data.success !== undefined) {
          shouldDismiss = false;
          const promiseData = typeof data.success === "function" ? await data.success(response) : data.success;
          const description = typeof data.description === "function" ? await data.description(response) : data.description;
          const isExtendedResult = typeof promiseData === "object" && !React66.isValidElement(promiseData);
          const toastSettings = isExtendedResult ? promiseData : {
            message: promiseData
          };
          this.create({
            id,
            type: "success",
            description,
            ...toastSettings
          });
        }
      }).catch(async (error) => {
        result = [
          "reject",
          error
        ];
        if (data.error !== undefined) {
          shouldDismiss = false;
          const promiseData = typeof data.error === "function" ? await data.error(error) : data.error;
          const description = typeof data.description === "function" ? await data.description(error) : data.description;
          const isExtendedResult = typeof promiseData === "object" && !React66.isValidElement(promiseData);
          const toastSettings = isExtendedResult ? promiseData : {
            message: promiseData
          };
          this.create({
            id,
            type: "error",
            description,
            ...toastSettings
          });
        }
      }).finally(() => {
        if (shouldDismiss) {
          this.dismiss(id);
          id = undefined;
        }
        data.finally == null || data.finally.call(data);
      });
      const unwrap = () => new Promise((resolve, reject) => originalPromise.then(() => result[0] === "reject" ? reject(result[1]) : resolve(result[1])).catch(reject));
      if (typeof id !== "string" && typeof id !== "number") {
        return {
          unwrap
        };
      } else {
        return Object.assign(id, {
          unwrap
        });
      }
    };
    this.custom = (jsx35, data) => {
      const id = (data == null ? undefined : data.id) || toastsCounter++;
      this.create({
        jsx: jsx35(id),
        id,
        ...data
      });
      return id;
    };
    this.getActiveToasts = () => {
      return this.toasts.filter((toast) => !this.dismissedToasts.has(toast.id));
    };
    this.subscribers = [];
    this.toasts = [];
    this.dismissedToasts = new Set;
  }
}
var ToastState = new Observer;
var toastFunction = (message, data) => {
  const id = (data == null ? undefined : data.id) || toastsCounter++;
  ToastState.addToast({
    title: message,
    ...data,
    id
  });
  return id;
};
var isHttpResponse = (data) => {
  return data && typeof data === "object" && "ok" in data && typeof data.ok === "boolean" && "status" in data && typeof data.status === "number";
};
var basicToast = toastFunction;
var getHistory = () => ToastState.toasts;
var getToasts = () => ToastState.getActiveToasts();
var toast = Object.assign(basicToast, {
  success: ToastState.success,
  info: ToastState.info,
  warning: ToastState.warning,
  error: ToastState.error,
  custom: ToastState.custom,
  message: ToastState.message,
  promise: ToastState.promise,
  dismiss: ToastState.dismiss,
  loading: ToastState.loading
}, {
  getHistory,
  getToasts
});
__insertCSS("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}");

// ../componentry/dist/vibrant/index.js
import { jsx as jsx80, jsxs as jsxs31 } from "react/jsx-runtime";
import React542 from "react";
import { jsx as jsx81, jsxs as jsxs322 } from "react/jsx-runtime";
import React552 from "react";
import { jsx as jsx822, jsxs as jsxs33 } from "react/jsx-runtime";
import React562 from "react";
import { jsx as jsx83 } from "react/jsx-runtime";
import { jsx as jsx84, jsxs as jsxs34 } from "react/jsx-runtime";
import clsx232 from "clsx";
import React582 from "react";
import clsx21 from "clsx";

// ../../node_modules/cmdk/dist/chunk-NZJY6EH4.mjs
var U2 = 1;
var Y = 0.9;
var H = 0.8;
var J2 = 0.17;
var p = 0.1;
var u = 0.999;
var $ = 0.9999;
var k = 0.99;
var m = /[\\\/_+.#"@\[\(\{&]/;
var B = /[\\\/_+.#"@\[\(\{&]/g;
var K = /[\s-]/;
var X = /[\s-]/g;
function G(_2, C, h, P, A, f, O) {
  if (f === C.length)
    return A === _2.length ? U2 : k;
  var T = `${A},${f}`;
  if (O[T] !== undefined)
    return O[T];
  for (var L = P.charAt(f), c = h.indexOf(L, A), S = 0, E, N, R, M2;c >= 0; )
    E = G(_2, C, h, P, c + 1, f + 1, O), E > S && (c === A ? E *= U2 : m.test(_2.charAt(c - 1)) ? (E *= H, R = _2.slice(A, c - 1).match(B), R && A > 0 && (E *= Math.pow(u, R.length))) : K.test(_2.charAt(c - 1)) ? (E *= Y, M2 = _2.slice(A, c - 1).match(X), M2 && A > 0 && (E *= Math.pow(u, M2.length))) : (E *= J2, A > 0 && (E *= Math.pow(u, c - A))), _2.charAt(c) !== C.charAt(f) && (E *= $)), (E < p && h.charAt(c - 1) === P.charAt(f + 1) || P.charAt(f + 1) === P.charAt(f) && h.charAt(c - 1) !== P.charAt(f)) && (N = G(_2, C, h, P, c + 1, f + 2, O), N * p > E && (E = N * p)), E > S && (S = E), c = h.indexOf(L, c + 1);
  return O[T] = S, S;
}
function D(_2) {
  return _2.toLowerCase().replace(X, " ");
}
function W(_2, C, h) {
  return _2 = h && h.length > 0 ? `${_2 + " " + h.join(" ")}` : _2, G(_2, C, D(_2), D(C), 0, 0, {});
}

// ../../node_modules/cmdk/dist/index.mjs
import * as t2 from "react";
"use client";
var N = '[cmdk-group=""]';
var Y2 = '[cmdk-group-items=""]';
var be = '[cmdk-group-heading=""]';
var le = '[cmdk-item=""]';
var ce = `${le}:not([aria-disabled="true"])`;
var Z = "cmdk-item-select";
var T = "data-value";
var Re = (r, o, n) => W(r, o, n);
var ue = t2.createContext(undefined);
var K2 = () => t2.useContext(ue);
var de = t2.createContext(undefined);
var ee = () => t2.useContext(de);
var fe = t2.createContext(undefined);
var me = t2.forwardRef((r, o) => {
  let n = L(() => {
    var e, a;
    return { search: "", value: (a = (e = r.value) != null ? e : r.defaultValue) != null ? a : "", selectedItemId: undefined, filtered: { count: 0, items: new Map, groups: new Set } };
  }), u2 = L(() => new Set), c = L(() => new Map), d = L(() => new Map), f = L(() => new Set), p2 = pe(r), { label: b, children: m2, value: R, onValueChange: x2, filter: C, shouldFilter: S, loop: A, disablePointerSelection: ge = false, vimBindings: j = true, ...O } = r, $2 = useId2(), q = useId2(), _2 = useId2(), I = t2.useRef(null), v = ke();
  k2(() => {
    if (R !== undefined) {
      let e = R.trim();
      n.current.value = e, E.emit();
    }
  }, [R]), k2(() => {
    v(6, ne);
  }, []);
  let E = t2.useMemo(() => ({ subscribe: (e) => (f.current.add(e), () => f.current.delete(e)), snapshot: () => n.current, setState: (e, a, s) => {
    var i, l, g, y;
    if (!Object.is(n.current[e], a)) {
      if (n.current[e] = a, e === "search")
        J3(), z2(), v(1, W2);
      else if (e === "value") {
        if (document.activeElement.hasAttribute("cmdk-input") || document.activeElement.hasAttribute("cmdk-root")) {
          let h = document.getElementById(_2);
          h ? h.focus() : (i = document.getElementById($2)) == null || i.focus();
        }
        if (v(7, () => {
          var h;
          n.current.selectedItemId = (h = M2()) == null ? undefined : h.id, E.emit();
        }), s || v(5, ne), ((l = p2.current) == null ? undefined : l.value) !== undefined) {
          let h = a != null ? a : "";
          (y = (g = p2.current).onValueChange) == null || y.call(g, h);
          return;
        }
      }
      E.emit();
    }
  }, emit: () => {
    f.current.forEach((e) => e());
  } }), []), U3 = t2.useMemo(() => ({ value: (e, a, s) => {
    var i;
    a !== ((i = d.current.get(e)) == null ? undefined : i.value) && (d.current.set(e, { value: a, keywords: s }), n.current.filtered.items.set(e, te(a, s)), v(2, () => {
      z2(), E.emit();
    }));
  }, item: (e, a) => (u2.current.add(e), a && (c.current.has(a) ? c.current.get(a).add(e) : c.current.set(a, new Set([e]))), v(3, () => {
    J3(), z2(), n.current.value || W2(), E.emit();
  }), () => {
    d.current.delete(e), u2.current.delete(e), n.current.filtered.items.delete(e);
    let s = M2();
    v(4, () => {
      J3(), (s == null ? undefined : s.getAttribute("id")) === e && W2(), E.emit();
    });
  }), group: (e) => (c.current.has(e) || c.current.set(e, new Set), () => {
    d.current.delete(e), c.current.delete(e);
  }), filter: () => p2.current.shouldFilter, label: b || r["aria-label"], getDisablePointerSelection: () => p2.current.disablePointerSelection, listId: $2, inputId: _2, labelId: q, listInnerRef: I }), []);
  function te(e, a) {
    var i, l;
    let s = (l = (i = p2.current) == null ? undefined : i.filter) != null ? l : Re;
    return e ? s(e, n.current.search, a) : 0;
  }
  function z2() {
    if (!n.current.search || p2.current.shouldFilter === false)
      return;
    let e = n.current.filtered.items, a = [];
    n.current.filtered.groups.forEach((i) => {
      let l = c.current.get(i), g = 0;
      l.forEach((y) => {
        let h = e.get(y);
        g = Math.max(h, g);
      }), a.push([i, g]);
    });
    let s = I.current;
    V().sort((i, l) => {
      var h, F;
      let g = i.getAttribute("id"), y = l.getAttribute("id");
      return ((h = e.get(y)) != null ? h : 0) - ((F = e.get(g)) != null ? F : 0);
    }).forEach((i) => {
      let l = i.closest(Y2);
      l ? l.appendChild(i.parentElement === l ? i : i.closest(`${Y2} > *`)) : s.appendChild(i.parentElement === s ? i : i.closest(`${Y2} > *`));
    }), a.sort((i, l) => l[1] - i[1]).forEach((i) => {
      var g;
      let l = (g = I.current) == null ? undefined : g.querySelector(`${N}[${T}="${encodeURIComponent(i[0])}"]`);
      l == null || l.parentElement.appendChild(l);
    });
  }
  function W2() {
    let e = V().find((s) => s.getAttribute("aria-disabled") !== "true"), a = e == null ? undefined : e.getAttribute(T);
    E.setState("value", a || undefined);
  }
  function J3() {
    var a, s, i, l;
    if (!n.current.search || p2.current.shouldFilter === false) {
      n.current.filtered.count = u2.current.size;
      return;
    }
    n.current.filtered.groups = new Set;
    let e = 0;
    for (let g of u2.current) {
      let y = (s = (a = d.current.get(g)) == null ? undefined : a.value) != null ? s : "", h = (l = (i = d.current.get(g)) == null ? undefined : i.keywords) != null ? l : [], F = te(y, h);
      n.current.filtered.items.set(g, F), F > 0 && e++;
    }
    for (let [g, y] of c.current)
      for (let h of y)
        if (n.current.filtered.items.get(h) > 0) {
          n.current.filtered.groups.add(g);
          break;
        }
    n.current.filtered.count = e;
  }
  function ne() {
    var a, s, i;
    let e = M2();
    e && (((a = e.parentElement) == null ? undefined : a.firstChild) === e && ((i = (s = e.closest(N)) == null ? undefined : s.querySelector(be)) == null || i.scrollIntoView({ block: "nearest" })), e.scrollIntoView({ block: "nearest" }));
  }
  function M2() {
    var e;
    return (e = I.current) == null ? undefined : e.querySelector(`${le}[aria-selected="true"]`);
  }
  function V() {
    var e;
    return Array.from(((e = I.current) == null ? undefined : e.querySelectorAll(ce)) || []);
  }
  function X2(e) {
    let s = V()[e];
    s && E.setState("value", s.getAttribute(T));
  }
  function Q(e) {
    var g;
    let a = M2(), s = V(), i = s.findIndex((y) => y === a), l = s[i + e];
    (g = p2.current) != null && g.loop && (l = i + e < 0 ? s[s.length - 1] : i + e === s.length ? s[0] : s[i + e]), l && E.setState("value", l.getAttribute(T));
  }
  function re(e) {
    let a = M2(), s = a == null ? undefined : a.closest(N), i;
    for (;s && !i; )
      s = e > 0 ? we(s, N) : De(s, N), i = s == null ? undefined : s.querySelector(ce);
    i ? E.setState("value", i.getAttribute(T)) : Q(e);
  }
  let oe = () => X2(V().length - 1), ie = (e) => {
    e.preventDefault(), e.metaKey ? oe() : e.altKey ? re(1) : Q(1);
  }, se = (e) => {
    e.preventDefault(), e.metaKey ? X2(0) : e.altKey ? re(-1) : Q(-1);
  };
  return t2.createElement(Primitive2.div, { ref: o, tabIndex: -1, ...O, "cmdk-root": "", onKeyDown: (e) => {
    var s;
    (s = O.onKeyDown) == null || s.call(O, e);
    let a = e.nativeEvent.isComposing || e.keyCode === 229;
    if (!(e.defaultPrevented || a))
      switch (e.key) {
        case "n":
        case "j": {
          j && e.ctrlKey && ie(e);
          break;
        }
        case "ArrowDown": {
          ie(e);
          break;
        }
        case "p":
        case "k": {
          j && e.ctrlKey && se(e);
          break;
        }
        case "ArrowUp": {
          se(e);
          break;
        }
        case "Home": {
          e.preventDefault(), X2(0);
          break;
        }
        case "End": {
          e.preventDefault(), oe();
          break;
        }
        case "Enter": {
          e.preventDefault();
          let i = M2();
          if (i) {
            let l = new Event(Z);
            i.dispatchEvent(l);
          }
        }
      }
  } }, t2.createElement("label", { "cmdk-label": "", htmlFor: U3.inputId, id: U3.labelId, style: Te }, b), B2(r, (e) => t2.createElement(de.Provider, { value: E }, t2.createElement(ue.Provider, { value: U3 }, e))));
});
var he = t2.forwardRef((r, o) => {
  var _2, I;
  let n = useId2(), u2 = t2.useRef(null), c = t2.useContext(fe), d = K2(), f = pe(r), p2 = (I = (_2 = f.current) == null ? undefined : _2.forceMount) != null ? I : c == null ? undefined : c.forceMount;
  k2(() => {
    if (!p2)
      return d.item(n, c == null ? undefined : c.id);
  }, [p2]);
  let b = ve(n, u2, [r.value, r.children, u2], r.keywords), m2 = ee(), R = P((v) => v.value && v.value === b.current), x2 = P((v) => p2 || d.filter() === false ? true : v.search ? v.filtered.items.get(n) > 0 : true);
  t2.useEffect(() => {
    let v = u2.current;
    if (!(!v || r.disabled))
      return v.addEventListener(Z, C), () => v.removeEventListener(Z, C);
  }, [x2, r.onSelect, r.disabled]);
  function C() {
    var v, E;
    S(), (E = (v = f.current).onSelect) == null || E.call(v, b.current);
  }
  function S() {
    m2.setState("value", b.current, true);
  }
  if (!x2)
    return null;
  let { disabled: A, value: ge, onSelect: j, forceMount: O, keywords: $2, ...q } = r;
  return t2.createElement(Primitive2.div, { ref: composeRefs2(u2, o), ...q, id: n, "cmdk-item": "", role: "option", "aria-disabled": !!A, "aria-selected": !!R, "data-disabled": !!A, "data-selected": !!R, onPointerMove: A || d.getDisablePointerSelection() ? undefined : S, onClick: A ? undefined : C }, r.children);
});
var Ee = t2.forwardRef((r, o) => {
  let { heading: n, children: u2, forceMount: c, ...d } = r, f = useId2(), p2 = t2.useRef(null), b = t2.useRef(null), m2 = useId2(), R = K2(), x2 = P((S) => c || R.filter() === false ? true : S.search ? S.filtered.groups.has(f) : true);
  k2(() => R.group(f), []), ve(f, p2, [r.value, r.heading, b]);
  let C = t2.useMemo(() => ({ id: f, forceMount: c }), [c]);
  return t2.createElement(Primitive2.div, { ref: composeRefs2(p2, o), ...d, "cmdk-group": "", role: "presentation", hidden: x2 ? undefined : true }, n && t2.createElement("div", { ref: b, "cmdk-group-heading": "", "aria-hidden": true, id: m2 }, n), B2(r, (S) => t2.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": n ? m2 : undefined }, t2.createElement(fe.Provider, { value: C }, S))));
});
var ye = t2.forwardRef((r, o) => {
  let { alwaysRender: n, ...u2 } = r, c = t2.useRef(null), d = P((f) => !f.search);
  return !n && !d ? null : t2.createElement(Primitive2.div, { ref: composeRefs2(c, o), ...u2, "cmdk-separator": "", role: "separator" });
});
var Se = t2.forwardRef((r, o) => {
  let { onValueChange: n, ...u2 } = r, c = r.value != null, d = ee(), f = P((m2) => m2.search), p2 = P((m2) => m2.selectedItemId), b = K2();
  return t2.useEffect(() => {
    r.value != null && d.setState("search", r.value);
  }, [r.value]), t2.createElement(Primitive2.input, { ref: o, ...u2, "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: false, "aria-autocomplete": "list", role: "combobox", "aria-expanded": true, "aria-controls": b.listId, "aria-labelledby": b.labelId, "aria-activedescendant": p2, id: b.inputId, type: "text", value: c ? r.value : f, onChange: (m2) => {
    c || d.setState("search", m2.target.value), n == null || n(m2.target.value);
  } });
});
var Ce = t2.forwardRef((r, o) => {
  let { children: n, label: u2 = "Suggestions", ...c } = r, d = t2.useRef(null), f = t2.useRef(null), p2 = P((m2) => m2.selectedItemId), b = K2();
  return t2.useEffect(() => {
    if (f.current && d.current) {
      let m2 = f.current, R = d.current, x2, C = new ResizeObserver(() => {
        x2 = requestAnimationFrame(() => {
          let S = m2.offsetHeight;
          R.style.setProperty("--cmdk-list-height", S.toFixed(1) + "px");
        });
      });
      return C.observe(m2), () => {
        cancelAnimationFrame(x2), C.unobserve(m2);
      };
    }
  }, []), t2.createElement(Primitive2.div, { ref: composeRefs2(d, o), ...c, "cmdk-list": "", role: "listbox", tabIndex: -1, "aria-activedescendant": p2, "aria-label": u2, id: b.listId }, B2(r, (m2) => t2.createElement("div", { ref: composeRefs2(f, b.listInnerRef), "cmdk-list-sizer": "" }, m2)));
});
var xe = t2.forwardRef((r, o) => {
  let { open: n, onOpenChange: u2, overlayClassName: c, contentClassName: d, container: f, ...p2 } = r;
  return t2.createElement(Root6, { open: n, onOpenChange: u2 }, t2.createElement(Portal5, { container: f }, t2.createElement(Overlay, { "cmdk-overlay": "", className: c }), t2.createElement(Content3, { "aria-label": r.label, "cmdk-dialog": "", className: d }, t2.createElement(me, { ref: o, ...p2 }))));
});
var Ie = t2.forwardRef((r, o) => P((u2) => u2.filtered.count === 0) ? t2.createElement(Primitive2.div, { ref: o, ...r, "cmdk-empty": "", role: "presentation" }) : null);
var Pe = t2.forwardRef((r, o) => {
  let { progress: n, children: u2, label: c = "Loading...", ...d } = r;
  return t2.createElement(Primitive2.div, { ref: o, ...d, "cmdk-loading": "", role: "progressbar", "aria-valuenow": n, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": c }, B2(r, (f) => t2.createElement("div", { "aria-hidden": true }, f)));
});
var _e = Object.assign(me, { List: Ce, Item: he, Input: Se, Group: Ee, Separator: ye, Dialog: xe, Empty: Ie, Loading: Pe });
function we(r, o) {
  let n = r.nextElementSibling;
  for (;n; ) {
    if (n.matches(o))
      return n;
    n = n.nextElementSibling;
  }
}
function De(r, o) {
  let n = r.previousElementSibling;
  for (;n; ) {
    if (n.matches(o))
      return n;
    n = n.previousElementSibling;
  }
}
function pe(r) {
  let o = t2.useRef(r);
  return k2(() => {
    o.current = r;
  }), o;
}
var k2 = typeof window == "undefined" ? t2.useEffect : t2.useLayoutEffect;
function L(r) {
  let o = t2.useRef();
  return o.current === undefined && (o.current = r()), o;
}
function P(r) {
  let o = ee(), n = () => r(o.snapshot());
  return t2.useSyncExternalStore(o.subscribe, n, n);
}
function ve(r, o, n, u2 = []) {
  let c = t2.useRef(), d = K2();
  return k2(() => {
    var b;
    let f = (() => {
      var m2;
      for (let R of n) {
        if (typeof R == "string")
          return R.trim();
        if (typeof R == "object" && "current" in R)
          return R.current ? (m2 = R.current.textContent) == null ? undefined : m2.trim() : c.current;
      }
    })(), p2 = u2.map((m2) => m2.trim());
    d.value(r, f, p2), (b = o.current) == null || b.setAttribute(T, f), c.current = f;
  }), c;
}
var ke = () => {
  let [r, o] = t2.useState(), n = L(() => new Map);
  return k2(() => {
    n.current.forEach((u2) => u2()), n.current = new Map;
  }, [r]), (u2, c) => {
    n.current.set(u2, c), o({});
  };
};
function Me(r) {
  let o = r.type;
  return typeof o == "function" ? o(r.props) : ("render" in o) ? o.render(r.props) : r;
}
function B2({ asChild: r, children: o }, n) {
  return r && t2.isValidElement(o) ? t2.cloneElement(Me(o), { ref: o.ref }, n(o.props.children)) : n(o);
}
var Te = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" };

// ../componentry/dist/vibrant/index.js
import clsx20 from "clsx";
import { jsx as jsx85, jsxs as jsxs35 } from "react/jsx-runtime";
import { jsx as jsx86, jsxs as jsxs36 } from "react/jsx-runtime";
import * as React572 from "react";
import { jsx as jsx87 } from "react/jsx-runtime";
import clsx222 from "clsx";
import { jsx as jsx88 } from "react/jsx-runtime";
import { jsx as jsx89, jsxs as jsxs37 } from "react/jsx-runtime";
import React592 from "react";
import { jsx as jsx90, jsxs as jsxs38 } from "react/jsx-runtime";
import clsx242 from "clsx";
import React602 from "react";
import { jsx as jsx91, jsxs as jsxs39 } from "react/jsx-runtime";
import React612 from "react";
import { jsx as jsx922, jsxs as jsxs40 } from "react/jsx-runtime";
import * as React622 from "react";
import { Fragment as Fragment112, jsx as jsx93, jsxs as jsxs41 } from "react/jsx-runtime";
import clsx25 from "clsx";
import { jsx as jsx94, jsxs as jsxs422 } from "react/jsx-runtime";
import { jsx as jsx95, jsxs as jsxs43 } from "react/jsx-runtime";
import React632 from "react";
import { jsx as jsx96, jsxs as jsxs44 } from "react/jsx-runtime";
import React642 from "react";
import { jsx as jsx97, jsxs as jsxs45 } from "react/jsx-runtime";
import React652 from "react";
import { jsx as jsx98, jsxs as jsxs46 } from "react/jsx-runtime";
import { jsx as jsx99, jsxs as jsxs47 } from "react/jsx-runtime";
import React662 from "react";
import { jsx as jsx100, jsxs as jsxs48 } from "react/jsx-runtime";
import * as React672 from "react";
import { jsx as jsx101 } from "react/jsx-runtime";
import clsx26 from "clsx";
import { jsx as jsx1022 } from "react/jsx-runtime";
import { jsx as jsx103, jsxs as jsxs49 } from "react/jsx-runtime";
import { jsx as jsx104 } from "react/jsx-runtime";
import { jsx as jsx105 } from "react/jsx-runtime";
import React682 from "react";
import { jsx as jsx106, jsxs as jsxs50 } from "react/jsx-runtime";
import { jsx as jsx107, jsxs as jsxs51 } from "react/jsx-runtime";
import { jsx as jsx108, jsxs as jsxs522 } from "react/jsx-runtime";
import React692 from "react";
import { jsx as jsx109, jsxs as jsxs53 } from "react/jsx-runtime";
import React70 from "react";
import { jsx as jsx110, jsxs as jsxs54 } from "react/jsx-runtime";
import React71 from "react";
import { jsx as jsx111, jsxs as jsxs55 } from "react/jsx-runtime";
import * as React722 from "react";
import { jsx as jsx1122 } from "react/jsx-runtime";
import clsx27 from "clsx";
import { jsx as jsx113, jsxs as jsxs56 } from "react/jsx-runtime";
import { jsx as jsx114, jsxs as jsxs57 } from "react/jsx-runtime";
import { jsx as jsx115, jsxs as jsxs58 } from "react/jsx-runtime";
import * as React73 from "react";
import { Fragment as Fragment122, jsx as jsx116, jsxs as jsxs59 } from "react/jsx-runtime";
import clsx28 from "clsx";
import { jsx as jsx117, jsxs as jsxs60 } from "react/jsx-runtime";
import { jsx as jsx118, jsxs as jsxs61 } from "react/jsx-runtime";
import { jsx as jsx119, jsxs as jsxs622 } from "react/jsx-runtime";
import React74 from "react";
import { jsx as jsx120, jsxs as jsxs63 } from "react/jsx-runtime";
import React76 from "react";
import * as React75 from "react";
import { jsx as jsx121 } from "react/jsx-runtime";
import clsx29 from "clsx";
import { jsx as jsx1222 } from "react/jsx-runtime";
import { jsx as jsx123 } from "react/jsx-runtime";
import React78 from "react";
import * as React2102 from "react";
import * as React77 from "react";
import { jsx as jsx124, jsxs as jsxs64 } from "react/jsx-runtime";
import { jsx as jsx242 } from "react/jsx-runtime";
import clsx30 from "clsx";
import { jsx as jsx125 } from "react/jsx-runtime";
import { jsx as jsx126, jsxs as jsxs65 } from "react/jsx-runtime";
import { jsx as jsx127, jsxs as jsxs66 } from "react/jsx-runtime";
import React81 from "react";
import * as React2122 from "react";
import * as React79 from "react";
import { Fragment as Fragment132, jsx as jsx128, jsxs as jsxs67 } from "react/jsx-runtime";
import clsx31 from "clsx";
import { jsx as jsx129, jsxs as jsxs68 } from "react/jsx-runtime";
import * as React80 from "react";
import { jsx as jsx130 } from "react/jsx-runtime";
import clsx322 from "clsx";
import { jsx as jsx131 } from "react/jsx-runtime";
import { jsx as jsx1322, jsxs as jsxs69 } from "react/jsx-runtime";
import { jsx as jsx133, jsxs as jsxs70 } from "react/jsx-runtime";
import { jsx as jsx134, jsxs as jsxs71 } from "react/jsx-runtime";
import { jsx as jsx135, jsxs as jsxs72 } from "react/jsx-runtime";
import { jsx as jsx136, jsxs as jsxs73 } from "react/jsx-runtime";
import { jsx as jsx137, jsxs as jsxs74 } from "react/jsx-runtime";
import React822 from "react";
import clsx332 from "clsx";
import { jsx as jsx138, jsxs as jsxs75 } from "react/jsx-runtime";
import { jsx as jsx139, jsxs as jsxs76 } from "react/jsx-runtime";
import React83 from "react";
import { jsx as jsx140, jsxs as jsxs77 } from "react/jsx-runtime";
import clsx34 from "clsx";
import { jsx as jsx141 } from "react/jsx-runtime";
import { jsx as jsx1422, jsxs as jsxs78 } from "react/jsx-runtime";
import { jsx as jsx143, jsxs as jsxs79 } from "react/jsx-runtime";
import { clsx as clsx36 } from "clsx";
import React85 from "react";
import * as React84 from "react";
import { jsx as jsx144, jsxs as jsxs80 } from "react/jsx-runtime";
import clsx35 from "clsx";
import { jsx as jsx145, jsxs as jsxs81 } from "react/jsx-runtime";
import { jsx as jsx146 } from "react/jsx-runtime";
import { jsx as jsx147 } from "react/jsx-runtime";
import React87 from "react";
import * as React86 from "react";
import { jsx as jsx148, jsxs as jsxs822 } from "react/jsx-runtime";
import clsx37 from "clsx";
import { jsx as jsx149 } from "react/jsx-runtime";
import { jsx as jsx150, jsxs as jsxs83 } from "react/jsx-runtime";
import React88 from "react";
import { jsx as jsx151, jsxs as jsxs84 } from "react/jsx-runtime";
import clsx38 from "clsx";
import { jsx as jsx1522 } from "react/jsx-runtime";
import { jsx as jsx153, jsxs as jsxs85 } from "react/jsx-runtime";
import React90 from "react";
import * as React89 from "react";
import { jsx as jsx154 } from "react/jsx-runtime";
import clsx39 from "clsx";
import { jsx as jsx155 } from "react/jsx-runtime";
import { jsx as jsx156, jsxs as jsxs86 } from "react/jsx-runtime";
import clsx40 from "clsx";
import { jsx as jsx157 } from "react/jsx-runtime";
import { jsx as jsx158 } from "react/jsx-runtime";
import { jsx as jsx159 } from "react/jsx-runtime";
import { jsx as jsx160, jsxs as jsxs87 } from "react/jsx-runtime";
import { jsx as jsx161, jsxs as jsxs88 } from "react/jsx-runtime";
import React91 from "react";
import { jsx as jsx1622, jsxs as jsxs89 } from "react/jsx-runtime";
import React922 from "react";
import { jsx as jsx163, jsxs as jsxs90 } from "react/jsx-runtime";
import * as React93 from "react";
import { jsx as jsx164 } from "react/jsx-runtime";
import clsx41 from "clsx";
import { jsx as jsx165 } from "react/jsx-runtime";
import { jsx as jsx166 } from "react/jsx-runtime";
import { jsx as jsx167 } from "react/jsx-runtime";
import React95 from "react";
import React94 from "react";
import { jsx as jsx168 } from "react/jsx-runtime";
import clsx422 from "clsx";
import { jsx as jsx169 } from "react/jsx-runtime";
import { jsx as jsx170, jsxs as jsxs91 } from "react/jsx-runtime";
import { jsx as jsx171, jsxs as jsxs92 } from "react/jsx-runtime";
import { jsx as jsx1722, jsxs as jsxs93 } from "react/jsx-runtime";
import { jsx as jsx173, jsxs as jsxs94 } from "react/jsx-runtime";
import { jsx as jsx174, jsxs as jsxs95 } from "react/jsx-runtime";
import { jsx as jsx175, jsxs as jsxs96 } from "react/jsx-runtime";
import { jsx as jsx176 } from "react/jsx-runtime";
import { jsx as jsx177 } from "react/jsx-runtime";
import { jsx as jsx178 } from "react/jsx-runtime";
import { jsx as jsx179, jsxs as jsxs97 } from "react/jsx-runtime";
import { jsx as jsx180, jsxs as jsxs98 } from "react/jsx-runtime";
import { jsx as jsx181 } from "react/jsx-runtime";
import { jsx as jsx1822, jsxs as jsxs99 } from "react/jsx-runtime";
import { jsx as jsx183 } from "react/jsx-runtime";
import { jsx as jsx184 } from "react/jsx-runtime";
import { jsx as jsx185 } from "react/jsx-runtime";
import { jsx as jsx186 } from "react/jsx-runtime";
import { jsx as jsx187 } from "react/jsx-runtime";
import { jsx as jsx188 } from "react/jsx-runtime";
import { jsx as jsx189 } from "react/jsx-runtime";
import { jsx as jsx190, jsxs as jsxs100 } from "react/jsx-runtime";
import { jsx as jsx191 } from "react/jsx-runtime";
import { jsx as jsx1922 } from "react/jsx-runtime";
import { jsx as jsx193 } from "react/jsx-runtime";
import { jsx as jsx194, jsxs as jsxs101 } from "react/jsx-runtime";
import { jsx as jsx195, jsxs as jsxs102 } from "react/jsx-runtime";
import clsx432 from "clsx";
import { jsx as jsx196 } from "react/jsx-runtime";
import clsx44 from "clsx";
import { jsx as jsx197 } from "react/jsx-runtime";
import { useMemo as useMemo112 } from "react";
import clsx45 from "clsx";
import { jsx as jsx198, jsxs as jsxs103 } from "react/jsx-runtime";
import React96 from "react";

// ../../node_modules/react-hook-form/dist/index.esm.mjs
import React67 from "react";
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
var isObjectType = (value) => typeof value === "object";
var isObject = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy;
  const isArray = Array.isArray(data);
  const isFileListInstance = typeof FileList !== "undefined" ? data instanceof FileList : false;
  if (data instanceof Date) {
    copy = new Date(data);
  } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject(data))) {
    copy = isArray ? [] : Object.create(Object.getPrototypeOf(data));
    if (!isArray && !isPlainObject(data)) {
      copy = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy;
}
var isKey = (value) => /^\w*$/.test(value);
var isUndefined = (val) => val === undefined;
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var get = (object, path, defaultValue) => {
  if (!path || !isObject(object)) {
    return defaultValue;
  }
  const result = (isKey(path) ? [path] : stringToPath(path)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
};
var isBoolean = (value) => typeof value === "boolean";
var set = (object, path, value) => {
  let index2 = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index2 < length) {
    const key = tempPath[index2];
    let newValue = value;
    if (index2 !== lastIndex) {
      const objValue = object[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index2 + 1]) ? [] : {};
    }
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return;
    }
    object[key] = newValue;
    object = object[key];
  }
};
var EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
var VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
var HookFormContext = React67.createContext(null);
HookFormContext.displayName = "HookFormContext";
var useFormContext = () => React67.useContext(HookFormContext);
var FormProvider = (props) => {
  const { children, ...data } = props;
  return React67.createElement(HookFormContext.Provider, { value: data }, children);
};
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var useIsomorphicLayoutEffect3 = typeof window !== "undefined" ? React67.useLayoutEffect : React67.useEffect;
function useFormState(props) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = React67.useState(control._formState);
  const _localProxyFormState = React67.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  useIsomorphicLayoutEffect3(() => control._subscribe({
    name,
    formState: _localProxyFormState.current,
    exact,
    callback: (formState2) => {
      !disabled && updateFormState({
        ...control._formState,
        ...formState2
      });
    }
  }), [name, disabled, exact]);
  React67.useEffect(() => {
    _localProxyFormState.current.isValid && control._setValid(true);
  }, [control]);
  return React67.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual2(object1, object2, _internal_visited = new WeakSet) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  if (_internal_visited.has(object1) || _internal_visited.has(object2)) {
    return true;
  }
  _internal_visited.add(object1);
  _internal_visited.add(object2);
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual2(val1, val2, _internal_visited) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
function useWatch(props) {
  const methods = useFormContext();
  const { control = methods.control, name, defaultValue, disabled, exact, compute } = props || {};
  const _defaultValue = React67.useRef(defaultValue);
  const _compute = React67.useRef(compute);
  const _computeFormValues = React67.useRef(undefined);
  _compute.current = compute;
  const defaultValueMemo = React67.useMemo(() => control._getWatch(name, _defaultValue.current), [control, name]);
  const [value, updateValue] = React67.useState(_compute.current ? _compute.current(defaultValueMemo) : defaultValueMemo);
  useIsomorphicLayoutEffect3(() => control._subscribe({
    name,
    formState: {
      values: true
    },
    exact,
    callback: (formState) => {
      if (!disabled) {
        const formValues = generateWatchOutput(name, control._names, formState.values || control._formValues, false, _defaultValue.current);
        if (_compute.current) {
          const computedFormValues = _compute.current(formValues);
          if (!deepEqual2(computedFormValues, _computeFormValues.current)) {
            updateValue(computedFormValues);
            _computeFormValues.current = computedFormValues;
          }
        } else {
          updateValue(formValues);
        }
      }
    }
  }), [control, disabled, name, exact]);
  React67.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props) {
  const methods = useFormContext();
  const { name, disabled, control = methods.control, shouldUnregister, defaultValue } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const defaultValueMemo = React67.useMemo(() => get(control._formValues, name, get(control._defaultValues, name, defaultValue)), [control, name, defaultValue]);
  const value = useWatch({
    control,
    name,
    defaultValue: defaultValueMemo,
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _props = React67.useRef(props);
  const _previousNameRef = React67.useRef(undefined);
  const _registerProps = React67.useRef(control.register(name, {
    ...props.rules,
    value,
    ...isBoolean(props.disabled) ? { disabled: props.disabled } : {}
  }));
  _props.current = props;
  const fieldState = React67.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: true,
      get: () => !!get(formState.errors, name)
    },
    isDirty: {
      enumerable: true,
      get: () => !!get(formState.dirtyFields, name)
    },
    isTouched: {
      enumerable: true,
      get: () => !!get(formState.touchedFields, name)
    },
    isValidating: {
      enumerable: true,
      get: () => !!get(formState.validatingFields, name)
    },
    error: {
      enumerable: true,
      get: () => get(formState.errors, name)
    }
  }), [formState, name]);
  const onChange = React67.useCallback((event) => _registerProps.current.onChange({
    target: {
      value: getEventValue(event),
      name
    },
    type: EVENTS.CHANGE
  }), [name]);
  const onBlur = React67.useCallback(() => _registerProps.current.onBlur({
    target: {
      value: get(control._formValues, name),
      name
    },
    type: EVENTS.BLUR
  }), [name, control._formValues]);
  const ref = React67.useCallback((elm) => {
    const field2 = get(control._fields, name);
    if (field2 && elm) {
      field2._f.ref = {
        focus: () => elm.focus && elm.focus(),
        select: () => elm.select && elm.select(),
        setCustomValidity: (message) => elm.setCustomValidity(message),
        reportValidity: () => elm.reportValidity()
      };
    }
  }, [control._fields, name]);
  const field = React67.useMemo(() => ({
    name,
    value,
    ...isBoolean(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
    onChange,
    onBlur,
    ref
  }), [name, disabled, formState.disabled, onChange, onBlur, ref, value]);
  React67.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    const previousName = _previousNameRef.current;
    if (previousName && previousName !== name && !isArrayField) {
      control.unregister(previousName);
    }
    control.register(name, {
      ..._props.current.rules,
      ...isBoolean(_props.current.disabled) ? { disabled: _props.current.disabled } : {}
    });
    const updateMounted = (name2, value2) => {
      const field2 = get(control._fields, name2);
      if (field2 && field2._f) {
        field2._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get(control._options.defaultValues, name, _props.current.defaultValue));
      set(control._defaultValues, name, value2);
      if (isUndefined(get(control._formValues, name))) {
        set(control._formValues, name, value2);
      }
    }
    !isArrayField && control.register(name);
    _previousNameRef.current = name;
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  React67.useEffect(() => {
    control._setDisabledField({
      disabled,
      name
    });
  }, [disabled, name, control]);
  return React67.useMemo(() => ({
    field,
    formState,
    fieldState
  }), [field, formState, fieldState]);
}
var Controller = (props) => props.render(useController(props));
var defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};

// ../componentry/dist/vibrant/index.js
import clsx46 from "clsx";
import { jsx as jsx199 } from "react/jsx-runtime";
import clsx47 from "clsx";
import { jsx as jsx200 } from "react/jsx-runtime";
import clsx48 from "clsx";
import { jsx as jsx201 } from "react/jsx-runtime";
import clsx49 from "clsx";
import { jsx as jsx2022 } from "react/jsx-runtime";
import clsx50 from "clsx";
import React98 from "react";
import React97 from "react";
import { jsx as jsx203, jsxs as jsxs104 } from "react/jsx-runtime";
import { jsx as jsx204 } from "react/jsx-runtime";
var __create3 = Object.create;
var __getProtoOf3 = Object.getPrototypeOf;
var __defProp3 = Object.defineProperty;
var __getOwnPropNames3 = Object.getOwnPropertyNames;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __toESM3 = (mod, isNodeMode, target) => {
  target = mod != null ? __create3(__getProtoOf3(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames3(mod))
    if (!__hasOwnProp3.call(to, key))
      __defProp3(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS3 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export3 = (target, all) => {
  for (var name in all)
    __defProp3(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm2 = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var exports_react_dom_production2 = {};
__export3(exports_react_dom_production2, {
  version: () => $version2,
  useFormStatus: () => $useFormStatus2,
  useFormState: () => $useFormState2,
  unstable_batchedUpdates: () => $unstable_batchedUpdates2,
  requestFormReset: () => $requestFormReset2,
  preloadModule: () => $preloadModule2,
  preload: () => $preload2,
  preinitModule: () => $preinitModule2,
  preinit: () => $preinit2,
  prefetchDNS: () => $prefetchDNS2,
  preconnect: () => $preconnect2,
  flushSync: () => $flushSync2,
  createPortal: () => $createPortal2,
  __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: () => $__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE2
});
function formatProdErrorMessage2(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2;i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function noop4() {}
function createPortal$12(children, containerInfo, implementation) {
  var key = 3 < arguments.length && arguments[3] !== undefined ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE2,
    key: key == null ? null : "" + key,
    children,
    containerInfo,
    implementation
  };
}
function getCrossOriginStringAs2(as, input) {
  if (as === "font")
    return "";
  if (typeof input === "string")
    return input === "use-credentials" ? input : "";
}
var Internals2;
var REACT_PORTAL_TYPE2;
var ReactSharedInternals2;
var $__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE2;
var $createPortal2 = function(children, container) {
  var key = 2 < arguments.length && arguments[2] !== undefined ? arguments[2] : null;
  if (!container || container.nodeType !== 1 && container.nodeType !== 9 && container.nodeType !== 11)
    throw Error(formatProdErrorMessage2(299));
  return createPortal$12(children, container, null, key);
};
var $flushSync2 = function(fn) {
  var previousTransition = ReactSharedInternals2.T, previousUpdatePriority = Internals2.p;
  try {
    if (ReactSharedInternals2.T = null, Internals2.p = 2, fn)
      return fn();
  } finally {
    ReactSharedInternals2.T = previousTransition, Internals2.p = previousUpdatePriority, Internals2.d.f();
  }
};
var $preconnect2 = function(href2, options3) {
  typeof href2 === "string" && (options3 ? (options3 = options3.crossOrigin, options3 = typeof options3 === "string" ? options3 === "use-credentials" ? options3 : "" : undefined) : options3 = null, Internals2.d.C(href2, options3));
};
var $prefetchDNS2 = function(href2) {
  typeof href2 === "string" && Internals2.d.D(href2);
};
var $preinit2 = function(href2, options3) {
  if (typeof href2 === "string" && options3 && typeof options3.as === "string") {
    var as = options3.as, crossOrigin = getCrossOriginStringAs2(as, options3.crossOrigin), integrity = typeof options3.integrity === "string" ? options3.integrity : undefined, fetchPriority = typeof options3.fetchPriority === "string" ? options3.fetchPriority : undefined;
    as === "style" ? Internals2.d.S(href2, typeof options3.precedence === "string" ? options3.precedence : undefined, {
      crossOrigin,
      integrity,
      fetchPriority
    }) : as === "script" && Internals2.d.X(href2, {
      crossOrigin,
      integrity,
      fetchPriority,
      nonce: typeof options3.nonce === "string" ? options3.nonce : undefined
    });
  }
};
var $preinitModule2 = function(href2, options3) {
  if (typeof href2 === "string")
    if (typeof options3 === "object" && options3 !== null) {
      if (options3.as == null || options3.as === "script") {
        var crossOrigin = getCrossOriginStringAs2(options3.as, options3.crossOrigin);
        Internals2.d.M(href2, {
          crossOrigin,
          integrity: typeof options3.integrity === "string" ? options3.integrity : undefined,
          nonce: typeof options3.nonce === "string" ? options3.nonce : undefined
        });
      }
    } else
      options3 == null && Internals2.d.M(href2);
};
var $preload2 = function(href2, options3) {
  if (typeof href2 === "string" && typeof options3 === "object" && options3 !== null && typeof options3.as === "string") {
    var as = options3.as, crossOrigin = getCrossOriginStringAs2(as, options3.crossOrigin);
    Internals2.d.L(href2, as, {
      crossOrigin,
      integrity: typeof options3.integrity === "string" ? options3.integrity : undefined,
      nonce: typeof options3.nonce === "string" ? options3.nonce : undefined,
      type: typeof options3.type === "string" ? options3.type : undefined,
      fetchPriority: typeof options3.fetchPriority === "string" ? options3.fetchPriority : undefined,
      referrerPolicy: typeof options3.referrerPolicy === "string" ? options3.referrerPolicy : undefined,
      imageSrcSet: typeof options3.imageSrcSet === "string" ? options3.imageSrcSet : undefined,
      imageSizes: typeof options3.imageSizes === "string" ? options3.imageSizes : undefined,
      media: typeof options3.media === "string" ? options3.media : undefined
    });
  }
};
var $preloadModule2 = function(href2, options3) {
  if (typeof href2 === "string")
    if (options3) {
      var crossOrigin = getCrossOriginStringAs2(options3.as, options3.crossOrigin);
      Internals2.d.m(href2, {
        as: typeof options3.as === "string" && options3.as !== "script" ? options3.as : undefined,
        crossOrigin,
        integrity: typeof options3.integrity === "string" ? options3.integrity : undefined
      });
    } else
      Internals2.d.m(href2);
};
var $requestFormReset2 = function(form) {
  Internals2.d.r(form);
};
var $unstable_batchedUpdates2 = function(fn, a) {
  return fn(a);
};
var $useFormState2 = function(action, initialState, permalink) {
  return ReactSharedInternals2.H.useFormState(action, initialState, permalink);
};
var $useFormStatus2 = function() {
  return ReactSharedInternals2.H.useHostTransitionStatus();
};
var $version2 = "19.2.0";
var init_react_dom_production2 = __esm2(() => {
  Internals2 = {
    d: {
      f: noop4,
      r: function() {
        throw Error(formatProdErrorMessage2(522));
      },
      D: noop4,
      C: noop4,
      L: noop4,
      m: noop4,
      X: noop4,
      S: noop4,
      M: noop4
    },
    p: 0,
    findDOMNode: null
  };
  REACT_PORTAL_TYPE2 = Symbol.for("react.portal");
  ReactSharedInternals2 = React39.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  $__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE2 = Internals2;
});
var require_react_dom2 = __commonJS3((exports, module) => {
  init_react_dom_production2();
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    if (false) {}
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  if (true) {
    checkDCE();
    module.exports = exports_react_dom_production2;
  } else {}
});
var require_use_sync_external_store_shim_production2 = __commonJS3((exports) => {
  function is(x2, y) {
    return x2 === y && (x2 !== 0 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
  }
  var objectIs = typeof Object.is === "function" ? Object.is : is;
  var useState172 = React432.useState;
  var useEffect202 = React432.useEffect;
  var useLayoutEffect42 = React432.useLayoutEffect;
  var useDebugValue2 = React432.useDebugValue;
  function useSyncExternalStore$2(subscribe2, getSnapshot) {
    var value = getSnapshot(), _useState = useState172({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    useLayoutEffect42(function() {
      inst.value = value;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceUpdate({ inst });
    }, [subscribe2, value, getSnapshot]);
    useEffect202(function() {
      checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      return subscribe2(function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      });
    }, [subscribe2]);
    useDebugValue2(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function useSyncExternalStore$1(subscribe2, getSnapshot) {
    return getSnapshot();
  }
  var shim = typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined" ? useSyncExternalStore$1 : useSyncExternalStore$2;
  exports.useSyncExternalStore = React432.useSyncExternalStore !== undefined ? React432.useSyncExternalStore : shim;
});
var require_shim2 = __commonJS3((exports, module) => {
  if (true) {
    module.exports = require_use_sync_external_store_shim_production2();
  } else {}
});
var SvgIcon4 = createSpriteIcon("lucide");
function setRef3(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== undefined) {
    ref.current = value;
  }
}
function composeRefs3(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef3(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0;i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef3(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs3(...refs) {
  return React68.useCallback(composeRefs3(...refs), refs);
}
function createSlot3(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone3(ownerName);
  const Slot22 = React214.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React214.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable3);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React214.Children.count(newElement) > 1)
            return React214.Children.only(null);
          return React214.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsx40(SlotClone, { ...slotProps, ref: forwardedRef, children: React214.isValidElement(newElement) ? React214.cloneElement(newElement, undefined, newChildren) : null });
    }
    return /* @__PURE__ */ jsx40(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot4 = /* @__PURE__ */ createSlot3("Slot");
function createSlotClone3(ownerName) {
  const SlotClone = React214.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React214.isValidElement(children)) {
      const childrenRef = getElementRef6(children);
      const props2 = mergeProps3(slotProps, children.props);
      if (children.type !== React214.Fragment) {
        props2.ref = forwardedRef ? composeRefs3(forwardedRef, childrenRef) : childrenRef;
      }
      return React214.cloneElement(children, props2);
    }
    return React214.Children.count(children) > 1 ? React214.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER3 = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return /* @__PURE__ */ jsx40(Fragment23, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER3;
  return Slottable2;
}
function isSlottable3(child) {
  return React214.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER3;
}
function mergeProps3(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef6(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var buttonVariants2 = cva("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", {
  variants: {
    variant: {
      default: "bg-primary text-primary-foreground hover:bg-primary/90",
      destructive: "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
      outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
      secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
      ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
      link: "text-primary underline-offset-4 hover:underline"
    },
    size: {
      default: "h-9 px-4 py-2 has-[>svg]:px-3",
      sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
      lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
      icon: "size-9",
      "icon-sm": "size-8",
      "icon-lg": "size-10"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "default"
  }
});
function Button({
  className,
  variant,
  size: size4,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot4 : "button";
  return /* @__PURE__ */ jsx210(Comp, {
    "data-slot": "button",
    className: clsx9(buttonVariants2({ variant, size: size4, className })),
    ...props
  });
}
function Pagination({ className, ...props }) {
  return /* @__PURE__ */ jsx35("nav", {
    role: "navigation",
    "aria-label": "pagination",
    "data-slot": "pagination",
    className: clsx24("mx-auto flex w-full justify-center", className),
    ...props
  });
}
function PaginationContent({ className, ...props }) {
  return /* @__PURE__ */ jsx35("ul", {
    "data-slot": "pagination-content",
    className: clsx24("flex flex-row items-center gap-1", className),
    ...props
  });
}
function PaginationItem({ ...props }) {
  return /* @__PURE__ */ jsx35("li", {
    "data-slot": "pagination-item",
    ...props
  });
}
function PaginationLink({ className, isActive, size: size4 = "icon", ...props }) {
  return /* @__PURE__ */ jsx35("a", {
    "aria-current": isActive ? "page" : undefined,
    "data-slot": "pagination-link",
    "data-active": isActive,
    className: clsx24(buttonVariants2({
      variant: isActive ? "outline" : "ghost",
      size: size4
    }), className),
    ...props
  });
}
function PaginationPrevious({ className, ...props }) {
  return /* @__PURE__ */ jsxs8(PaginationLink, {
    "aria-label": "Go to previous page",
    size: "default",
    className: clsx24("gap-1 px-2.5 sm:pl-2.5", className),
    ...props,
    children: [
      /* @__PURE__ */ jsx35(SvgIcon4, {
        iconId: "ChevronLeft"
      }),
      /* @__PURE__ */ jsx35("span", {
        className: "hidden sm:block",
        children: "Previous"
      })
    ]
  });
}
function PaginationNext({ className, ...props }) {
  return /* @__PURE__ */ jsxs8(PaginationLink, {
    "aria-label": "Go to next page",
    size: "default",
    className: clsx24("gap-1 px-2.5 sm:pr-2.5", className),
    ...props,
    children: [
      /* @__PURE__ */ jsx35("span", {
        className: "hidden sm:block",
        children: "Next"
      }),
      /* @__PURE__ */ jsx35(SvgIcon4, {
        iconId: "ChevronRight"
      })
    ]
  });
}
function PaginationEllipsis({ className, ...props }) {
  return /* @__PURE__ */ jsxs8("span", {
    "aria-hidden": true,
    "data-slot": "pagination-ellipsis",
    className: clsx24("flex size-9 items-center justify-center", className),
    ...props,
    children: [
      /* @__PURE__ */ jsx35(SvgIcon4, {
        iconId: "Ellipsis",
        className: "size-4"
      }),
      /* @__PURE__ */ jsx35("span", {
        className: "sr-only",
        children: "More pages"
      })
    ]
  });
}
var ReactDOM4 = __toESM3(require_react_dom2(), 1);
function clamp3(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
var canUseDOM3 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function composeEventHandlers3(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
function createContext24(rootComponentName, defaultContext) {
  const Context = React410.createContext(defaultContext);
  const Provider = (props) => {
    const { children, ...context } = props;
    const value = React410.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsx44(Context.Provider, { value, children });
  };
  Provider.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React410.useContext(Context);
    if (context)
      return context;
    if (defaultContext !== undefined)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext22];
}
function createContextScope3(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React410.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const value = React410.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsx44(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const context = React410.useContext(Context);
      if (context)
        return context;
      if (defaultContext !== undefined)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React410.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return React410.useMemo(() => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }), [scope, contexts]);
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes3(createScope, ...createContextScopeDeps)];
}
function composeContextScopes3(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React410.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function createCollection3(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope5] = createContextScope3(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React510.useRef(null);
    const itemMap = React510.useRef(/* @__PURE__ */ new Map).current;
    return /* @__PURE__ */ jsx53(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot3(COLLECTION_SLOT_NAME);
  const CollectionSlot = React510.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = useComposedRefs3(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ jsx53(CollectionSlotImpl, { ref: composedRefs, children });
  });
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot3(ITEM_SLOT_NAME);
  const CollectionItemSlot = React510.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = React510.useRef(null);
    const composedRefs = useComposedRefs3(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    React510.useEffect(() => {
      context.itemMap.set(ref, { ref, ...itemData });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ jsx53(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
  });
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection5(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React510.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort((a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current));
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection5,
    createCollectionScope5
  ];
}
var __instanciated3 = /* @__PURE__ */ new WeakMap;
var OrderedDict3 = class _OrderedDict3 extends Map {
  #keys;
  constructor(entries) {
    super(entries);
    this.#keys = [...super.keys()];
    __instanciated3.set(this, true);
  }
  set(key, value) {
    if (__instanciated3.get(this)) {
      if (this.has(key)) {
        this.#keys[this.#keys.indexOf(key)] = key;
      } else {
        this.#keys.push(key);
      }
    }
    super.set(key, value);
    return this;
  }
  insert(index2, key, value) {
    const has = this.has(key);
    const length = this.#keys.length;
    const relativeIndex = toSafeInteger3(index2);
    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
    if (safeIndex === this.size || has && safeIndex === this.size - 1 || safeIndex === -1) {
      this.set(key, value);
      return this;
    }
    const size4 = this.size + (has ? 0 : 1);
    if (relativeIndex < 0) {
      actualIndex++;
    }
    const keys = [...this.#keys];
    let nextValue;
    let shouldSkip = false;
    for (let i = actualIndex;i < size4; i++) {
      if (actualIndex === i) {
        let nextKey = keys[i];
        if (keys[i] === key) {
          nextKey = keys[i + 1];
        }
        if (has) {
          this.delete(key);
        }
        nextValue = this.get(nextKey);
        this.set(key, value);
      } else {
        if (!shouldSkip && keys[i - 1] === key) {
          shouldSkip = true;
        }
        const currentKey = keys[shouldSkip ? i : i - 1];
        const currentValue = nextValue;
        nextValue = this.get(currentKey);
        this.delete(currentKey);
        this.set(currentKey, currentValue);
      }
    }
    return this;
  }
  with(index2, key, value) {
    const copy = new _OrderedDict3(this);
    copy.insert(index2, key, value);
    return copy;
  }
  before(key) {
    const index2 = this.#keys.indexOf(key) - 1;
    if (index2 < 0) {
      return;
    }
    return this.entryAt(index2);
  }
  setBefore(key, newKey, value) {
    const index2 = this.#keys.indexOf(key);
    if (index2 === -1) {
      return this;
    }
    return this.insert(index2, newKey, value);
  }
  after(key) {
    let index2 = this.#keys.indexOf(key);
    index2 = index2 === -1 || index2 === this.size - 1 ? -1 : index2 + 1;
    if (index2 === -1) {
      return;
    }
    return this.entryAt(index2);
  }
  setAfter(key, newKey, value) {
    const index2 = this.#keys.indexOf(key);
    if (index2 === -1) {
      return this;
    }
    return this.insert(index2 + 1, newKey, value);
  }
  first() {
    return this.entryAt(0);
  }
  last() {
    return this.entryAt(-1);
  }
  clear() {
    this.#keys = [];
    return super.clear();
  }
  delete(key) {
    const deleted = super.delete(key);
    if (deleted) {
      this.#keys.splice(this.#keys.indexOf(key), 1);
    }
    return deleted;
  }
  deleteAt(index2) {
    const key = this.keyAt(index2);
    if (key !== undefined) {
      return this.delete(key);
    }
    return false;
  }
  at(index2) {
    const key = at3(this.#keys, index2);
    if (key !== undefined) {
      return this.get(key);
    }
  }
  entryAt(index2) {
    const key = at3(this.#keys, index2);
    if (key !== undefined) {
      return [key, this.get(key)];
    }
  }
  indexOf(key) {
    return this.#keys.indexOf(key);
  }
  keyAt(index2) {
    return at3(this.#keys, index2);
  }
  from(key, offset4) {
    const index2 = this.indexOf(key);
    if (index2 === -1) {
      return;
    }
    let dest = index2 + offset4;
    if (dest < 0)
      dest = 0;
    if (dest >= this.size)
      dest = this.size - 1;
    return this.at(dest);
  }
  keyFrom(key, offset4) {
    const index2 = this.indexOf(key);
    if (index2 === -1) {
      return;
    }
    let dest = index2 + offset4;
    if (dest < 0)
      dest = 0;
    if (dest >= this.size)
      dest = this.size - 1;
    return this.keyAt(dest);
  }
  find(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return entry;
      }
      index2++;
    }
    return;
  }
  findIndex(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return index2;
      }
      index2++;
    }
    return -1;
  }
  filter(predicate, thisArg) {
    const entries = [];
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        entries.push(entry);
      }
      index2++;
    }
    return new _OrderedDict3(entries);
  }
  map(callbackfn, thisArg) {
    const entries = [];
    let index2 = 0;
    for (const entry of this) {
      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index2, this])]);
      index2++;
    }
    return new _OrderedDict3(entries);
  }
  reduce(...args) {
    const [callbackfn, initialValue] = args;
    let index2 = 0;
    let accumulator = initialValue ?? this.at(0);
    for (const entry of this) {
      if (index2 === 0 && args.length === 1) {
        accumulator = entry;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index2, this]);
      }
      index2++;
    }
    return accumulator;
  }
  reduceRight(...args) {
    const [callbackfn, initialValue] = args;
    let accumulator = initialValue ?? this.at(-1);
    for (let index2 = this.size - 1;index2 >= 0; index2--) {
      const entry = this.at(index2);
      if (index2 === this.size - 1 && args.length === 1) {
        accumulator = entry;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index2, this]);
      }
    }
    return accumulator;
  }
  toSorted(compareFn) {
    const entries = [...this.entries()].sort(compareFn);
    return new _OrderedDict3(entries);
  }
  toReversed() {
    const reversed = new _OrderedDict3;
    for (let index2 = this.size - 1;index2 >= 0; index2--) {
      const key = this.keyAt(index2);
      const element = this.get(key);
      reversed.set(key, element);
    }
    return reversed;
  }
  toSpliced(...args) {
    const entries = [...this.entries()];
    entries.splice(...args);
    return new _OrderedDict3(entries);
  }
  slice(start, end) {
    const result = new _OrderedDict3;
    let stop = this.size - 1;
    if (start === undefined) {
      return result;
    }
    if (start < 0) {
      start = start + this.size;
    }
    if (end !== undefined && end > 0) {
      stop = end - 1;
    }
    for (let index2 = start;index2 <= stop; index2++) {
      const key = this.keyAt(index2);
      const element = this.get(key);
      result.set(key, element);
    }
    return result;
  }
  every(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (!Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return false;
      }
      index2++;
    }
    return true;
  }
  some(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return true;
      }
      index2++;
    }
    return false;
  }
};
function at3(array, index2) {
  if ("at" in Array.prototype) {
    return Array.prototype.at.call(array, index2);
  }
  const actualIndex = toSafeIndex3(array, index2);
  return actualIndex === -1 ? undefined : array[actualIndex];
}
function toSafeIndex3(array, index2) {
  const length = array.length;
  const relativeIndex = toSafeInteger3(index2);
  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
}
function toSafeInteger3(number) {
  return number !== number || number === 0 ? 0 : Math.trunc(number);
}
var DirectionContext3 = React69.createContext(undefined);
function useDirection3(localDir) {
  const globalDir = React69.useContext(DirectionContext3);
  return localDir || globalDir || "ltr";
}
var ReactDOM7 = __toESM3(require_react_dom2(), 1);
var NODES3 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive3 = NODES3.reduce((primitive, node) => {
  const Slot22 = createSlot3(`Primitive.${node}`);
  const Node2 = React72.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot22 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsx72(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent3(target, event) {
  if (target)
    ReactDOM7.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef6(callback) {
  const callbackRef = React82.useRef(callback);
  React82.useEffect(() => {
    callbackRef.current = callback;
  });
  return React82.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useEscapeKeydown3(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef6(onEscapeKeyDownProp);
  React92.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME3 = "DismissableLayer";
var CONTEXT_UPDATE3 = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE3 = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE3 = "dismissableLayer.focusOutside";
var originalBodyPointerEvents3;
var DismissableLayerContext3 = React102.createContext({
  layers: /* @__PURE__ */ new Set,
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set,
  branches: /* @__PURE__ */ new Set
});
var DismissableLayer3 = React102.forwardRef((props, forwardedRef) => {
  const {
    disableOutsidePointerEvents = false,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss,
    ...layerProps
  } = props;
  const context = React102.useContext(DismissableLayerContext3);
  const [node, setNode] = React102.useState(null);
  const ownerDocument = node?.ownerDocument ?? globalThis?.document;
  const [, force] = React102.useState({});
  const composedRefs = useComposedRefs3(forwardedRef, (node2) => setNode(node2));
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node ? layers.indexOf(node) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = usePointerDownOutside3((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside?.(event);
    onInteractOutside?.(event);
    if (!event.defaultPrevented)
      onDismiss?.();
  }, ownerDocument);
  const focusOutside = useFocusOutside3((event) => {
    const target = event.target;
    const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
    if (isFocusInBranch)
      return;
    onFocusOutside?.(event);
    onInteractOutside?.(event);
    if (!event.defaultPrevented)
      onDismiss?.();
  }, ownerDocument);
  useEscapeKeydown3((event) => {
    const isHighestLayer = index2 === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown?.(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  React102.useEffect(() => {
    if (!node)
      return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        originalBodyPointerEvents3 = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node);
    }
    context.layers.add(node);
    dispatchUpdate3();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
        ownerDocument.body.style.pointerEvents = originalBodyPointerEvents3;
      }
    };
  }, [node, ownerDocument, disableOutsidePointerEvents, context]);
  React102.useEffect(() => {
    return () => {
      if (!node)
        return;
      context.layers.delete(node);
      context.layersWithOutsidePointerEventsDisabled.delete(node);
      dispatchUpdate3();
    };
  }, [node, context]);
  React102.useEffect(() => {
    const handleUpdate = () => force({});
    document.addEventListener(CONTEXT_UPDATE3, handleUpdate);
    return () => document.removeEventListener(CONTEXT_UPDATE3, handleUpdate);
  }, []);
  return /* @__PURE__ */ jsx82(Primitive3.div, {
    ...layerProps,
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : undefined,
      ...props.style
    },
    onFocusCapture: composeEventHandlers3(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: composeEventHandlers3(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: composeEventHandlers3(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  });
});
DismissableLayer3.displayName = DISMISSABLE_LAYER_NAME3;
var BRANCH_NAME3 = "DismissableLayerBranch";
var DismissableLayerBranch3 = React102.forwardRef((props, forwardedRef) => {
  const context = React102.useContext(DismissableLayerContext3);
  const ref = React102.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  React102.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsx82(Primitive3.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch3.displayName = BRANCH_NAME3;
function usePointerDownOutside3(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef6(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React102.useRef(false);
  const handleClickRef = React102.useRef(() => {});
  React102.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent3(POINTER_DOWN_OUTSIDE3, handlePointerDownOutside, eventDetail, { discrete: true });
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside3(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef6(onFocusOutside);
  const isFocusInsideReactTreeRef = React102.useRef(false);
  React102.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent3(FOCUS_OUTSIDE3, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate3() {
  const event = new CustomEvent(CONTEXT_UPDATE3);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent3(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent3(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var count6 = 0;
function useFocusGuards3() {
  React112.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard3());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard3());
    count6++;
    return () => {
      if (count6 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count6--;
    };
  }, []);
}
function createFocusGuard3() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var AUTOFOCUS_ON_MOUNT3 = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT3 = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS6 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME3 = "FocusScope";
var FocusScope3 = React122.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React122.useState(null);
  const onMountAutoFocus = useCallbackRef6(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef6(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React122.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setContainer(node));
  const focusScope = React122.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React122.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus3(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus3(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus3(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React122.useEffect(() => {
    if (container) {
      focusScopesStack3.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT3, EVENT_OPTIONS6);
        container.addEventListener(AUTOFOCUS_ON_MOUNT3, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst7(removeLinks3(getTabbableCandidates3(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus3(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT3, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT3, EVENT_OPTIONS6);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT3, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus3(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT3, onUnmountAutoFocus);
          focusScopesStack3.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React122.useCallback((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container2 = event.currentTarget;
      const [first, last] = getTabbableEdges3(container2);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container2)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop)
            focus3(first, { select: true });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop)
            focus3(last, { select: true });
        }
      }
    }
  }, [loop, trapped, focusScope.paused]);
  return /* @__PURE__ */ jsx92(Primitive3.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope3.displayName = FOCUS_SCOPE_NAME3;
function focusFirst7(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus3(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges3(container) {
  const candidates = getTabbableCandidates3(container);
  const first = findVisible3(candidates, container);
  const last = findVisible3(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates3(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible3(elements, container) {
  for (const element of elements) {
    if (!isHidden3(element, { upTo: container }))
      return element;
  }
}
function isHidden3(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== undefined && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput3(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus3(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput3(element) && select)
      element.select();
  }
}
var focusScopesStack3 = createFocusScopesStack3();
function createFocusScopesStack3() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove3(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove3(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove3(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks3(items) {
  return items.filter((item) => item.tagName !== "A");
}
var useLayoutEffect24 = globalThis?.document ? React132.useLayoutEffect : () => {};
var useReactId3 = React142[" useId ".trim().toString()] || (() => {
  return;
});
var count22 = 0;
function useId3(deterministicId) {
  const [id, setId] = React142.useState(useReactId3());
  useLayoutEffect24(() => {
    if (!deterministicId)
      setId((reactId) => reactId ?? String(count22++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}
var sides2 = ["top", "right", "bottom", "left"];
var min2 = Math.min;
var max2 = Math.max;
var round2 = Math.round;
var floor2 = Math.floor;
var createCoords2 = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap2 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap2 = {
  start: "end",
  end: "start"
};
function clamp22(start, value, end) {
  return max2(start, min2(value, end));
}
function evaluate2(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide2(placement) {
  return placement.split("-")[0];
}
function getAlignment2(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis2(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength2(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides2 = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis2(placement) {
  return yAxisSides2.has(getSide2(placement)) ? "y" : "x";
}
function getAlignmentAxis2(placement) {
  return getOppositeAxis2(getSideAxis2(placement));
}
function getAlignmentSides2(placement, rects, rtl) {
  if (rtl === undefined) {
    rtl = false;
  }
  const alignment = getAlignment2(placement);
  const alignmentAxis = getAlignmentAxis2(placement);
  const length = getAxisLength2(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement2(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement2(mainAlignmentSide)];
}
function getExpandedPlacements2(placement) {
  const oppositePlacement = getOppositePlacement2(placement);
  return [getOppositeAlignmentPlacement2(placement), oppositePlacement, getOppositeAlignmentPlacement2(oppositePlacement)];
}
function getOppositeAlignmentPlacement2(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap2[alignment]);
}
var lrPlacement2 = ["left", "right"];
var rlPlacement2 = ["right", "left"];
var tbPlacement2 = ["top", "bottom"];
var btPlacement2 = ["bottom", "top"];
function getSideList2(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rlPlacement2 : lrPlacement2;
      return isStart ? lrPlacement2 : rlPlacement2;
    case "left":
    case "right":
      return isStart ? tbPlacement2 : btPlacement2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements2(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment2(placement);
  let list = getSideList2(getSide2(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement2));
    }
  }
  return list;
}
function getOppositePlacement2(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap2[side]);
}
function expandPaddingObject2(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject2(padding) {
  return typeof padding !== "number" ? expandPaddingObject2(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect2(rect) {
  const {
    x: x2,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x2,
    right: x2 + width,
    bottom: y + height,
    x: x2,
    y
  };
}
function computeCoordsFromPlacement2(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis2(placement);
  const alignmentAxis = getAlignmentAxis2(placement);
  const alignLength = getAxisLength2(alignmentAxis);
  const side = getSide2(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment2(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition3 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? undefined : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y
  } = computeCoordsFromPlacement2(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0;i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y
        } = computeCoordsFromPlacement2(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x: x2,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow2(state, options3) {
  var _await$platform$isEle;
  if (options3 === undefined) {
    options3 = {};
  }
  const {
    x: x2,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate2(options3, state);
  const paddingObject = getPaddingObject2(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect2(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? undefined : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? undefined : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? undefined : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? undefined : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? undefined : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect2(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow4 = (options3) => ({
  name: "arrow",
  options: options3,
  async fn(state) {
    const {
      x: x2,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate2(options3, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject2(padding);
    const coords = {
      x: x2,
      y
    };
    const axis = getAlignmentAxis2(placement);
    const length = getAxisLength2(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? undefined : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? undefined : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max22 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp22(min$1, center, max22);
    const shouldAddOffset = !middlewareData.arrow && getAlignment2(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max22 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip4 = function(options3) {
  if (options3 === undefined) {
    options3 = {};
  }
  return {
    name: "flip",
    options: options3,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate2(options3, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide2(placement);
      const initialSideAxis = getSideAxis2(initialPlacement);
      const isBasePlacement = getSide2(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? undefined : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement2(initialPlacement)] : getExpandedPlacements2(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements2(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow2(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? undefined : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides22 = getAlignmentSides2(placement, rects, rtl);
        overflows.push(overflow[sides22[0]], overflow[sides22[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? undefined : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis2(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || overflowsData.every((d) => getSideAxis2(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? undefined : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis2(d.placement);
                  return currentSideAxis === initialSideAxis || currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? undefined : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets2(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped2(overflow) {
  return sides2.some((side) => overflow[side] >= 0);
}
var hide4 = function(options3) {
  if (options3 === undefined) {
    options3 = {};
  }
  return {
    name: "hide",
    options: options3,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate2(options3, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow2(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets2(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped2(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow2(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets2(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped2(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides2 = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords2(state, options3) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? undefined : platform2.isRTL(elements.floating));
  const side = getSide2(placement);
  const alignment = getAlignment2(placement);
  const isVertical = getSideAxis2(placement) === "y";
  const mainAxisMulti = originSides2.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate2(options3, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset4 = function(options3) {
  if (options3 === undefined) {
    options3 = 0;
  }
  return {
    name: "offset",
    options: options3,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords2(state, options3);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? undefined : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift4 = function(options3) {
  if (options3 === undefined) {
    options3 = {};
  }
  return {
    name: "shift",
    options: options3,
    async fn(state) {
      const {
        x: x2,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x22,
              y: y2
            } = _ref;
            return {
              x: x22,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate2(options3, state);
      const coords = {
        x: x2,
        y
      };
      const overflow = await detectOverflow2(state, detectOverflowOptions);
      const crossAxis = getSideAxis2(getSide2(placement));
      const mainAxis = getOppositeAxis2(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min22 = mainAxisCoord + overflow[minSide];
        const max22 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp22(min22, mainAxisCoord, max22);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min22 = crossAxisCoord + overflow[minSide];
        const max22 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp22(min22, crossAxisCoord, max22);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift4 = function(options3) {
  if (options3 === undefined) {
    options3 = {};
  }
  return {
    options: options3,
    fn(state) {
      const {
        x: x2,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset22 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate2(options3, state);
      const coords = {
        x: x2,
        y
      };
      const crossAxis = getSideAxis2(placement);
      const mainAxis = getOppositeAxis2(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate2(offset22, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides2.has(getSide2(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? undefined : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? undefined : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size4 = function(options3) {
  if (options3 === undefined) {
    options3 = {};
  }
  return {
    name: "size",
    options: options3,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = evaluate2(options3, state);
      const overflow = await detectOverflow2(state, detectOverflowOptions);
      const side = getSide2(placement);
      const alignment = getAlignment2(placement);
      const isYAxis = getSideAxis2(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? undefined : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max2(overflow.left, 0);
        const xMax = max2(overflow.right, 0);
        const yMin = max2(overflow.top, 0);
        const yMax = max2(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow2() {
  return typeof window !== "undefined";
}
function getNodeName2(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? undefined : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? undefined : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow2()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  if (!hasWindow2()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  if (!hasWindow2()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (!hasWindow2() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
var invalidOverflowDisplayValues2 = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle22(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues2.has(display);
}
var tableElements2 = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement2(element) {
  return tableElements2.has(getNodeName2(element));
}
var topLayerSelectors2 = [":popover-open", ":modal"];
function isTopLayer2(element) {
  return topLayerSelectors2.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e2) {
      return false;
    }
  });
}
var transformProperties2 = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues2 = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues2 = ["paint", "layout", "strict", "content"];
function isContainingBlock2(elementOrCss) {
  const webkit = isWebKit2();
  const css = isElement2(elementOrCss) ? getComputedStyle22(elementOrCss) : elementOrCss;
  return transformProperties2.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues2.some((value) => (css.willChange || "").includes(value)) || containValues2.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock2(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode2(currentNode)) {
    if (isContainingBlock2(currentNode)) {
      return currentNode;
    } else if (isTopLayer2(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit2() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames2 = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode2(node) {
  return lastTraversableNodeNames2.has(getNodeName2(node));
}
function getComputedStyle22(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll2(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node) {
  if (getNodeName2(node) === "html") {
    return node;
  }
  const result = node.assignedSlot || node.parentNode || isShadowRoot2(node) && node.host || getDocumentElement2(node);
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor2(node) {
  const parentNode = getParentNode2(node);
  if (isLastTraversableNode2(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor2(parentNode);
}
function getOverflowAncestors2(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === undefined) {
    list = [];
  }
  if (traverseIframes === undefined) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor2(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? undefined : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement2(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors2(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors2(scrollableAncestor, [], traverseIframes));
}
function getFrameElement2(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions2(element) {
  const css = getComputedStyle22(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement2(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale2(element) {
  const domElement = unwrapElement2(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords2(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions2(domElement);
  let x2 = ($2 ? round2(rect.width) : rect.width) / width;
  let y = ($2 ? round2(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x: x2,
    y
  };
}
var noOffsets2 = /* @__PURE__ */ createCoords2(0);
function getVisualOffsets2(element) {
  const win = getWindow2(element);
  if (!isWebKit2() || !win.visualViewport) {
    return noOffsets2;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets2(element, isFixed, floatingOffsetParent) {
  if (isFixed === undefined) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect2(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === undefined) {
    includeScale = false;
  }
  if (isFixedStrategy === undefined) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement2(element);
  let scale = createCoords2(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale2(offsetParent);
      }
    } else {
      scale = getScale2(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets2(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets2(domElement) : createCoords2(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement2(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale2(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle22(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y += top;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement2(currentWin);
    }
  }
  return rectToClientRect2({
    width,
    height,
    x: x2,
    y
  });
}
function getWindowScrollBarX2(element, rect) {
  const leftScroll = getNodeScroll2(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect2(getDocumentElement2(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset2(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX2(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect2(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement2(offsetParent);
  const topLayer = elements ? isTopLayer2(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords2(1);
  const offsets = createCoords2(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll2(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect2(offsetParent);
      scale = getScale2(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset2(documentElement, scroll) : createCoords2(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects2(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect2(element) {
  const html = getDocumentElement2(element);
  const scroll = getNodeScroll2(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX2(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle22(body).direction === "rtl") {
    x2 += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
var SCROLLBAR_MAX2 = 25;
function getViewportRect2(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement2(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit2();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX2(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX2) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX2) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
var absoluteOrFixed2 = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect2(element, strategy) {
  const clientRect = getBoundingClientRect2(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale2(element) : createCoords2(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y
  };
}
function getClientRectFromClippingAncestor2(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect2(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect2(getDocumentElement2(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect2(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets2(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect2(rect);
}
function hasFixedPositionAncestor2(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode2(parentNode)) {
    return false;
  }
  return getComputedStyle22(parentNode).position === "fixed" || hasFixedPositionAncestor2(parentNode, stopNode);
}
function getClippingElementAncestors2(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors2(element, [], false).filter((el) => isElement2(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle22(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode2(currentNode)) {
    const computedStyle = getComputedStyle22(currentNode);
    const currentNodeIsContaining = isContainingBlock2(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed2.has(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor2(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect2(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer2(element) ? [] : getClippingElementAncestors2(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor2(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor2(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions2(element) {
  const {
    width,
    height
  } = getCssDimensions2(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent2(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect2(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords2(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX2(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll2(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect2(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset2(documentElement, scroll) : createCoords2(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned2(element) {
  return getComputedStyle22(element).position === "static";
}
function getTrueOffsetParent2(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle22(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement2(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent2(element, polyfill) {
  const win = getWindow2(element);
  if (isTopLayer2(element)) {
    return win;
  }
  if (!isHTMLElement2(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode2(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned2(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent2(element, polyfill);
  while (offsetParent && isTableElement2(offsetParent) && isStaticPositioned2(offsetParent)) {
    offsetParent = getTrueOffsetParent2(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode2(offsetParent) && isStaticPositioned2(offsetParent) && !isContainingBlock2(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock2(element) || win;
}
var getElementRects2 = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent2;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent2(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL2(element) {
  return getComputedStyle22(element).direction === "rtl";
}
var platform2 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect2,
  getDocumentElement: getDocumentElement2,
  getClippingRect: getClippingRect2,
  getOffsetParent: getOffsetParent2,
  getElementRects: getElementRects2,
  getClientRects: getClientRects2,
  getDimensions: getDimensions2,
  getScale: getScale2,
  isElement: isElement2,
  isRTL: isRTL2
};
function rectsAreEqual2(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove2(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === undefined) {
      skip = false;
    }
    if (threshold === undefined) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor2(top);
    const insetRight = floor2(root.clientWidth - (left + width));
    const insetBottom = floor2(root.clientHeight - (top + height));
    const insetLeft = floor2(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options3 = {
      rootMargin,
      threshold: max2(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 0.0000001);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual2(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options3,
        root: root.ownerDocument
      });
    } catch (_e2) {
      io = new IntersectionObserver(handleObserve, options3);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate2(reference, floating, update, options3) {
  if (options3 === undefined) {
    options3 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options3;
  const referenceEl = unwrapElement2(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors2(referenceEl) : [], ...getOverflowAncestors2(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove2(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect2(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect2(reference);
    if (prevRefRect && !rectsAreEqual2(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset22 = offset4;
var shift22 = shift4;
var flip22 = flip4;
var size22 = size4;
var hide22 = hide4;
var arrow22 = arrow4;
var limitShift22 = limitShift4;
var computePosition22 = (reference, floating, options3) => {
  const cache = new Map;
  const mergedOptions = {
    platform: platform2,
    ...options3
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition3(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var ReactDOM22 = __toESM3(require_react_dom2(), 1);
var isClient2 = typeof document !== "undefined";
var noop22 = function noop32() {};
var index2 = isClient2 ? useLayoutEffect32 : noop22;
function deepEqual3(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length)
        return false;
      for (i = length;i-- !== 0; ) {
        if (!deepEqual3(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length;i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length;i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual3(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR2(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR2(element, value) {
  const dpr = getDPR2(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef2(value) {
  const ref = React152.useRef(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating2(options3) {
  if (options3 === undefined) {
    options3 = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform22,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options3;
  const [data, setData] = React152.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React152.useState(middleware);
  if (!deepEqual3(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React152.useState(null);
  const [_floating, _setFloating] = React152.useState(null);
  const setReference = React152.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React152.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React152.useRef(null);
  const floatingRef = React152.useRef(null);
  const dataRef = React152.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef2(whileElementsMounted);
  const platformRef = useLatestRef2(platform22);
  const openRef = useLatestRef2(open);
  const update = React152.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition22(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual3(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM22.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index2(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React152.useRef(false);
  index2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index2(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React152.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React152.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React152.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR2(elements.floating, data.x);
    const y = roundByDPR2(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y + "px)",
        ...getDPR2(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React152.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$12 = (options3) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options: options3,
    fn(state) {
      const {
        element,
        padding
      } = typeof options3 === "function" ? options3(state) : options3;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow22({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow22({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset32 = (options3, deps) => ({
  ...offset22(options3),
  options: [options3, deps]
});
var shift32 = (options3, deps) => ({
  ...shift22(options3),
  options: [options3, deps]
});
var limitShift32 = (options3, deps) => ({
  ...limitShift22(options3),
  options: [options3, deps]
});
var flip32 = (options3, deps) => ({
  ...flip22(options3),
  options: [options3, deps]
});
var size32 = (options3, deps) => ({
  ...size22(options3),
  options: [options3, deps]
});
var hide32 = (options3, deps) => ({
  ...hide22(options3),
  options: [options3, deps]
});
var arrow32 = (options3, deps) => ({
  ...arrow$12(options3),
  options: [options3, deps]
});
var NAME2 = "Arrow";
var Arrow3 = React162.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsx102(Primitive3.svg, {
    ...arrowProps,
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none",
    children: props.asChild ? children : /* @__PURE__ */ jsx102("polygon", { points: "0,0 30,0 15,10" })
  });
});
Arrow3.displayName = NAME2;
var Root8 = Arrow3;
function useSize2(element) {
  const [size42, setSize] = React172.useState(undefined);
  useLayoutEffect24(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(undefined);
    }
  }, [element]);
  return size42;
}
var POPPER_NAME2 = "Popper";
var [createPopperContext2, createPopperScope2] = createContextScope3(POPPER_NAME2);
var [PopperProvider2, usePopperContext2] = createPopperContext2(POPPER_NAME2);
var Popper2 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React182.useState(null);
  return /* @__PURE__ */ jsx112(PopperProvider2, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper2.displayName = POPPER_NAME2;
var ANCHOR_NAME3 = "PopperAnchor";
var PopperAnchor2 = React182.forwardRef((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context = usePopperContext2(ANCHOR_NAME3, __scopePopper);
  const ref = React182.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  const anchorRef = React182.useRef(null);
  React182.useEffect(() => {
    const previousAnchor = anchorRef.current;
    anchorRef.current = virtualRef?.current || ref.current;
    if (previousAnchor !== anchorRef.current) {
      context.onAnchorChange(anchorRef.current);
    }
  });
  return virtualRef ? null : /* @__PURE__ */ jsx112(Primitive3.div, { ...anchorProps, ref: composedRefs });
});
PopperAnchor2.displayName = ANCHOR_NAME3;
var CONTENT_NAME7 = "PopperContent";
var [PopperContentProvider2, useContentContext2] = createPopperContext2(CONTENT_NAME7);
var PopperContent2 = React182.forwardRef((props, forwardedRef) => {
  const {
    __scopePopper,
    side = "bottom",
    sideOffset = 0,
    align = "center",
    alignOffset = 0,
    arrowPadding = 0,
    avoidCollisions = true,
    collisionBoundary = [],
    collisionPadding: collisionPaddingProp = 0,
    sticky = "partial",
    hideWhenDetached = false,
    updatePositionStrategy = "optimized",
    onPlaced,
    ...contentProps
  } = props;
  const context = usePopperContext2(CONTENT_NAME7, __scopePopper);
  const [content, setContent] = React182.useState(null);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setContent(node));
  const [arrow42, setArrow] = React182.useState(null);
  const arrowSize = useSize2(arrow42);
  const arrowWidth = arrowSize?.width ?? 0;
  const arrowHeight = arrowSize?.height ?? 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter(isNotNull2),
    altBoundary: hasExplicitBoundaries
  };
  const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating2({
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: (...args) => {
      const cleanup = autoUpdate2(...args, {
        animationFrame: updatePositionStrategy === "always"
      });
      return cleanup;
    },
    elements: {
      reference: context.anchor
    },
    middleware: [
      offset32({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
      avoidCollisions && shift32({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? limitShift32() : undefined,
        ...detectOverflowOptions
      }),
      avoidCollisions && flip32({ ...detectOverflowOptions }),
      size32({
        ...detectOverflowOptions,
        apply: ({ elements, rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          const contentStyle = elements.floating.style;
          contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
          contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
          contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
          contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
        }
      }),
      arrow42 && arrow32({ element: arrow42, padding: arrowPadding }),
      transformOrigin2({ arrowWidth, arrowHeight }),
      hideWhenDetached && hide32({ strategy: "referenceHidden", ...detectOverflowOptions })
    ]
  });
  const [placedSide, placedAlign] = getSideAndAlignFromPlacement2(placement);
  const handlePlaced = useCallbackRef6(onPlaced);
  useLayoutEffect24(() => {
    if (isPositioned) {
      handlePlaced?.();
    }
  }, [isPositioned, handlePlaced]);
  const arrowX = middlewareData.arrow?.x;
  const arrowY = middlewareData.arrow?.y;
  const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
  const [contentZIndex, setContentZIndex] = React182.useState();
  useLayoutEffect24(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  return /* @__PURE__ */ jsx112("div", {
    ref: refs.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...floatingStyles,
      transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        middlewareData.transformOrigin?.x,
        middlewareData.transformOrigin?.y
      ].join(" "),
      ...middlewareData.hide?.referenceHidden && {
        visibility: "hidden",
        pointerEvents: "none"
      }
    },
    dir: props.dir,
    children: /* @__PURE__ */ jsx112(PopperContentProvider2, {
      scope: __scopePopper,
      placedSide,
      onArrowChange: setArrow,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow,
      children: /* @__PURE__ */ jsx112(Primitive3.div, {
        "data-side": placedSide,
        "data-align": placedAlign,
        ...contentProps,
        ref: composedRefs,
        style: {
          ...contentProps.style,
          animation: !isPositioned ? "none" : undefined
        }
      })
    })
  });
});
PopperContent2.displayName = CONTENT_NAME7;
var ARROW_NAME4 = "PopperArrow";
var OPPOSITE_SIDE2 = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow3 = React182.forwardRef(function PopperArrow22(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext2(ARROW_NAME4, __scopePopper);
  const baseSide = OPPOSITE_SIDE2[contentContext.placedSide];
  return /* @__PURE__ */ jsx112("span", {
    ref: contentContext.onArrowChange,
    style: {
      position: "absolute",
      left: contentContext.arrowX,
      top: contentContext.arrowY,
      [baseSide]: 0,
      transformOrigin: {
        top: "",
        right: "0 0",
        bottom: "center 0",
        left: "100% 0"
      }[contentContext.placedSide],
      transform: {
        top: "translateY(100%)",
        right: "translateY(50%) rotate(90deg) translateX(-50%)",
        bottom: `rotate(180deg)`,
        left: "translateY(50%) rotate(-90deg) translateX(50%)"
      }[contentContext.placedSide],
      visibility: contentContext.shouldHideArrow ? "hidden" : undefined
    },
    children: /* @__PURE__ */ jsx112(Root8, {
      ...arrowProps,
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        display: "block"
      }
    })
  });
});
PopperArrow3.displayName = ARROW_NAME4;
function isNotNull2(value) {
  return value !== null;
}
var transformOrigin2 = (options3) => ({
  name: "transformOrigin",
  options: options3,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options3.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options3.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement2(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x2 = "";
    let y = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x2, y } };
  }
});
function getSideAndAlignFromPlacement2(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root22 = Popper2;
var Anchor3 = PopperAnchor2;
var Content5 = PopperContent2;
var Arrow23 = PopperArrow3;
var import_react_dom22 = __toESM3(require_react_dom2(), 1);
var PORTAL_NAME8 = "Portal";
var Portal6 = React192.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React192.useState(false);
  useLayoutEffect24(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? import_react_dom22.default.createPortal(/* @__PURE__ */ jsx122(Primitive3.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal6.displayName = PORTAL_NAME8;
var useInsertionEffect3 = React202[" useInsertionEffect ".trim().toString()] || useLayoutEffect24;
function useControllableState3({
  prop,
  defaultProp,
  onChange = () => {},
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState3({
    defaultProp,
    onChange
  });
  const isControlled = prop !== undefined;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React202.useRef(prop !== undefined);
    React202.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(`${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`);
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React202.useCallback((nextValue) => {
    if (isControlled) {
      const value2 = isFunction3(nextValue) ? nextValue(prop) : nextValue;
      if (value2 !== prop) {
        onChangeRef.current?.(value2);
      }
    } else {
      setUncontrolledProp(nextValue);
    }
  }, [isControlled, prop, setUncontrolledProp, onChangeRef]);
  return [value, setValue];
}
function useUncontrolledState3({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React202.useState(defaultProp);
  const prevValueRef = React202.useRef(value);
  const onChangeRef = React202.useRef(onChange);
  useInsertionEffect3(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React202.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction3(value) {
  return typeof value === "function";
}
var SYNC_STATE3 = Symbol("RADIX:SYNC_STATE");
function usePrevious(value) {
  const ref = React215.useRef({ value, previous: value });
  return React215.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME22 = "VisuallyHidden";
var VisuallyHidden = React242.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsx132(Primitive3.span, {
    ...props,
    ref: forwardedRef,
    style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
  });
});
VisuallyHidden.displayName = NAME22;
var Root33 = VisuallyHidden;
var getDefaultParent3 = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap3 = new WeakMap;
var uncontrolledNodes3 = new WeakMap;
var markerMap3 = {};
var lockCount3 = 0;
var unwrapHost3 = function(node) {
  return node && (node.host || unwrapHost3(node.parentNode));
};
var correctTargets3 = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost3(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers3 = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets3(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap3[markerName]) {
    markerMap3[markerName] = new WeakMap;
  }
  var markerCounter = markerMap3[markerName];
  var hiddenNodes = [];
  var elementsToKeep = new Set;
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap3.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap3.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes3.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount3++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap3.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap3.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes3.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes3.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount3--;
    if (!lockCount3) {
      counterMap3 = new WeakMap;
      counterMap3 = new WeakMap;
      uncontrolledNodes3 = new WeakMap;
      markerMap3 = {};
    }
  };
};
var hideOthers3 = function(originalTarget, parentNode, markerName) {
  if (markerName === undefined) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent3(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers3(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign3 = function() {
  __assign3 = Object.assign || function __assign(t3) {
    for (var s, i = 1, n = arguments.length;i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign3.apply(this, arguments);
};
function __rest3(s, e) {
  var t3 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t3[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s);i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t3[p2[i]] = s[p2[i]];
    }
  return t3;
}
function __spreadArray3(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar;i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var zeroRightClassName3 = "right-scroll-bar-position";
var fullWidthClassName3 = "width-before-scroll-bar";
var noScrollbarsClassName3 = "with-scroll-bars-hidden";
var removedBarSizeVariable3 = "--removed-body-scroll-bar-size";
function assignRef3(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef22(initialValue, callback) {
  var ref = useState92(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect4 = typeof window !== "undefined" ? React262.useLayoutEffect : React262.useEffect;
var currentValues3 = new WeakMap;
function useMergeRefs3(refs, defaultValue) {
  var callbackRef = useCallbackRef22(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef3(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect4(function() {
    var oldValue = currentValues3.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef3(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef3(ref, current_1);
        }
      });
    }
    currentValues3.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI3(a) {
  return a;
}
function innerCreateMedium3(defaults, middleware) {
  if (middleware === undefined) {
    middleware = ItoI3;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium3(options3) {
  if (options3 === undefined) {
    options3 = {};
  }
  var medium = innerCreateMedium3(null);
  medium.options = __assign3({ async: true, ssr: false }, options3);
  return medium;
}
var SideCar3 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest3(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React272.createElement(Target, __assign3({}, rest));
};
SideCar3.isSideCarExport = true;
function exportSidecar3(medium, exported) {
  medium.useMedium(exported);
  return SideCar3;
}
var effectCar3 = createSidecarMedium3();
var nothing3 = function() {
  return;
};
var RemoveScroll3 = React282.forwardRef(function(props, parentRef) {
  var ref = React282.useRef(null);
  var _a = React282.useState({
    onScrollCapture: nothing3,
    onWheelCapture: nothing3,
    onTouchMoveCapture: nothing3
  }), callbacks = _a[0], setCallbacks = _a[1];
  var { forwardProps, children, className, removeScrollBar, enabled, shards, sideCar, noRelative, noIsolation, inert, allowPinchZoom, as: _b } = props, Container = _b === undefined ? "div" : _b, gapMode = props.gapMode, rest = __rest3(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar22 = sideCar;
  var containerRef = useMergeRefs3([ref, parentRef]);
  var containerProps = __assign3(__assign3({}, rest), callbacks);
  return React282.createElement(React282.Fragment, null, enabled && React282.createElement(SideCar22, { sideCar: effectCar3, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }), forwardProps ? React282.cloneElement(React282.Children.only(children), __assign3(__assign3({}, containerProps), { ref: containerRef })) : React282.createElement(Container, __assign3({}, containerProps, { className, ref: containerRef }), children));
});
RemoveScroll3.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll3.classNames = {
  fullWidth: fullWidthClassName3,
  zeroRight: zeroRightClassName3
};
var currentNonce3;
var getNonce3 = function() {
  if (currentNonce3) {
    return currentNonce3;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return;
};
function makeStyleTag3() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce3();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles3(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag3(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton3 = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag3()) {
          injectStyles3(stylesheet, style);
          insertStyleTag3(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton3 = function() {
  var sheet = stylesheetSingleton3();
  return function(styles, isDynamic) {
    React292.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton3 = function() {
  var useStyle = styleHookSingleton3();
  var Sheet = function(_a) {
    var { styles, dynamic } = _a;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap3 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse3 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset3 = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse3(left), parse3(top), parse3(right)];
};
var getGapWidth3 = function(gapMode) {
  if (gapMode === undefined) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap3;
  }
  var offsets = getOffset3(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style3 = styleSingleton3();
var lockAttribute3 = "data-scroll-locked";
var getStyles3 = function(_a, allowRelative, gapMode, important) {
  var { left, top, right, gap } = _a;
  if (gapMode === undefined) {
    gapMode = "margin";
  }
  return `
  .`.concat(noScrollbarsClassName3, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute3, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && `
    padding-left: `.concat(left, `px;
    padding-top: `).concat(top, `px;
    padding-right: `).concat(right, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName3, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName3, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName3, " .").concat(zeroRightClassName3, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName3, " .").concat(fullWidthClassName3, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute3, `] {
    `).concat(removedBarSizeVariable3, ": ").concat(gap, `px;
  }
`);
};
var getCurrentUseCounter3 = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute3) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute3 = function() {
  React302.useEffect(function() {
    document.body.setAttribute(lockAttribute3, (getCurrentUseCounter3() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter3() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute3);
      } else {
        document.body.setAttribute(lockAttribute3, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar3 = function(_a) {
  var { noRelative, noImportant, gapMode: _b } = _a, gapMode = _b === undefined ? "margin" : _b;
  useLockAttribute3();
  var gap = React302.useMemo(function() {
    return getGapWidth3(gapMode);
  }, [gapMode]);
  return React302.createElement(Style3, { styles: getStyles3(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported3 = false;
if (typeof window !== "undefined") {
  try {
    options3 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported3 = true;
        return true;
      }
    });
    window.addEventListener("test", options3, options3);
    window.removeEventListener("test", options3, options3);
  } catch (err) {
    passiveSupported3 = false;
  }
}
var options3;
var nonPassive3 = passiveSupported3 ? { passive: false } : false;
var alwaysContainsScroll3 = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled3 = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll3(node) && styles[overflow] === "visible");
};
var elementCouldBeVScrolled3 = function(node) {
  return elementCanBeScrolled3(node, "overflowY");
};
var elementCouldBeHScrolled3 = function(node) {
  return elementCanBeScrolled3(node, "overflowX");
};
var locationCouldBeScrolled3 = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled3(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables3(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables3 = function(_a) {
  var { scrollTop, scrollHeight, clientHeight } = _a;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables3 = function(_a) {
  var { scrollLeft, scrollWidth, clientWidth } = _a;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled3 = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled3(node) : elementCouldBeHScrolled3(node);
};
var getScrollVariables3 = function(axis, node) {
  return axis === "v" ? getVScrollVariables3(node) : getHScrollVariables3(node);
};
var getDirectionFactor3 = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll3 = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor3(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a = getScrollVariables3(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled3(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY3 = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY3 = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef3 = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare3 = function(x2, y) {
  return x2[0] === y[0] && x2[1] === y[1];
};
var generateStyle3 = function(id) {
  return `
  .block-interactivity-`.concat(id, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id, ` {pointer-events: all;}
`);
};
var idCounter3 = 0;
var lockStack3 = [];
function RemoveScrollSideCar3(props) {
  var shouldPreventQueue = React312.useRef([]);
  var touchStartRef = React312.useRef([0, 0]);
  var activeAxis = React312.useRef();
  var id = React312.useState(idCounter3++)[0];
  var Style22 = React312.useState(styleSingleton3)[0];
  var lastProps = React312.useRef(props);
  React312.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React312.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray3([props.lockRef.current], (props.shards || []).map(extractRef3), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React312.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY3(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled3(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled3(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll3(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React312.useCallback(function(_event) {
    var event = _event;
    if (!lockStack3.length || lockStack3[lockStack3.length - 1] !== Style22) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY3(event) : getTouchXY3(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare3(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef3).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React312.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent3(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React312.useCallback(function(event) {
    touchStartRef.current = getTouchXY3(event);
    activeAxis.current = undefined;
  }, []);
  var scrollWheel = React312.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY3(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React312.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY3(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React312.useEffect(function() {
    lockStack3.push(Style22);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive3);
    document.addEventListener("touchmove", shouldPrevent, nonPassive3);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive3);
    return function() {
      lockStack3 = lockStack3.filter(function(inst) {
        return inst !== Style22;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive3);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive3);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive3);
    };
  }, []);
  var { removeScrollBar, inert } = props;
  return React312.createElement(React312.Fragment, null, inert ? React312.createElement(Style22, { styles: generateStyle3(id) }) : null, removeScrollBar ? React312.createElement(RemoveScrollBar3, { noRelative: props.noRelative, gapMode: props.gapMode }) : null);
}
function getOutermostShadowParent3(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
var sidecar_default3 = exportSidecar3(effectCar3, RemoveScrollSideCar3);
var ReactRemoveScroll3 = React323.forwardRef(function(props, ref) {
  return React323.createElement(RemoveScroll3, __assign3({}, props, { ref, sideCar: sidecar_default3 }));
});
ReactRemoveScroll3.classNames = RemoveScroll3.classNames;
var Combination_default3 = ReactRemoveScroll3;
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS2 = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection7, useCollection7, createCollectionScope7] = createCollection3(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope3(SELECT_NAME, [
  createCollectionScope7,
  createPopperScope2
]);
var usePopperScope2 = createPopperScope2();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope2(__scopeSelect);
  const [trigger, setTrigger] = React332.useState(null);
  const [valueNode, setValueNode] = React332.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React332.useState(false);
  const direction = useDirection3(dir);
  const [open, setOpen] = useControllableState3({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SELECT_NAME
  });
  const [value, setValue] = useControllableState3({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange,
    caller: SELECT_NAME
  });
  const triggerPointerDownPosRef = React332.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React332.useState(/* @__PURE__ */ new Set);
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsx142(Root22, { ...popperScope, children: /* @__PURE__ */ jsxs22(SelectProvider, {
    required,
    scope: __scopeSelect,
    trigger,
    onTriggerChange: setTrigger,
    valueNode,
    onValueNodeChange: setValueNode,
    valueNodeHasChildren,
    onValueNodeHasChildrenChange: setValueNodeHasChildren,
    contentId: useId3(),
    value,
    onValueChange: setValue,
    open,
    onOpenChange: setOpen,
    dir: direction,
    triggerPointerDownPosRef,
    disabled,
    children: [
      /* @__PURE__ */ jsx142(Collection7.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsx142(SelectNativeOptionsProvider, {
        scope: props.__scopeSelect,
        onNativeOptionAdd: React332.useCallback((option) => {
          setNativeOptionsSet((prev) => new Set(prev).add(option));
        }, []),
        onNativeOptionRemove: React332.useCallback((option) => {
          setNativeOptionsSet((prev) => {
            const optionsSet = new Set(prev);
            optionsSet.delete(option);
            return optionsSet;
          });
        }, []),
        children
      }) }),
      isFormControl ? /* @__PURE__ */ jsxs22(SelectBubbleInput, {
        "aria-hidden": true,
        required,
        tabIndex: -1,
        name,
        autoComplete,
        value,
        onChange: (event) => setValue(event.target.value),
        disabled,
        form,
        children: [
          value === undefined ? /* @__PURE__ */ jsx142("option", { value: "" }) : null,
          Array.from(nativeOptionsSet)
        ]
      }, nativeSelectKey) : null
    ]
  }) });
};
Select.displayName = SELECT_NAME;
var TRIGGER_NAME5 = "SelectTrigger";
var SelectTrigger = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, disabled = false, ...triggerProps } = props;
  const popperScope = usePopperScope2(__scopeSelect);
  const context = useSelectContext(TRIGGER_NAME5, __scopeSelect);
  const isDisabled = context.disabled || disabled;
  const composedRefs = useComposedRefs3(forwardedRef, context.onTriggerChange);
  const getItems = useCollection7(__scopeSelect);
  const pointerTypeRef = React332.useRef("touch");
  const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
    const enabledItems = getItems().filter((item) => !item.disabled);
    const currentItem = enabledItems.find((item) => item.value === context.value);
    const nextItem = findNextItem(enabledItems, search, currentItem);
    if (nextItem !== undefined) {
      context.onValueChange(nextItem.value);
    }
  });
  const handleOpen = (pointerEvent) => {
    if (!isDisabled) {
      context.onOpenChange(true);
      resetTypeahead();
    }
    if (pointerEvent) {
      context.triggerPointerDownPosRef.current = {
        x: Math.round(pointerEvent.pageX),
        y: Math.round(pointerEvent.pageY)
      };
    }
  };
  return /* @__PURE__ */ jsx142(Anchor3, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsx142(Primitive3.button, {
    type: "button",
    role: "combobox",
    "aria-controls": context.contentId,
    "aria-expanded": context.open,
    "aria-required": context.required,
    "aria-autocomplete": "none",
    dir: context.dir,
    "data-state": context.open ? "open" : "closed",
    disabled: isDisabled,
    "data-disabled": isDisabled ? "" : undefined,
    "data-placeholder": shouldShowPlaceholder(context.value) ? "" : undefined,
    ...triggerProps,
    ref: composedRefs,
    onClick: composeEventHandlers3(triggerProps.onClick, (event) => {
      event.currentTarget.focus();
      if (pointerTypeRef.current !== "mouse") {
        handleOpen(event);
      }
    }),
    onPointerDown: composeEventHandlers3(triggerProps.onPointerDown, (event) => {
      pointerTypeRef.current = event.pointerType;
      const target = event.target;
      if (target.hasPointerCapture(event.pointerId)) {
        target.releasePointerCapture(event.pointerId);
      }
      if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
        handleOpen(event);
        event.preventDefault();
      }
    }),
    onKeyDown: composeEventHandlers3(triggerProps.onKeyDown, (event) => {
      const isTypingAhead = searchRef.current !== "";
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      if (!isModifierKey && event.key.length === 1)
        handleTypeaheadSearch(event.key);
      if (isTypingAhead && event.key === " ")
        return;
      if (OPEN_KEYS.includes(event.key)) {
        handleOpen();
        event.preventDefault();
      }
    })
  }) });
});
SelectTrigger.displayName = TRIGGER_NAME5;
var VALUE_NAME = "SelectValue";
var SelectValue = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
  const context = useSelectContext(VALUE_NAME, __scopeSelect);
  const { onValueNodeHasChildrenChange } = context;
  const hasChildren = children !== undefined;
  const composedRefs = useComposedRefs3(forwardedRef, context.onValueNodeChange);
  useLayoutEffect24(() => {
    onValueNodeHasChildrenChange(hasChildren);
  }, [onValueNodeHasChildrenChange, hasChildren]);
  return /* @__PURE__ */ jsx142(Primitive3.span, {
    ...valueProps,
    ref: composedRefs,
    style: { pointerEvents: "none" },
    children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsx142(Fragment62, { children: placeholder }) : children
  });
});
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, children, ...iconProps } = props;
  return /* @__PURE__ */ jsx142(Primitive3.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "" });
});
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME22 = "SelectPortal";
var SelectPortal = (props) => {
  return /* @__PURE__ */ jsx142(Portal6, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME22;
var CONTENT_NAME22 = "SelectContent";
var SelectContent = React332.forwardRef((props, forwardedRef) => {
  const context = useSelectContext(CONTENT_NAME22, props.__scopeSelect);
  const [fragment, setFragment] = React332.useState();
  useLayoutEffect24(() => {
    setFragment(new DocumentFragment);
  }, []);
  if (!context.open) {
    const frag = fragment;
    return frag ? ReactDOM4.createPortal(/* @__PURE__ */ jsx142(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsx142(Collection7.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsx142("div", { children: props.children }) }) }), frag) : null;
  }
  return /* @__PURE__ */ jsx142(SelectContentImpl, { ...props, ref: forwardedRef });
});
SelectContent.displayName = CONTENT_NAME22;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME22);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var Slot22 = createSlot3("SelectContent.RemoveScroll");
var SelectContentImpl = React332.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    position = "item-aligned",
    onCloseAutoFocus,
    onEscapeKeyDown,
    onPointerDownOutside,
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    hideWhenDetached,
    avoidCollisions,
    ...contentProps
  } = props;
  const context = useSelectContext(CONTENT_NAME22, __scopeSelect);
  const [content, setContent] = React332.useState(null);
  const [viewport, setViewport] = React332.useState(null);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setContent(node));
  const [selectedItem, setSelectedItem] = React332.useState(null);
  const [selectedItemText, setSelectedItemText] = React332.useState(null);
  const getItems = useCollection7(__scopeSelect);
  const [isPositioned, setIsPositioned] = React332.useState(false);
  const firstValidItemFoundRef = React332.useRef(false);
  React332.useEffect(() => {
    if (content)
      return hideOthers3(content);
  }, [content]);
  useFocusGuards3();
  const focusFirst22 = React332.useCallback((candidates) => {
    const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
    const [lastItem] = restItems.slice(-1);
    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
    for (const candidate of candidates) {
      if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
        return;
      candidate?.scrollIntoView({ block: "nearest" });
      if (candidate === firstItem && viewport)
        viewport.scrollTop = 0;
      if (candidate === lastItem && viewport)
        viewport.scrollTop = viewport.scrollHeight;
      candidate?.focus();
      if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
        return;
    }
  }, [getItems, viewport]);
  const focusSelectedItem = React332.useCallback(() => focusFirst22([selectedItem, content]), [focusFirst22, selectedItem, content]);
  React332.useEffect(() => {
    if (isPositioned) {
      focusSelectedItem();
    }
  }, [isPositioned, focusSelectedItem]);
  const { onOpenChange, triggerPointerDownPosRef } = context;
  React332.useEffect(() => {
    if (content) {
      let pointerMoveDelta = { x: 0, y: 0 };
      const handlePointerMove = (event) => {
        pointerMoveDelta = {
          x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),
          y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0))
        };
      };
      const handlePointerUp = (event) => {
        if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
          event.preventDefault();
        } else {
          if (!content.contains(event.target)) {
            onOpenChange(false);
          }
        }
        document.removeEventListener("pointermove", handlePointerMove);
        triggerPointerDownPosRef.current = null;
      };
      if (triggerPointerDownPosRef.current !== null) {
        document.addEventListener("pointermove", handlePointerMove);
        document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
      }
      return () => {
        document.removeEventListener("pointermove", handlePointerMove);
        document.removeEventListener("pointerup", handlePointerUp, { capture: true });
      };
    }
  }, [content, onOpenChange, triggerPointerDownPosRef]);
  React332.useEffect(() => {
    const close = () => onOpenChange(false);
    window.addEventListener("blur", close);
    window.addEventListener("resize", close);
    return () => {
      window.removeEventListener("blur", close);
      window.removeEventListener("resize", close);
    };
  }, [onOpenChange]);
  const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
    const enabledItems = getItems().filter((item) => !item.disabled);
    const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
    const nextItem = findNextItem(enabledItems, search, currentItem);
    if (nextItem) {
      setTimeout(() => nextItem.ref.current.focus());
    }
  });
  const itemRefCallback = React332.useCallback((node, value, disabled) => {
    const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
    const isSelectedItem = context.value !== undefined && context.value === value;
    if (isSelectedItem || isFirstValidItem) {
      setSelectedItem(node);
      if (isFirstValidItem)
        firstValidItemFoundRef.current = true;
    }
  }, [context.value]);
  const handleItemLeave = React332.useCallback(() => content?.focus(), [content]);
  const itemTextRefCallback = React332.useCallback((node, value, disabled) => {
    const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
    const isSelectedItem = context.value !== undefined && context.value === value;
    if (isSelectedItem || isFirstValidItem) {
      setSelectedItemText(node);
    }
  }, [context.value]);
  const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
  const popperContentProps = SelectPosition === SelectPopperPosition ? {
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    hideWhenDetached,
    avoidCollisions
  } : {};
  return /* @__PURE__ */ jsx142(SelectContentProvider, {
    scope: __scopeSelect,
    content,
    viewport,
    onViewportChange: setViewport,
    itemRefCallback,
    selectedItem,
    onItemLeave: handleItemLeave,
    itemTextRefCallback,
    focusSelectedItem,
    selectedItemText,
    position,
    isPositioned,
    searchRef,
    children: /* @__PURE__ */ jsx142(Combination_default3, { as: Slot22, allowPinchZoom: true, children: /* @__PURE__ */ jsx142(FocusScope3, {
      asChild: true,
      trapped: context.open,
      onMountAutoFocus: (event) => {
        event.preventDefault();
      },
      onUnmountAutoFocus: composeEventHandlers3(onCloseAutoFocus, (event) => {
        context.trigger?.focus({ preventScroll: true });
        event.preventDefault();
      }),
      children: /* @__PURE__ */ jsx142(DismissableLayer3, {
        asChild: true,
        disableOutsidePointerEvents: true,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: () => context.onOpenChange(false),
        children: /* @__PURE__ */ jsx142(SelectPosition, {
          role: "listbox",
          id: context.contentId,
          "data-state": context.open ? "open" : "closed",
          dir: context.dir,
          onContextMenu: (event) => event.preventDefault(),
          ...contentProps,
          ...popperContentProps,
          onPlaced: () => setIsPositioned(true),
          ref: composedRefs,
          style: {
            display: "flex",
            flexDirection: "column",
            outline: "none",
            ...contentProps.style
          },
          onKeyDown: composeEventHandlers3(contentProps.onKeyDown, (event) => {
            const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
            if (event.key === "Tab")
              event.preventDefault();
            if (!isModifierKey && event.key.length === 1)
              handleTypeaheadSearch(event.key);
            if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
              const items = getItems().filter((item) => !item.disabled);
              let candidateNodes = items.map((item) => item.ref.current);
              if (["ArrowUp", "End"].includes(event.key)) {
                candidateNodes = candidateNodes.slice().reverse();
              }
              if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                const currentElement = event.target;
                const currentIndex = candidateNodes.indexOf(currentElement);
                candidateNodes = candidateNodes.slice(currentIndex + 1);
              }
              setTimeout(() => focusFirst22(candidateNodes));
              event.preventDefault();
            }
          })
        })
      })
    }) })
  });
});
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME22, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME22, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React332.useState(null);
  const [content, setContent] = React332.useState(null);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setContent(node));
  const getItems = useCollection7(__scopeSelect);
  const shouldExpandOnScrollRef = React332.useRef(false);
  const shouldRepositionRef = React332.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React332.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp3(left, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp3(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(triggerMiddleToBottomEdge, selectedItemHalfHeight + (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth);
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(topEdgeToTriggerMiddle, contentBorderTopWidth + viewport.offsetTop + (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight);
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced?.();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect24(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React332.useState();
  useLayoutEffect24(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React332.useCallback((node) => {
    if (node && shouldRepositionRef.current === true) {
      position();
      focusSelectedItem?.();
      shouldRepositionRef.current = false;
    }
  }, [position, focusSelectedItem]);
  return /* @__PURE__ */ jsx142(SelectViewportProvider, {
    scope: __scopeSelect,
    contentWrapper,
    shouldExpandOnScrollRef,
    onScrollButtonChange: handleScrollButtonChange,
    children: /* @__PURE__ */ jsx142("div", {
      ref: setContentWrapper,
      style: {
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: contentZIndex
      },
      children: /* @__PURE__ */ jsx142(Primitive3.div, {
        ...popperProps,
        ref: composedRefs,
        style: {
          boxSizing: "border-box",
          maxHeight: "100%",
          ...popperProps.style
        }
      })
    })
  });
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React332.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope2(__scopeSelect);
  return /* @__PURE__ */ jsx142(Content5, {
    ...popperScope,
    ...popperProps,
    ref: forwardedRef,
    align,
    collisionPadding,
    style: {
      boxSizing: "border-box",
      ...popperProps.style,
      ...{
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME22, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, nonce, ...viewportProps } = props;
  const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
  const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
  const composedRefs = useComposedRefs3(forwardedRef, contentContext.onViewportChange);
  const prevScrollTopRef = React332.useRef(0);
  return /* @__PURE__ */ jsxs22(Fragment62, { children: [
    /* @__PURE__ */ jsx142("style", {
      dangerouslySetInnerHTML: {
        __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
      },
      nonce
    }),
    /* @__PURE__ */ jsx142(Collection7.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsx142(Primitive3.div, {
      "data-radix-select-viewport": "",
      role: "presentation",
      ...viewportProps,
      ref: composedRefs,
      style: {
        position: "relative",
        flex: 1,
        overflow: "hidden auto",
        ...viewportProps.style
      },
      onScroll: composeEventHandlers3(viewportProps.onScroll, (event) => {
        const viewport = event.currentTarget;
        const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
        if (shouldExpandOnScrollRef?.current && contentWrapper) {
          const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
          if (scrolledBy > 0) {
            const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
            const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
            const cssHeight = parseFloat(contentWrapper.style.height);
            const prevHeight = Math.max(cssMinHeight, cssHeight);
            if (prevHeight < availableHeight) {
              const nextHeight = prevHeight + scrolledBy;
              const clampedNextHeight = Math.min(availableHeight, nextHeight);
              const heightDiff = nextHeight - clampedNextHeight;
              contentWrapper.style.height = clampedNextHeight + "px";
              if (contentWrapper.style.bottom === "0px") {
                viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                contentWrapper.style.justifyContent = "flex-end";
              }
            }
          }
        }
        prevScrollTopRef.current = viewport.scrollTop;
      })
    }) })
  ] });
});
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME6 = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME6);
var SelectGroup = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, ...groupProps } = props;
  const groupId = useId3();
  return /* @__PURE__ */ jsx142(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsx142(Primitive3.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
});
SelectGroup.displayName = GROUP_NAME6;
var LABEL_NAME3 = "SelectLabel";
var SelectLabel = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, ...labelProps } = props;
  const groupContext = useSelectGroupContext(LABEL_NAME3, __scopeSelect);
  return /* @__PURE__ */ jsx142(Primitive3.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
});
SelectLabel.displayName = LABEL_NAME3;
var ITEM_NAME6 = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME6);
var SelectItem = React332.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    value,
    disabled = false,
    textValue: textValueProp,
    ...itemProps
  } = props;
  const context = useSelectContext(ITEM_NAME6, __scopeSelect);
  const contentContext = useSelectContentContext(ITEM_NAME6, __scopeSelect);
  const isSelected = context.value === value;
  const [textValue, setTextValue] = React332.useState(textValueProp ?? "");
  const [isFocused, setIsFocused] = React332.useState(false);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => contentContext.itemRefCallback?.(node, value, disabled));
  const textId = useId3();
  const pointerTypeRef = React332.useRef("touch");
  const handleSelect = () => {
    if (!disabled) {
      context.onValueChange(value);
      context.onOpenChange(false);
    }
  };
  if (value === "") {
    throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
  }
  return /* @__PURE__ */ jsx142(SelectItemContextProvider, {
    scope: __scopeSelect,
    value,
    disabled,
    textId,
    isSelected,
    onItemTextChange: React332.useCallback((node) => {
      setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? "").trim());
    }, []),
    children: /* @__PURE__ */ jsx142(Collection7.ItemSlot, {
      scope: __scopeSelect,
      value,
      disabled,
      textValue,
      children: /* @__PURE__ */ jsx142(Primitive3.div, {
        role: "option",
        "aria-labelledby": textId,
        "data-highlighted": isFocused ? "" : undefined,
        "aria-selected": isSelected && isFocused,
        "data-state": isSelected ? "checked" : "unchecked",
        "aria-disabled": disabled || undefined,
        "data-disabled": disabled ? "" : undefined,
        tabIndex: disabled ? undefined : -1,
        ...itemProps,
        ref: composedRefs,
        onFocus: composeEventHandlers3(itemProps.onFocus, () => setIsFocused(true)),
        onBlur: composeEventHandlers3(itemProps.onBlur, () => setIsFocused(false)),
        onClick: composeEventHandlers3(itemProps.onClick, () => {
          if (pointerTypeRef.current !== "mouse")
            handleSelect();
        }),
        onPointerUp: composeEventHandlers3(itemProps.onPointerUp, () => {
          if (pointerTypeRef.current === "mouse")
            handleSelect();
        }),
        onPointerDown: composeEventHandlers3(itemProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
        }),
        onPointerMove: composeEventHandlers3(itemProps.onPointerMove, (event) => {
          pointerTypeRef.current = event.pointerType;
          if (disabled) {
            contentContext.onItemLeave?.();
          } else if (pointerTypeRef.current === "mouse") {
            event.currentTarget.focus({ preventScroll: true });
          }
        }),
        onPointerLeave: composeEventHandlers3(itemProps.onPointerLeave, (event) => {
          if (event.currentTarget === document.activeElement) {
            contentContext.onItemLeave?.();
          }
        }),
        onKeyDown: composeEventHandlers3(itemProps.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef?.current !== "";
          if (isTypingAhead && event.key === " ")
            return;
          if (SELECTION_KEYS2.includes(event.key))
            handleSelect();
          if (event.key === " ")
            event.preventDefault();
        })
      })
    })
  });
});
SelectItem.displayName = ITEM_NAME6;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, className, style, ...itemTextProps } = props;
  const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
  const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
  const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
  const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
  const [itemTextNode, setItemTextNode] = React332.useState(null);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setItemTextNode(node), itemContext.onItemTextChange, (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled));
  const textContent = itemTextNode?.textContent;
  const nativeOption = React332.useMemo(() => /* @__PURE__ */ jsx142("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value), [itemContext.disabled, itemContext.value, textContent]);
  const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
  useLayoutEffect24(() => {
    onNativeOptionAdd(nativeOption);
    return () => onNativeOptionRemove(nativeOption);
  }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
  return /* @__PURE__ */ jsxs22(Fragment62, { children: [
    /* @__PURE__ */ jsx142(Primitive3.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
    itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM4.createPortal(itemTextProps.children, context.valueNode) : null
  ] });
});
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME2 = "SelectItemIndicator";
var SelectItemIndicator = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, ...itemIndicatorProps } = props;
  const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME2, __scopeSelect);
  return itemContext.isSelected ? /* @__PURE__ */ jsx142(Primitive3.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
});
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME2;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = React332.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React332.useState(false);
  const composedRefs = useComposedRefs3(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect24(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll222 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      var handleScroll22 = handleScroll222;
      const viewport = contentContext.viewport;
      handleScroll222();
      viewport.addEventListener("scroll", handleScroll222);
      return () => viewport.removeEventListener("scroll", handleScroll222);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsx142(SelectScrollButtonImpl, {
    ...props,
    ref: composedRefs,
    onAutoScroll: () => {
      const { viewport, selectedItem } = contentContext;
      if (viewport && selectedItem) {
        viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
      }
    }
  }) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = React332.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React332.useState(false);
  const composedRefs = useComposedRefs3(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect24(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll222 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      var handleScroll22 = handleScroll222;
      const viewport = contentContext.viewport;
      handleScroll222();
      viewport.addEventListener("scroll", handleScroll222);
      return () => viewport.removeEventListener("scroll", handleScroll222);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsx142(SelectScrollButtonImpl, {
    ...props,
    ref: composedRefs,
    onAutoScroll: () => {
      const { viewport, selectedItem } = contentContext;
      if (viewport && selectedItem) {
        viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
      }
    }
  }) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React332.useRef(null);
  const getItems = useCollection7(__scopeSelect);
  const clearAutoScrollTimer = React332.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React332.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect24(() => {
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    activeItem?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsx142(Primitive3.div, {
    "aria-hidden": true,
    ...scrollIndicatorProps,
    ref: forwardedRef,
    style: { flexShrink: 0, ...scrollIndicatorProps.style },
    onPointerDown: composeEventHandlers3(scrollIndicatorProps.onPointerDown, () => {
      if (autoScrollTimerRef.current === null) {
        autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
      }
    }),
    onPointerMove: composeEventHandlers3(scrollIndicatorProps.onPointerMove, () => {
      contentContext.onItemLeave?.();
      if (autoScrollTimerRef.current === null) {
        autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
      }
    }),
    onPointerLeave: composeEventHandlers3(scrollIndicatorProps.onPointerLeave, () => {
      clearAutoScrollTimer();
    })
  });
});
var SEPARATOR_NAME3 = "SelectSeparator";
var SelectSeparator = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, ...separatorProps } = props;
  return /* @__PURE__ */ jsx142(Primitive3.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
});
SelectSeparator.displayName = SEPARATOR_NAME3;
var ARROW_NAME22 = "SelectArrow";
var SelectArrow = React332.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, ...arrowProps } = props;
  const popperScope = usePopperScope2(__scopeSelect);
  const context = useSelectContext(ARROW_NAME22, __scopeSelect);
  const contentContext = useSelectContentContext(ARROW_NAME22, __scopeSelect);
  return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsx142(Arrow23, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
});
SelectArrow.displayName = ARROW_NAME22;
var BUBBLE_INPUT_NAME = "SelectBubbleInput";
var SelectBubbleInput = React332.forwardRef(({ __scopeSelect, value, ...props }, forwardedRef) => {
  const ref = React332.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  const prevValue = usePrevious(value);
  React332.useEffect(() => {
    const select = ref.current;
    if (!select)
      return;
    const selectProto = window.HTMLSelectElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(selectProto, "value");
    const setValue = descriptor.set;
    if (prevValue !== value && setValue) {
      const event = new Event("change", { bubbles: true });
      setValue.call(select, value);
      select.dispatchEvent(event);
    }
  }, [prevValue, value]);
  return /* @__PURE__ */ jsx142(Primitive3.select, {
    ...props,
    style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
    ref: composedRefs,
    defaultValue: value
  });
});
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME;
function shouldShowPlaceholder(value) {
  return value === "" || value === undefined;
}
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef6(onSearchChange);
  const searchRef = React332.useRef("");
  const timerRef = React332.useRef(0);
  const handleTypeaheadSearch = React332.useCallback((key) => {
    const search = searchRef.current + key;
    handleSearchChange(search);
    (function updateSearch(value) {
      searchRef.current = value;
      window.clearTimeout(timerRef.current);
      if (value !== "")
        timerRef.current = window.setTimeout(() => updateSearch(""), 1000);
    })(search);
  }, [handleSearchChange]);
  const resetTypeahead = React332.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React332.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray6(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem)
    wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find((item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase()));
  return nextItem !== currentItem ? nextItem : undefined;
}
function wrapArray6(array, startIndex) {
  return array.map((_2, index22) => array[(startIndex + index22) % array.length]);
}
var Root222 = Select;
var Trigger = SelectTrigger;
var Value = SelectValue;
var Icon = SelectIcon;
var Portal22 = SelectPortal;
var Content22 = SelectContent;
var Viewport = SelectViewport;
var Group2 = SelectGroup;
var Label2 = SelectLabel;
var Item5 = SelectItem;
var ItemText = SelectItemText;
var ItemIndicator2 = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton;
var ScrollDownButton = SelectScrollDownButton;
var Separator2 = SelectSeparator;
function Select2({ ...props }) {
  return /* @__PURE__ */ jsx152(Root222, {
    "data-slot": "select",
    ...props
  });
}
function SelectGroup2({ ...props }) {
  return /* @__PURE__ */ jsx152(Group2, {
    "data-slot": "select-group",
    ...props
  });
}
function SelectValue2({ ...props }) {
  return /* @__PURE__ */ jsx152(Value, {
    "data-slot": "select-value",
    ...props
  });
}
function SelectTrigger2({
  className,
  size: size42 = "default",
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxs32(Trigger, {
    "data-slot": "select-trigger",
    "data-size": size42,
    className: clsx33("flex w-fit items-center justify-between gap-2 whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-xs outline-none transition-[color,box-shadow] focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:cursor-not-allowed disabled:opacity-50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 data-[size=default]:h-9 data-[size=sm]:h-8 data-[placeholder]:text-muted-foreground *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 dark:bg-input/30 dark:aria-invalid:ring-destructive/40 dark:hover:bg-input/50 [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsx152(Icon, {
        asChild: true,
        children: /* @__PURE__ */ jsx152(SvgIcon4, {
          iconId: "ChevronDown",
          className: "size-4 opacity-50"
        })
      })
    ]
  });
}
function SelectContent2({ className, children, position = "popper", align = "center", ...props }) {
  return /* @__PURE__ */ jsx152(Portal22, {
    children: /* @__PURE__ */ jsxs32(Content22, {
      "data-slot": "select-content",
      className: clsx33("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=closed]:animate-out data-[state=open]:animate-in", position === "popper" && "data-[side=left]:-translate-x-1 data-[side=top]:-translate-y-1 data-[side=right]:translate-x-1 data-[side=bottom]:translate-y-1", className),
      position,
      align,
      ...props,
      children: [
        /* @__PURE__ */ jsx152(SelectScrollUpButton2, {}),
        /* @__PURE__ */ jsx152(Viewport, {
          className: clsx33("p-1", position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"),
          children
        }),
        /* @__PURE__ */ jsx152(SelectScrollDownButton2, {})
      ]
    })
  });
}
function SelectLabel2({ className, ...props }) {
  return /* @__PURE__ */ jsx152(Label2, {
    "data-slot": "select-label",
    className: clsx33("px-2 py-1.5 text-muted-foreground text-xs", className),
    ...props
  });
}
function SelectItem2({ className, children, ...props }) {
  return /* @__PURE__ */ jsxs32(Item5, {
    "data-slot": "select-item",
    className: clsx33("relative flex w-full cursor-default select-none items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", className),
    ...props,
    children: [
      /* @__PURE__ */ jsx152("span", {
        className: "absolute right-2 flex size-3.5 items-center justify-center",
        children: /* @__PURE__ */ jsx152(ItemIndicator2, {
          children: /* @__PURE__ */ jsx152(SvgIcon4, {
            iconId: "Check",
            className: "size-4"
          })
        })
      }),
      /* @__PURE__ */ jsx152(ItemText, {
        children
      })
    ]
  });
}
function SelectSeparator2({ className, ...props }) {
  return /* @__PURE__ */ jsx152(Separator2, {
    "data-slot": "select-separator",
    className: clsx33("-mx-1 pointer-events-none my-1 h-px bg-border", className),
    ...props
  });
}
function SelectScrollUpButton2({ className, ...props }) {
  return /* @__PURE__ */ jsx152(ScrollUpButton, {
    "data-slot": "select-scroll-up-button",
    className: clsx33("flex cursor-default items-center justify-center py-1", className),
    ...props,
    children: /* @__PURE__ */ jsx152(SvgIcon4, {
      iconId: "ChevronUp",
      className: "size-4"
    })
  });
}
function SelectScrollDownButton2({ className, ...props }) {
  return /* @__PURE__ */ jsx152(ScrollDownButton, {
    "data-slot": "select-scroll-down-button",
    className: clsx33("flex cursor-default items-center justify-center py-1", className),
    ...props,
    children: /* @__PURE__ */ jsx152(SvgIcon4, {
      iconId: "ChevronDown",
      className: "size-4"
    })
  });
}
function DataPagination({ currentRecords, pagination, totalRecords, baseRoute, routeParams = {}, perPageOptions = [25, 50, 100, 200], fetcher, isLoading = false, loadingIcon = true }) {
  const buildUrl = (params) => {
    const urlParams = new URLSearchParams;
    Object.entries(routeParams).forEach(([key, value]) => {
      if (value)
        urlParams.set(key, value);
    });
    Object.entries(params).forEach(([key, value]) => {
      urlParams.set(key, value);
    });
    const baseUrl = baseRoute;
    return `${baseUrl}?${urlParams.toString()}`;
  };
  const navigateToUrl = (url) => {
    try {
      fetcher.load(url);
      window.history.pushState({}, "", url);
    } catch (error) {
      console.error("Navigation error:", error);
    }
  };
  const handleLimitChange = (newLimit) => {
    const url = buildUrl({
      limit: newLimit.toString(),
      page: "1"
    });
    navigateToUrl(url);
  };
  const handlePageChange = (newPage) => {
    const url = buildUrl({
      page: newPage.toString(),
      limit: pagination.limit.toString()
    });
    navigateToUrl(url);
  };
  return /* @__PURE__ */ jsx162("div", {
    className: "border-b p-4",
    children: /* @__PURE__ */ jsxs42("div", {
      className: "flex items-center justify-between",
      children: [
        /* @__PURE__ */ jsxs42("div", {
          className: "flex items-center gap-2",
          children: [
            /* @__PURE__ */ jsx162(PaginationControls, {
              currentPage: pagination.page,
              hasNextPage: pagination.hasNextPage,
              hasPreviousPage: pagination.hasPreviousPage,
              onPageChange: handlePageChange,
              disabled: isLoading
            }),
            isLoading && loadingIcon && /* @__PURE__ */ jsx162(SvgIcon4, {
              iconId: "LoaderCircle",
              className: "h-4 w-4 animate-spin text-muted-foreground"
            })
          ]
        }),
        /* @__PURE__ */ jsxs42("div", {
          className: "flex items-center gap-4",
          children: [
            /* @__PURE__ */ jsx162(RowsPerPageSelector, {
              currentLimit: pagination.limit,
              options: perPageOptions,
              onLimitChange: handleLimitChange,
              disabled: isLoading
            }),
            /* @__PURE__ */ jsx162(RecordCountDisplay, {
              currentPage: pagination.page,
              currentRecords,
              hasNextPage: pagination.hasNextPage,
              totalRecords
            })
          ]
        })
      ]
    })
  });
}
function RowsPerPageSelector({ currentLimit, options: options22, onLimitChange, disabled = false }) {
  return /* @__PURE__ */ jsxs42("div", {
    className: "flex items-center gap-2",
    children: [
      /* @__PURE__ */ jsx162("label", {
        htmlFor: "rows-per-page",
        className: "font-medium text-sm",
        children: "Rows per page:"
      }),
      /* @__PURE__ */ jsxs42(Select2, {
        value: currentLimit.toString(),
        onValueChange: (value) => {
          onLimitChange(Number.parseInt(value, 10));
        },
        disabled,
        children: [
          /* @__PURE__ */ jsx162(SelectTrigger2, {
            className: "w-20",
            children: /* @__PURE__ */ jsx162(SelectValue2, {})
          }),
          /* @__PURE__ */ jsx162(SelectContent2, {
            children: options22.map((option) => /* @__PURE__ */ jsx162(SelectItem2, {
              value: option.toString(),
              children: option
            }, option))
          })
        ]
      })
    ]
  });
}
function RecordCountDisplay({ currentPage, currentRecords, hasNextPage, totalRecords }) {
  if (currentRecords === 0) {
    return null;
  }
  if (totalRecords !== undefined) {
    const currentLimit = currentRecords;
    const start = (currentPage - 1) * currentLimit + 1;
    const end = Math.min(currentPage * currentLimit, totalRecords);
    return /* @__PURE__ */ jsxs42("p", {
      className: "text-muted-foreground text-sm",
      children: [
        "Showing ",
        start,
        "-",
        end,
        " of ",
        totalRecords.toLocaleString(),
        " records"
      ]
    });
  }
  return /* @__PURE__ */ jsxs42("p", {
    className: "text-muted-foreground text-sm",
    children: [
      "Page ",
      currentPage,
      "  ",
      currentRecords,
      " records ",
      hasNextPage ? "(more available)" : ""
    ]
  });
}
function PaginationControls({ currentPage, hasNextPage, hasPreviousPage, onPageChange, disabled = false }) {
  if (!hasPreviousPage && !hasNextPage) {
    return null;
  }
  const handlePageClick = (page, e) => {
    e.preventDefault();
    if (!disabled && page !== currentPage) {
      onPageChange(page);
    }
  };
  const handleNavigationClick = (page, e) => {
    e.preventDefault();
    if (!disabled) {
      onPageChange(page);
    }
  };
  return /* @__PURE__ */ jsx162("div", {
    className: "",
    children: /* @__PURE__ */ jsx162(Pagination, {
      children: /* @__PURE__ */ jsxs42(PaginationContent, {
        children: [
          /* @__PURE__ */ jsx162(PaginationItem, {
            children: /* @__PURE__ */ jsx162(PaginationPrevious, {
              href: "#",
              className: hasPreviousPage ? "" : "pointer-events-none opacity-50",
              onClick: (e) => handleNavigationClick(currentPage - 1, e)
            })
          }),
          currentPage > 2 && /* @__PURE__ */ jsxs42(Fragment72, {
            children: [
              /* @__PURE__ */ jsx162(PaginationItem, {
                children: /* @__PURE__ */ jsx162(PaginationLink, {
                  href: "#",
                  onClick: (e) => handlePageClick(1, e),
                  children: "1"
                })
              }),
              currentPage > 3 && /* @__PURE__ */ jsx162(PaginationItem, {
                children: /* @__PURE__ */ jsx162(PaginationEllipsis, {})
              })
            ]
          }),
          hasPreviousPage && /* @__PURE__ */ jsx162(PaginationItem, {
            children: /* @__PURE__ */ jsx162(PaginationLink, {
              href: "#",
              onClick: (e) => handlePageClick(currentPage - 1, e),
              children: currentPage - 1
            })
          }),
          /* @__PURE__ */ jsx162(PaginationItem, {
            children: /* @__PURE__ */ jsx162(PaginationLink, {
              href: "#",
              isActive: true,
              children: currentPage
            })
          }),
          hasNextPage && /* @__PURE__ */ jsx162(PaginationItem, {
            children: /* @__PURE__ */ jsx162(PaginationLink, {
              href: "#",
              onClick: (e) => handlePageClick(currentPage + 1, e),
              children: currentPage + 1
            })
          }),
          hasNextPage && /* @__PURE__ */ jsx162(PaginationItem, {
            children: /* @__PURE__ */ jsx162(PaginationEllipsis, {})
          }),
          /* @__PURE__ */ jsx162(PaginationItem, {
            children: /* @__PURE__ */ jsx162(PaginationNext, {
              href: "#",
              className: hasNextPage ? "" : "pointer-events-none opacity-50",
              onClick: (e) => handleNavigationClick(currentPage + 1, e)
            })
          })
        ]
      })
    })
  });
}
function InputOtp({ value, onValueChange, containerClassName, children, ...props }) {
  return /* @__PURE__ */ jsx172(exports_dist.Root, {
    "data-slot": "input-otp",
    className: containerClassName,
    value,
    onValueChange,
    ...props,
    children
  });
}
function InputOtpGroup({ className, ...props }) {
  return /* @__PURE__ */ jsx172("div", {
    "data-slot": "input-otp-group",
    className: clsx43("flex items-center gap-2", className),
    ...props
  });
}
function InputOtpSlot({ className, index: index22, ...props }) {
  return /* @__PURE__ */ jsx172(exports_dist.Input, {
    "data-slot": "input-otp-slot",
    "data-index": index22,
    className: clsx43("relative flex h-10 w-10 items-center justify-center border-2 border-input bg-background text-sm transition-all dark:border", "rounded-md", "caret-transparent selection:bg-transparent selection:text-foreground", "focus-visible:z-10 focus-visible:border-ring focus-visible:outline-none", "disabled:cursor-not-allowed disabled:opacity-50", "aria-invalid:border-destructive", "text-center font-medium", className),
    ...props
  });
}
function InputOtpHiddenInput(props) {
  return /* @__PURE__ */ jsx172(exports_dist.HiddenInput, {
    "data-slot": "input-otp-hidden",
    ...props
  });
}
var Link4 = React342.forwardRef(function Link22(props, ref) {
  return /* @__PURE__ */ jsx182(RouterLink2, {
    ...props,
    to: props.href,
    ref
  });
});
var SpriteIconContext3 = createContext62(null);
function useStateMachine3(initialState, machine) {
  return React352.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence3 = (props) => {
  const { present, children } = props;
  const presence = usePresence3(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React252.Children.only(children);
  const ref = useComposedRefs3(presence.ref, getElementRef22(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React252.cloneElement(child, { ref }) : null;
};
Presence3.displayName = "Presence";
function usePresence3(present) {
  const [node, setNode] = React252.useState();
  const stylesRef = React252.useRef(null);
  const prevPresentRef = React252.useRef(present);
  const prevAnimationNameRef = React252.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine3(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React252.useEffect(() => {
    const currentAnimationName = getAnimationName3(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect24(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName3(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect24(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName3(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName3(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React252.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName3(styles) {
  return styles?.animationName || "none";
}
function getElementRef22(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var [createTooltipContext, createTooltipScope] = createContextScope3("Tooltip", [
  createPopperScope2
]);
var usePopperScope22 = createPopperScope2();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = React362.useRef(true);
  const isPointerInTransitRef = React362.useRef(false);
  const skipDelayTimerRef = React362.useRef(0);
  React362.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsx233(TooltipProviderContextProvider, {
    scope: __scopeTooltip,
    isOpenDelayedRef,
    delayDuration,
    onOpen: React362.useCallback(() => {
      window.clearTimeout(skipDelayTimerRef.current);
      isOpenDelayedRef.current = false;
    }, []),
    onClose: React362.useCallback(() => {
      window.clearTimeout(skipDelayTimerRef.current);
      skipDelayTimerRef.current = window.setTimeout(() => isOpenDelayedRef.current = true, skipDelayDuration);
    }, [skipDelayDuration]),
    isPointerInTransitRef,
    onPointerInTransitChange: React362.useCallback((inTransit) => {
      isPointerInTransitRef.current = inTransit;
    }, []),
    disableHoverableContent,
    children
  });
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope22(__scopeTooltip);
  const [trigger, setTrigger] = React362.useState(null);
  const contentId = useId3();
  const openTimerRef = React362.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React362.useRef(false);
  const [open, setOpen] = useControllableState3({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange?.(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = React362.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React362.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React362.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React362.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React362.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ jsx233(Root22, { ...popperScope, children: /* @__PURE__ */ jsx233(TooltipContextProvider, {
    scope: __scopeTooltip,
    contentId,
    open,
    stateAttribute,
    trigger,
    onTriggerChange: setTrigger,
    onTriggerEnter: React362.useCallback(() => {
      if (providerContext.isOpenDelayedRef.current)
        handleDelayedOpen();
      else
        handleOpen();
    }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
    onTriggerLeave: React362.useCallback(() => {
      if (disableHoverableContent) {
        handleClose();
      } else {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    }, [handleClose, disableHoverableContent]),
    onOpen: handleOpen,
    onClose: handleClose,
    disableHoverableContent,
    children
  }) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME22 = "TooltipTrigger";
var TooltipTrigger = React362.forwardRef((props, forwardedRef) => {
  const { __scopeTooltip, ...triggerProps } = props;
  const context = useTooltipContext(TRIGGER_NAME22, __scopeTooltip);
  const providerContext = useTooltipProviderContext(TRIGGER_NAME22, __scopeTooltip);
  const popperScope = usePopperScope22(__scopeTooltip);
  const ref = React362.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref, context.onTriggerChange);
  const isPointerDownRef = React362.useRef(false);
  const hasPointerMoveOpenedRef = React362.useRef(false);
  const handlePointerUp = React362.useCallback(() => isPointerDownRef.current = false, []);
  React362.useEffect(() => {
    return () => document.removeEventListener("pointerup", handlePointerUp);
  }, [handlePointerUp]);
  return /* @__PURE__ */ jsx233(Anchor3, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsx233(Primitive3.button, {
    "aria-describedby": context.open ? context.contentId : undefined,
    "data-state": context.stateAttribute,
    ...triggerProps,
    ref: composedRefs,
    onPointerMove: composeEventHandlers3(props.onPointerMove, (event) => {
      if (event.pointerType === "touch")
        return;
      if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
        context.onTriggerEnter();
        hasPointerMoveOpenedRef.current = true;
      }
    }),
    onPointerLeave: composeEventHandlers3(props.onPointerLeave, () => {
      context.onTriggerLeave();
      hasPointerMoveOpenedRef.current = false;
    }),
    onPointerDown: composeEventHandlers3(props.onPointerDown, () => {
      if (context.open) {
        context.onClose();
      }
      isPointerDownRef.current = true;
      document.addEventListener("pointerup", handlePointerUp, { once: true });
    }),
    onFocus: composeEventHandlers3(props.onFocus, () => {
      if (!isPointerDownRef.current)
        context.onOpen();
    }),
    onBlur: composeEventHandlers3(props.onBlur, context.onClose),
    onClick: composeEventHandlers3(props.onClick, context.onClose)
  }) });
});
TooltipTrigger.displayName = TRIGGER_NAME22;
var PORTAL_NAME32 = "TooltipPortal";
var [PortalProvider5, usePortalContext5] = createTooltipContext(PORTAL_NAME32, {
  forceMount: undefined
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME32, __scopeTooltip);
  return /* @__PURE__ */ jsx233(PortalProvider5, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ jsx233(Presence3, { present: forceMount || context.open, children: /* @__PURE__ */ jsx233(Portal6, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME32;
var CONTENT_NAME32 = "TooltipContent";
var TooltipContent = React362.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext5(CONTENT_NAME32, props.__scopeTooltip);
  const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
  const context = useTooltipContext(CONTENT_NAME32, props.__scopeTooltip);
  return /* @__PURE__ */ jsx233(Presence3, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsx233(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx233(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
});
var TooltipContentHoverable = React362.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME32, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME32, props.__scopeTooltip);
  const ref = React362.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React362.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React362.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React362.useCallback((event, hoverTarget) => {
    const currentTarget = event.currentTarget;
    const exitPoint = { x: event.clientX, y: event.clientY };
    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
    setPointerGraceArea(graceArea);
    onPointerInTransitChange(true);
  }, [onPointerInTransitChange]);
  React362.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React362.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React362.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon2(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsx233(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable = createSlottable("TooltipContent");
var TooltipContentImpl = React362.forwardRef((props, forwardedRef) => {
  const {
    __scopeTooltip,
    children,
    "aria-label": ariaLabel,
    onEscapeKeyDown,
    onPointerDownOutside,
    ...contentProps
  } = props;
  const context = useTooltipContext(CONTENT_NAME32, __scopeTooltip);
  const popperScope = usePopperScope22(__scopeTooltip);
  const { onClose } = context;
  React362.useEffect(() => {
    document.addEventListener(TOOLTIP_OPEN, onClose);
    return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
  }, [onClose]);
  React362.useEffect(() => {
    if (context.trigger) {
      const handleScroll22 = (event) => {
        const target = event.target;
        if (target?.contains(context.trigger))
          onClose();
      };
      window.addEventListener("scroll", handleScroll22, { capture: true });
      return () => window.removeEventListener("scroll", handleScroll22, { capture: true });
    }
  }, [context.trigger, onClose]);
  return /* @__PURE__ */ jsx233(DismissableLayer3, {
    asChild: true,
    disableOutsidePointerEvents: false,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside: (event) => event.preventDefault(),
    onDismiss: onClose,
    children: /* @__PURE__ */ jsxs52(Content5, {
      "data-state": context.stateAttribute,
      ...popperScope,
      ...contentProps,
      ref: forwardedRef,
      style: {
        ...contentProps.style,
        ...{
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        }
      },
      children: [
        /* @__PURE__ */ jsx233(Slottable, { children }),
        /* @__PURE__ */ jsx233(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsx233(Root33, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
      ]
    })
  });
});
TooltipContent.displayName = CONTENT_NAME32;
var ARROW_NAME32 = "TooltipArrow";
var TooltipArrow = React362.forwardRef((props, forwardedRef) => {
  const { __scopeTooltip, ...arrowProps } = props;
  const popperScope = usePopperScope22(__scopeTooltip);
  const visuallyHiddenContentContext = useVisuallyHiddenContentContext(ARROW_NAME32, __scopeTooltip);
  return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsx233(Arrow23, { ...popperScope, ...arrowProps, ref: forwardedRef });
});
TooltipArrow.displayName = ARROW_NAME32;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y + padding }, { x: exitPoint.x + padding, y: exitPoint.y + padding });
      break;
    case "bottom":
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y - padding }, { x: exitPoint.x + padding, y: exitPoint.y - padding });
      break;
    case "left":
      paddedExitPoints.push({ x: exitPoint.x + padding, y: exitPoint.y - padding }, { x: exitPoint.x + padding, y: exitPoint.y + padding });
      break;
    case "right":
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y - padding }, { x: exitPoint.x - padding, y: exitPoint.y + padding });
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon2(point, polygon) {
  const { x: x2, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1;i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x2 < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x)
      return -1;
    else if (a.x > b.x)
      return 1;
    else if (a.y < b.y)
      return -1;
    else if (a.y > b.y)
      return 1;
    else
      return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0;i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1;i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider;
var Root322 = Tooltip;
var Trigger2 = TooltipTrigger;
var Portal32 = TooltipPortal;
var Content222 = TooltipContent;
var Arrow222 = TooltipArrow;
function TooltipProvider2({ delayDuration = 0, ...props }) {
  return /* @__PURE__ */ jsx252(Provider, {
    "data-slot": "tooltip-provider",
    delayDuration,
    ...props
  });
}
function Tooltip2({ ...props }) {
  return /* @__PURE__ */ jsx252(TooltipProvider2, {
    children: /* @__PURE__ */ jsx252(Root322, {
      "data-slot": "tooltip",
      ...props
    })
  });
}
function TooltipTrigger2({ ...props }) {
  return /* @__PURE__ */ jsx252(Trigger2, {
    "data-slot": "tooltip-trigger",
    ...props
  });
}
function TooltipContent2({ className, sideOffset = 0, children, ...props }) {
  return /* @__PURE__ */ jsx252(Portal32, {
    children: /* @__PURE__ */ jsxs62(Content222, {
      "data-slot": "tooltip-content",
      sideOffset,
      className: clsx62("fade-in-0 zoom-in-95 data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) animate-in text-balance rounded-md bg-foreground px-3 py-1.5 text-background text-xs data-[state=closed]:animate-out", className),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsx252(Arrow222, {
          className: "z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] bg-foreground fill-foreground"
        })
      ]
    })
  });
}
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = createContextScope3(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible = React372.forwardRef((props, forwardedRef) => {
  const {
    __scopeCollapsible,
    open: openProp,
    defaultOpen,
    disabled,
    onOpenChange,
    ...collapsibleProps
  } = props;
  const [open, setOpen] = useControllableState3({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: COLLAPSIBLE_NAME
  });
  return /* @__PURE__ */ jsx262(CollapsibleProvider, {
    scope: __scopeCollapsible,
    disabled,
    contentId: useId3(),
    open,
    onOpenToggle: React372.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
    children: /* @__PURE__ */ jsx262(Primitive3.div, {
      "data-state": getState3(open),
      "data-disabled": disabled ? "" : undefined,
      ...collapsibleProps,
      ref: forwardedRef
    })
  });
});
Collapsible.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME32 = "CollapsibleTrigger";
var CollapsibleTrigger = React372.forwardRef((props, forwardedRef) => {
  const { __scopeCollapsible, ...triggerProps } = props;
  const context = useCollapsibleContext(TRIGGER_NAME32, __scopeCollapsible);
  return /* @__PURE__ */ jsx262(Primitive3.button, {
    type: "button",
    "aria-controls": context.contentId,
    "aria-expanded": context.open || false,
    "data-state": getState3(context.open),
    "data-disabled": context.disabled ? "" : undefined,
    disabled: context.disabled,
    ...triggerProps,
    ref: forwardedRef,
    onClick: composeEventHandlers3(props.onClick, context.onOpenToggle)
  });
});
CollapsibleTrigger.displayName = TRIGGER_NAME32;
var CONTENT_NAME42 = "CollapsibleContent";
var CollapsibleContent = React372.forwardRef((props, forwardedRef) => {
  const { forceMount, ...contentProps } = props;
  const context = useCollapsibleContext(CONTENT_NAME42, props.__scopeCollapsible);
  return /* @__PURE__ */ jsx262(Presence3, { present: forceMount || context.open, children: ({ present }) => /* @__PURE__ */ jsx262(CollapsibleContentImpl, { ...contentProps, ref: forwardedRef, present }) });
});
CollapsibleContent.displayName = CONTENT_NAME42;
var CollapsibleContentImpl = React372.forwardRef((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context = useCollapsibleContext(CONTENT_NAME42, __scopeCollapsible);
  const [isPresent, setIsPresent] = React372.useState(present);
  const ref = React372.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  const heightRef = React372.useRef(0);
  const height = heightRef.current;
  const widthRef = React372.useRef(0);
  const width = widthRef.current;
  const isOpen = context.open || isPresent;
  const isMountAnimationPreventedRef = React372.useRef(isOpen);
  const originalStylesRef = React372.useRef(undefined);
  React372.useEffect(() => {
    const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF);
  }, []);
  useLayoutEffect24(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [context.open, present]);
  return /* @__PURE__ */ jsx262(Primitive3.div, {
    "data-state": getState3(context.open),
    "data-disabled": context.disabled ? "" : undefined,
    id: context.contentId,
    hidden: !isOpen,
    ...contentProps,
    ref: composedRefs,
    style: {
      [`--radix-collapsible-content-height`]: height ? `${height}px` : undefined,
      [`--radix-collapsible-content-width`]: width ? `${width}px` : undefined,
      ...props.style
    },
    children: isOpen && children
  });
});
function getState3(open) {
  return open ? "open" : "closed";
}
var Root5 = Collapsible;
var Trigger3 = CollapsibleTrigger;
var Content32 = CollapsibleContent;
var ACCORDION_NAME = "Accordion";
var ACCORDION_KEYS = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"];
var [Collection22, useCollection22, createCollectionScope22] = createCollection3(ACCORDION_NAME);
var [createAccordionContext, createAccordionScope] = createContextScope3(ACCORDION_NAME, [
  createCollectionScope22,
  createCollapsibleScope
]);
var useCollapsibleScope = createCollapsibleScope();
var Accordion = React382.forwardRef((props, forwardedRef) => {
  const { type, ...accordionProps } = props;
  const singleProps = accordionProps;
  const multipleProps = accordionProps;
  return /* @__PURE__ */ jsx272(Collection22.Provider, { scope: props.__scopeAccordion, children: type === "multiple" ? /* @__PURE__ */ jsx272(AccordionImplMultiple, { ...multipleProps, ref: forwardedRef }) : /* @__PURE__ */ jsx272(AccordionImplSingle, { ...singleProps, ref: forwardedRef }) });
});
Accordion.displayName = ACCORDION_NAME;
var [AccordionValueProvider, useAccordionValueContext] = createAccordionContext(ACCORDION_NAME);
var [AccordionCollapsibleProvider, useAccordionCollapsibleContext] = createAccordionContext(ACCORDION_NAME, { collapsible: false });
var AccordionImplSingle = React382.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {},
    collapsible = false,
    ...accordionSingleProps
  } = props;
  const [value, setValue] = useControllableState3({
    prop: valueProp,
    defaultProp: defaultValue ?? "",
    onChange: onValueChange,
    caller: ACCORDION_NAME
  });
  return /* @__PURE__ */ jsx272(AccordionValueProvider, {
    scope: props.__scopeAccordion,
    value: React382.useMemo(() => value ? [value] : [], [value]),
    onItemOpen: setValue,
    onItemClose: React382.useCallback(() => collapsible && setValue(""), [collapsible, setValue]),
    children: /* @__PURE__ */ jsx272(AccordionCollapsibleProvider, { scope: props.__scopeAccordion, collapsible, children: /* @__PURE__ */ jsx272(AccordionImpl, { ...accordionSingleProps, ref: forwardedRef }) })
  });
});
var AccordionImplMultiple = React382.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {},
    ...accordionMultipleProps
  } = props;
  const [value, setValue] = useControllableState3({
    prop: valueProp,
    defaultProp: defaultValue ?? [],
    onChange: onValueChange,
    caller: ACCORDION_NAME
  });
  const handleItemOpen = React382.useCallback((itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]), [setValue]);
  const handleItemClose = React382.useCallback((itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)), [setValue]);
  return /* @__PURE__ */ jsx272(AccordionValueProvider, {
    scope: props.__scopeAccordion,
    value,
    onItemOpen: handleItemOpen,
    onItemClose: handleItemClose,
    children: /* @__PURE__ */ jsx272(AccordionCollapsibleProvider, { scope: props.__scopeAccordion, collapsible: true, children: /* @__PURE__ */ jsx272(AccordionImpl, { ...accordionMultipleProps, ref: forwardedRef }) })
  });
});
var [AccordionImplProvider, useAccordionContext] = createAccordionContext(ACCORDION_NAME);
var AccordionImpl = React382.forwardRef((props, forwardedRef) => {
  const { __scopeAccordion, disabled, dir, orientation = "vertical", ...accordionProps } = props;
  const accordionRef = React382.useRef(null);
  const composedRefs = useComposedRefs3(accordionRef, forwardedRef);
  const getItems = useCollection22(__scopeAccordion);
  const direction = useDirection3(dir);
  const isDirectionLTR = direction === "ltr";
  const handleKeyDown = composeEventHandlers3(props.onKeyDown, (event) => {
    if (!ACCORDION_KEYS.includes(event.key))
      return;
    const target = event.target;
    const triggerCollection = getItems().filter((item) => !item.ref.current?.disabled);
    const triggerIndex = triggerCollection.findIndex((item) => item.ref.current === target);
    const triggerCount = triggerCollection.length;
    if (triggerIndex === -1)
      return;
    event.preventDefault();
    let nextIndex = triggerIndex;
    const homeIndex = 0;
    const endIndex = triggerCount - 1;
    const moveNext = () => {
      nextIndex = triggerIndex + 1;
      if (nextIndex > endIndex) {
        nextIndex = homeIndex;
      }
    };
    const movePrev = () => {
      nextIndex = triggerIndex - 1;
      if (nextIndex < homeIndex) {
        nextIndex = endIndex;
      }
    };
    switch (event.key) {
      case "Home":
        nextIndex = homeIndex;
        break;
      case "End":
        nextIndex = endIndex;
        break;
      case "ArrowRight":
        if (orientation === "horizontal") {
          if (isDirectionLTR) {
            moveNext();
          } else {
            movePrev();
          }
        }
        break;
      case "ArrowDown":
        if (orientation === "vertical") {
          moveNext();
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal") {
          if (isDirectionLTR) {
            movePrev();
          } else {
            moveNext();
          }
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical") {
          movePrev();
        }
        break;
    }
    const clampedIndex = nextIndex % triggerCount;
    triggerCollection[clampedIndex].ref.current?.focus();
  });
  return /* @__PURE__ */ jsx272(AccordionImplProvider, {
    scope: __scopeAccordion,
    disabled,
    direction: dir,
    orientation,
    children: /* @__PURE__ */ jsx272(Collection22.Slot, { scope: __scopeAccordion, children: /* @__PURE__ */ jsx272(Primitive3.div, {
      ...accordionProps,
      "data-orientation": orientation,
      ref: composedRefs,
      onKeyDown: disabled ? undefined : handleKeyDown
    }) })
  });
});
var ITEM_NAME22 = "AccordionItem";
var [AccordionItemProvider, useAccordionItemContext] = createAccordionContext(ITEM_NAME22);
var AccordionItem = React382.forwardRef((props, forwardedRef) => {
  const { __scopeAccordion, value, ...accordionItemProps } = props;
  const accordionContext = useAccordionContext(ITEM_NAME22, __scopeAccordion);
  const valueContext = useAccordionValueContext(ITEM_NAME22, __scopeAccordion);
  const collapsibleScope = useCollapsibleScope(__scopeAccordion);
  const triggerId = useId3();
  const open = value && valueContext.value.includes(value) || false;
  const disabled = accordionContext.disabled || props.disabled;
  return /* @__PURE__ */ jsx272(AccordionItemProvider, {
    scope: __scopeAccordion,
    open,
    disabled,
    triggerId,
    children: /* @__PURE__ */ jsx272(Root5, {
      "data-orientation": accordionContext.orientation,
      "data-state": getState22(open),
      ...collapsibleScope,
      ...accordionItemProps,
      ref: forwardedRef,
      disabled,
      open,
      onOpenChange: (open2) => {
        if (open2) {
          valueContext.onItemOpen(value);
        } else {
          valueContext.onItemClose(value);
        }
      }
    })
  });
});
AccordionItem.displayName = ITEM_NAME22;
var HEADER_NAME = "AccordionHeader";
var AccordionHeader = React382.forwardRef((props, forwardedRef) => {
  const { __scopeAccordion, ...headerProps } = props;
  const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
  const itemContext = useAccordionItemContext(HEADER_NAME, __scopeAccordion);
  return /* @__PURE__ */ jsx272(Primitive3.h3, {
    "data-orientation": accordionContext.orientation,
    "data-state": getState22(itemContext.open),
    "data-disabled": itemContext.disabled ? "" : undefined,
    ...headerProps,
    ref: forwardedRef
  });
});
AccordionHeader.displayName = HEADER_NAME;
var TRIGGER_NAME4 = "AccordionTrigger";
var AccordionTrigger = React382.forwardRef((props, forwardedRef) => {
  const { __scopeAccordion, ...triggerProps } = props;
  const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
  const itemContext = useAccordionItemContext(TRIGGER_NAME4, __scopeAccordion);
  const collapsibleContext = useAccordionCollapsibleContext(TRIGGER_NAME4, __scopeAccordion);
  const collapsibleScope = useCollapsibleScope(__scopeAccordion);
  return /* @__PURE__ */ jsx272(Collection22.ItemSlot, { scope: __scopeAccordion, children: /* @__PURE__ */ jsx272(Trigger3, {
    "aria-disabled": itemContext.open && !collapsibleContext.collapsible || undefined,
    "data-orientation": accordionContext.orientation,
    id: itemContext.triggerId,
    ...collapsibleScope,
    ...triggerProps,
    ref: forwardedRef
  }) });
});
AccordionTrigger.displayName = TRIGGER_NAME4;
var CONTENT_NAME52 = "AccordionContent";
var AccordionContent = React382.forwardRef((props, forwardedRef) => {
  const { __scopeAccordion, ...contentProps } = props;
  const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
  const itemContext = useAccordionItemContext(CONTENT_NAME52, __scopeAccordion);
  const collapsibleScope = useCollapsibleScope(__scopeAccordion);
  return /* @__PURE__ */ jsx272(Content32, {
    role: "region",
    "aria-labelledby": itemContext.triggerId,
    "data-orientation": accordionContext.orientation,
    ...collapsibleScope,
    ...contentProps,
    ref: forwardedRef,
    style: {
      ["--radix-accordion-content-height"]: "var(--radix-collapsible-content-height)",
      ["--radix-accordion-content-width"]: "var(--radix-collapsible-content-width)",
      ...props.style
    }
  });
});
AccordionContent.displayName = CONTENT_NAME52;
function getState22(open) {
  return open ? "open" : "closed";
}
var Root23 = Accordion;
var Item22 = AccordionItem;
var Header = AccordionHeader;
var Trigger22 = AccordionTrigger;
var Content23 = AccordionContent;
function Accordion2({ ...props }) {
  return /* @__PURE__ */ jsx282(Root23, {
    "data-slot": "accordion",
    ...props
  });
}
function AccordionItem2({ className, ...props }) {
  return /* @__PURE__ */ jsx282(Item22, {
    "data-slot": "accordion-item",
    className: clsx72("border-b last:border-b-0", className),
    ...props
  });
}
function AccordionTrigger2({ className, children, ...props }) {
  return /* @__PURE__ */ jsx282(Header, {
    className: "flex",
    children: /* @__PURE__ */ jsxs7(Trigger22, {
      "data-slot": "accordion-trigger",
      className: clsx72("flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left font-medium text-sm outline-none transition-all hover:underline focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180", className),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsx282(SvgIcon4, {
          iconId: "ChevronDown",
          className: "pointer-events-none size-4 shrink-0 translate-y-0.5 text-muted-foreground transition-transform duration-200"
        })
      ]
    })
  });
}
function AccordionContent2({ className, children, ...props }) {
  return /* @__PURE__ */ jsx282(Content23, {
    "data-slot": "accordion-content",
    className: "overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
    ...props,
    children: /* @__PURE__ */ jsx282("div", {
      className: clsx72("pt-0 pb-4", className),
      children
    })
  });
}
var alertVariants = cva("relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current", {
  variants: {
    variant: {
      default: "bg-card text-card-foreground",
      destructive: "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90"
    }
  },
  defaultVariants: {
    variant: "default"
  }
});
function Alert({ className, variant, ...props }) {
  return /* @__PURE__ */ jsx302("div", {
    "data-slot": "alert",
    role: "alert",
    className: clsx8(alertVariants({ variant }), className),
    ...props
  });
}
function AlertTitle({ className, ...props }) {
  return /* @__PURE__ */ jsx302("div", {
    "data-slot": "alert-title",
    className: clsx8("col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", className),
    ...props
  });
}
function AlertDescription({ className, ...props }) {
  return /* @__PURE__ */ jsx302("div", {
    "data-slot": "alert-description",
    className: clsx8("col-start-2 grid justify-items-start gap-1 text-muted-foreground text-sm [&_p]:leading-relaxed", className),
    ...props
  });
}
var DIALOG_NAME3 = "Dialog";
var [createDialogContext3, createDialogScope3] = createContextScope3(DIALOG_NAME3);
var [DialogProvider3, useDialogContext3] = createDialogContext3(DIALOG_NAME3);
var Dialog3 = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React392.useRef(null);
  const contentRef = React392.useRef(null);
  const [open, setOpen] = useControllableState3({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME3
  });
  return /* @__PURE__ */ jsx332(DialogProvider3, {
    scope: __scopeDialog,
    triggerRef,
    contentRef,
    contentId: useId3(),
    titleId: useId3(),
    descriptionId: useId3(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: React392.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
    modal,
    children
  });
};
Dialog3.displayName = DIALOG_NAME3;
var TRIGGER_NAME52 = "DialogTrigger";
var DialogTrigger3 = React392.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...triggerProps } = props;
  const context = useDialogContext3(TRIGGER_NAME52, __scopeDialog);
  const composedTriggerRef = useComposedRefs3(forwardedRef, context.triggerRef);
  return /* @__PURE__ */ jsx332(Primitive3.button, {
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": getState32(context.open),
    ...triggerProps,
    ref: composedTriggerRef,
    onClick: composeEventHandlers3(props.onClick, context.onOpenToggle)
  });
});
DialogTrigger3.displayName = TRIGGER_NAME52;
var PORTAL_NAME42 = "DialogPortal";
var [PortalProvider22, usePortalContext22] = createDialogContext3(PORTAL_NAME42, {
  forceMount: undefined
});
var DialogPortal3 = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext3(PORTAL_NAME42, __scopeDialog);
  return /* @__PURE__ */ jsx332(PortalProvider22, { scope: __scopeDialog, forceMount, children: React392.Children.map(children, (child) => /* @__PURE__ */ jsx332(Presence3, { present: forceMount || context.open, children: /* @__PURE__ */ jsx332(Portal6, { asChild: true, container, children: child }) })) });
};
DialogPortal3.displayName = PORTAL_NAME42;
var OVERLAY_NAME3 = "DialogOverlay";
var DialogOverlay3 = React392.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext22(OVERLAY_NAME3, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...overlayProps } = props;
  const context = useDialogContext3(OVERLAY_NAME3, props.__scopeDialog);
  return context.modal ? /* @__PURE__ */ jsx332(Presence3, { present: forceMount || context.open, children: /* @__PURE__ */ jsx332(DialogOverlayImpl3, { ...overlayProps, ref: forwardedRef }) }) : null;
});
DialogOverlay3.displayName = OVERLAY_NAME3;
var Slot32 = createSlot3("DialogOverlay.RemoveScroll");
var DialogOverlayImpl3 = React392.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...overlayProps } = props;
  const context = useDialogContext3(OVERLAY_NAME3, __scopeDialog);
  return /* @__PURE__ */ jsx332(Combination_default3, { as: Slot32, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsx332(Primitive3.div, {
    "data-state": getState32(context.open),
    ...overlayProps,
    ref: forwardedRef,
    style: { pointerEvents: "auto", ...overlayProps.style }
  }) });
});
var CONTENT_NAME6 = "DialogContent";
var DialogContent3 = React392.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext22(CONTENT_NAME6, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = useDialogContext3(CONTENT_NAME6, props.__scopeDialog);
  return /* @__PURE__ */ jsx332(Presence3, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsx332(DialogContentModal3, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx332(DialogContentNonModal3, { ...contentProps, ref: forwardedRef }) });
});
DialogContent3.displayName = CONTENT_NAME6;
var DialogContentModal3 = React392.forwardRef((props, forwardedRef) => {
  const context = useDialogContext3(CONTENT_NAME6, props.__scopeDialog);
  const contentRef = React392.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, context.contentRef, contentRef);
  React392.useEffect(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers3(content);
  }, []);
  return /* @__PURE__ */ jsx332(DialogContentImpl3, {
    ...props,
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: composeEventHandlers3(props.onCloseAutoFocus, (event) => {
      event.preventDefault();
      context.triggerRef.current?.focus();
    }),
    onPointerDownOutside: composeEventHandlers3(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (isRightClick)
        event.preventDefault();
    }),
    onFocusOutside: composeEventHandlers3(props.onFocusOutside, (event) => event.preventDefault())
  });
});
var DialogContentNonModal3 = React392.forwardRef((props, forwardedRef) => {
  const context = useDialogContext3(CONTENT_NAME6, props.__scopeDialog);
  const hasInteractedOutsideRef = React392.useRef(false);
  const hasPointerDownOutsideRef = React392.useRef(false);
  return /* @__PURE__ */ jsx332(DialogContentImpl3, {
    ...props,
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      props.onCloseAutoFocus?.(event);
      if (!event.defaultPrevented) {
        if (!hasInteractedOutsideRef.current)
          context.triggerRef.current?.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      props.onInteractOutside?.(event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown") {
          hasPointerDownOutsideRef.current = true;
        }
      }
      const target = event.target;
      const targetIsTrigger = context.triggerRef.current?.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
        event.preventDefault();
      }
    }
  });
});
var DialogContentImpl3 = React392.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
  const context = useDialogContext3(CONTENT_NAME6, __scopeDialog);
  const contentRef = React392.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, contentRef);
  useFocusGuards3();
  return /* @__PURE__ */ jsxs11(Fragment82, { children: [
    /* @__PURE__ */ jsx332(FocusScope3, {
      asChild: true,
      loop: true,
      trapped: trapFocus,
      onMountAutoFocus: onOpenAutoFocus,
      onUnmountAutoFocus: onCloseAutoFocus,
      children: /* @__PURE__ */ jsx332(DismissableLayer3, {
        role: "dialog",
        id: context.contentId,
        "aria-describedby": context.descriptionId,
        "aria-labelledby": context.titleId,
        "data-state": getState32(context.open),
        ...contentProps,
        ref: composedRefs,
        onDismiss: () => context.onOpenChange(false)
      })
    }),
    /* @__PURE__ */ jsxs11(Fragment82, { children: [
      /* @__PURE__ */ jsx332(TitleWarning3, { titleId: context.titleId }),
      /* @__PURE__ */ jsx332(DescriptionWarning3, { contentRef, descriptionId: context.descriptionId })
    ] })
  ] });
});
var TITLE_NAME3 = "DialogTitle";
var DialogTitle3 = React392.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...titleProps } = props;
  const context = useDialogContext3(TITLE_NAME3, __scopeDialog);
  return /* @__PURE__ */ jsx332(Primitive3.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
});
DialogTitle3.displayName = TITLE_NAME3;
var DESCRIPTION_NAME3 = "DialogDescription";
var DialogDescription3 = React392.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...descriptionProps } = props;
  const context = useDialogContext3(DESCRIPTION_NAME3, __scopeDialog);
  return /* @__PURE__ */ jsx332(Primitive3.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
});
DialogDescription3.displayName = DESCRIPTION_NAME3;
var CLOSE_NAME3 = "DialogClose";
var DialogClose3 = React392.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...closeProps } = props;
  const context = useDialogContext3(CLOSE_NAME3, __scopeDialog);
  return /* @__PURE__ */ jsx332(Primitive3.button, {
    type: "button",
    ...closeProps,
    ref: forwardedRef,
    onClick: composeEventHandlers3(props.onClick, () => context.onOpenChange(false))
  });
});
DialogClose3.displayName = CLOSE_NAME3;
function getState32(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME3 = "DialogTitleWarning";
var [WarningProvider3, useWarningContext3] = createContext24(TITLE_WARNING_NAME3, {
  contentName: CONTENT_NAME6,
  titleName: TITLE_NAME3,
  docsSlug: "dialog"
});
var TitleWarning3 = ({ titleId }) => {
  const titleWarningContext = useWarningContext3(TITLE_WARNING_NAME3);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React392.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME3 = "DialogDescriptionWarning";
var DescriptionWarning3 = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext3(DESCRIPTION_WARNING_NAME3);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React392.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root62 = Dialog3;
var Trigger4 = DialogTrigger3;
var Portal4 = DialogPortal3;
var Overlay2 = DialogOverlay3;
var Content52 = DialogContent3;
var Title = DialogTitle3;
var Description = DialogDescription3;
var Close = DialogClose3;
var ROOT_NAME = "AlertDialog";
var [createAlertDialogContext, createAlertDialogScope] = createContextScope3(ROOT_NAME, [
  createDialogScope3
]);
var useDialogScope = createDialogScope3();
var AlertDialog = (props) => {
  const { __scopeAlertDialog, ...alertDialogProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsx342(Root62, { ...dialogScope, ...alertDialogProps, modal: true });
};
AlertDialog.displayName = ROOT_NAME;
var TRIGGER_NAME6 = "AlertDialogTrigger";
var AlertDialogTrigger = React402.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...triggerProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsx342(Trigger4, { ...dialogScope, ...triggerProps, ref: forwardedRef });
});
AlertDialogTrigger.displayName = TRIGGER_NAME6;
var PORTAL_NAME52 = "AlertDialogPortal";
var AlertDialogPortal = (props) => {
  const { __scopeAlertDialog, ...portalProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsx342(Portal4, { ...dialogScope, ...portalProps });
};
AlertDialogPortal.displayName = PORTAL_NAME52;
var OVERLAY_NAME22 = "AlertDialogOverlay";
var AlertDialogOverlay = React402.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...overlayProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsx342(Overlay2, { ...dialogScope, ...overlayProps, ref: forwardedRef });
});
AlertDialogOverlay.displayName = OVERLAY_NAME22;
var CONTENT_NAME72 = "AlertDialogContent";
var [AlertDialogContentProvider, useAlertDialogContentContext] = createAlertDialogContext(CONTENT_NAME72);
var Slottable2 = createSlottable("AlertDialogContent");
var AlertDialogContent = React402.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, children, ...contentProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  const contentRef = React402.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, contentRef);
  const cancelRef = React402.useRef(null);
  return /* @__PURE__ */ jsx342(WarningProvider3, {
    contentName: CONTENT_NAME72,
    titleName: TITLE_NAME22,
    docsSlug: "alert-dialog",
    children: /* @__PURE__ */ jsx342(AlertDialogContentProvider, { scope: __scopeAlertDialog, cancelRef, children: /* @__PURE__ */ jsxs12(Content52, {
      role: "alertdialog",
      ...dialogScope,
      ...contentProps,
      ref: composedRefs,
      onOpenAutoFocus: composeEventHandlers3(contentProps.onOpenAutoFocus, (event) => {
        event.preventDefault();
        cancelRef.current?.focus({ preventScroll: true });
      }),
      onPointerDownOutside: (event) => event.preventDefault(),
      onInteractOutside: (event) => event.preventDefault(),
      children: [
        /* @__PURE__ */ jsx342(Slottable2, { children }),
        /* @__PURE__ */ jsx342(DescriptionWarning22, { contentRef })
      ]
    }) })
  });
});
AlertDialogContent.displayName = CONTENT_NAME72;
var TITLE_NAME22 = "AlertDialogTitle";
var AlertDialogTitle = React402.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...titleProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsx342(Title, { ...dialogScope, ...titleProps, ref: forwardedRef });
});
AlertDialogTitle.displayName = TITLE_NAME22;
var DESCRIPTION_NAME22 = "AlertDialogDescription";
var AlertDialogDescription = React402.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...descriptionProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsx342(Description, { ...dialogScope, ...descriptionProps, ref: forwardedRef });
});
AlertDialogDescription.displayName = DESCRIPTION_NAME22;
var ACTION_NAME = "AlertDialogAction";
var AlertDialogAction = React402.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...actionProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsx342(Close, { ...dialogScope, ...actionProps, ref: forwardedRef });
});
AlertDialogAction.displayName = ACTION_NAME;
var CANCEL_NAME = "AlertDialogCancel";
var AlertDialogCancel = React402.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...cancelProps } = props;
  const { cancelRef } = useAlertDialogContentContext(CANCEL_NAME, __scopeAlertDialog);
  const dialogScope = useDialogScope(__scopeAlertDialog);
  const ref = useComposedRefs3(forwardedRef, cancelRef);
  return /* @__PURE__ */ jsx342(Close, { ...dialogScope, ...cancelProps, ref });
});
AlertDialogCancel.displayName = CANCEL_NAME;
var DescriptionWarning22 = ({ contentRef }) => {
  const MESSAGE = `\`${CONTENT_NAME72}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${CONTENT_NAME72}\` by passing a \`${DESCRIPTION_NAME22}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${CONTENT_NAME72}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
  React402.useEffect(() => {
    const hasDescription = document.getElementById(contentRef.current?.getAttribute("aria-describedby"));
    if (!hasDescription)
      console.warn(MESSAGE);
  }, [MESSAGE, contentRef]);
  return null;
};
var Root24 = AlertDialog;
var Trigger23 = AlertDialogTrigger;
var Portal222 = AlertDialogPortal;
var Overlay22 = AlertDialogOverlay;
var Content24 = AlertDialogContent;
var Action = AlertDialogAction;
var Cancel = AlertDialogCancel;
var Title2 = AlertDialogTitle;
var Description2 = AlertDialogDescription;
function AlertDialog2({ ...props }) {
  return /* @__PURE__ */ jsx352(Root24, {
    "data-slot": "alert-dialog",
    ...props
  });
}
function AlertDialogTrigger2({ ...props }) {
  return /* @__PURE__ */ jsx352(Trigger23, {
    "data-slot": "alert-dialog-trigger",
    ...props
  });
}
function AlertDialogPortal2({ ...props }) {
  return /* @__PURE__ */ jsx352(Portal222, {
    "data-slot": "alert-dialog-portal",
    ...props
  });
}
function AlertDialogOverlay2({ className, ...props }) {
  return /* @__PURE__ */ jsx352(Overlay22, {
    "data-slot": "alert-dialog-overlay",
    className: clsx92("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50 data-[state=closed]:animate-out data-[state=open]:animate-in", className),
    ...props
  });
}
function AlertDialogContent2({ className, ...props }) {
  return /* @__PURE__ */ jsxs13(AlertDialogPortal2, {
    children: [
      /* @__PURE__ */ jsx352(AlertDialogOverlay2, {}),
      /* @__PURE__ */ jsx352(Content24, {
        "data-slot": "alert-dialog-content",
        className: clsx92("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=open]:animate-in sm:max-w-lg", className),
        ...props
      })
    ]
  });
}
function AlertDialogHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx352("div", {
    "data-slot": "alert-dialog-header",
    className: clsx92("flex flex-col gap-2 text-center sm:text-left", className),
    ...props
  });
}
function AlertDialogFooter({ className, ...props }) {
  return /* @__PURE__ */ jsx352("div", {
    "data-slot": "alert-dialog-footer",
    className: clsx92("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className),
    ...props
  });
}
function AlertDialogTitle2({ className, ...props }) {
  return /* @__PURE__ */ jsx352(Title2, {
    "data-slot": "alert-dialog-title",
    className: clsx92("font-semibold text-lg", className),
    ...props
  });
}
function AlertDialogDescription2({ className, ...props }) {
  return /* @__PURE__ */ jsx352(Description2, {
    "data-slot": "alert-dialog-description",
    className: clsx92("text-muted-foreground text-sm", className),
    ...props
  });
}
function AlertDialogAction2({ className, ...props }) {
  return /* @__PURE__ */ jsx352(Action, {
    className: clsx92(buttonVariants2(), className),
    ...props
  });
}
function AlertDialogCancel2({ className, ...props }) {
  return /* @__PURE__ */ jsx352(Cancel, {
    className: clsx92(buttonVariants2({ variant: "outline" }), className),
    ...props
  });
}
var NAME3 = "AspectRatio";
var AspectRatio = React422.forwardRef((props, forwardedRef) => {
  const { ratio = 1 / 1, style, ...aspectRatioProps } = props;
  return /* @__PURE__ */ jsx392("div", {
    style: {
      position: "relative",
      width: "100%",
      paddingBottom: `${100 / ratio}%`
    },
    "data-radix-aspect-ratio-wrapper": "",
    children: /* @__PURE__ */ jsx392(Primitive3.div, {
      ...aspectRatioProps,
      ref: forwardedRef,
      style: {
        ...style,
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    })
  });
});
AspectRatio.displayName = NAME3;
var import_shim2 = __toESM3(require_shim2(), 1);
function useIsHydrated2() {
  return import_shim2.useSyncExternalStore(subscribe2, () => true, () => false);
}
function subscribe2() {
  return () => {};
}
var AVATAR_NAME = "Avatar";
var [createAvatarContext, createAvatarScope] = createContextScope3(AVATAR_NAME);
var [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
var Avatar = React442.forwardRef((props, forwardedRef) => {
  const { __scopeAvatar, ...avatarProps } = props;
  const [imageLoadingStatus, setImageLoadingStatus] = React442.useState("idle");
  return /* @__PURE__ */ jsx422(AvatarProvider, {
    scope: __scopeAvatar,
    imageLoadingStatus,
    onImageLoadingStatusChange: setImageLoadingStatus,
    children: /* @__PURE__ */ jsx422(Primitive3.span, { ...avatarProps, ref: forwardedRef })
  });
});
Avatar.displayName = AVATAR_NAME;
var IMAGE_NAME = "AvatarImage";
var AvatarImage = React442.forwardRef((props, forwardedRef) => {
  const { __scopeAvatar, src, onLoadingStatusChange = () => {}, ...imageProps } = props;
  const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
  const imageLoadingStatus = useImageLoadingStatus(src, imageProps);
  const handleLoadingStatusChange = useCallbackRef6((status) => {
    onLoadingStatusChange(status);
    context.onImageLoadingStatusChange(status);
  });
  useLayoutEffect24(() => {
    if (imageLoadingStatus !== "idle") {
      handleLoadingStatusChange(imageLoadingStatus);
    }
  }, [imageLoadingStatus, handleLoadingStatusChange]);
  return imageLoadingStatus === "loaded" ? /* @__PURE__ */ jsx422(Primitive3.img, { ...imageProps, ref: forwardedRef, src }) : null;
});
AvatarImage.displayName = IMAGE_NAME;
var FALLBACK_NAME = "AvatarFallback";
var AvatarFallback = React442.forwardRef((props, forwardedRef) => {
  const { __scopeAvatar, delayMs, ...fallbackProps } = props;
  const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
  const [canRender, setCanRender] = React442.useState(delayMs === undefined);
  React442.useEffect(() => {
    if (delayMs !== undefined) {
      const timerId = window.setTimeout(() => setCanRender(true), delayMs);
      return () => window.clearTimeout(timerId);
    }
  }, [delayMs]);
  return canRender && context.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ jsx422(Primitive3.span, { ...fallbackProps, ref: forwardedRef }) : null;
});
AvatarFallback.displayName = FALLBACK_NAME;
function resolveLoadingStatus(image, src) {
  if (!image) {
    return "idle";
  }
  if (!src) {
    return "error";
  }
  if (image.src !== src) {
    image.src = src;
  }
  return image.complete && image.naturalWidth > 0 ? "loaded" : "loading";
}
function useImageLoadingStatus(src, { referrerPolicy, crossOrigin }) {
  const isHydrated = useIsHydrated2();
  const imageRef = React442.useRef(null);
  const image = (() => {
    if (!isHydrated)
      return null;
    if (!imageRef.current) {
      imageRef.current = new window.Image;
    }
    return imageRef.current;
  })();
  const [loadingStatus, setLoadingStatus] = React442.useState(() => resolveLoadingStatus(image, src));
  useLayoutEffect24(() => {
    setLoadingStatus(resolveLoadingStatus(image, src));
  }, [image, src]);
  useLayoutEffect24(() => {
    const updateStatus = (status) => () => {
      setLoadingStatus(status);
    };
    if (!image)
      return;
    const handleLoad = updateStatus("loaded");
    const handleError = updateStatus("error");
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (referrerPolicy) {
      image.referrerPolicy = referrerPolicy;
    }
    if (typeof crossOrigin === "string") {
      image.crossOrigin = crossOrigin;
    }
    return () => {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    };
  }, [image, crossOrigin, referrerPolicy]);
  return loadingStatus;
}
var Root82 = Avatar;
var Image2 = AvatarImage;
var Fallback = AvatarFallback;
function Avatar2({ className, ...props }) {
  return /* @__PURE__ */ jsx432(Root82, {
    "data-slot": "avatar",
    className: clsx12("relative flex size-8 shrink-0 overflow-hidden rounded-full", className),
    ...props
  });
}
function AvatarImage2({ className, ...props }) {
  return /* @__PURE__ */ jsx432(Image2, {
    "data-slot": "avatar-image",
    className: clsx12("aspect-square size-full", className),
    ...props
  });
}
function AvatarFallback2({ className, ...props }) {
  return /* @__PURE__ */ jsx432(Fallback, {
    "data-slot": "avatar-fallback",
    className: clsx12("flex size-full items-center justify-center rounded-full bg-muted", className),
    ...props
  });
}
var badgeVariants = cva("inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden", {
  variants: {
    variant: {
      default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
      secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
      destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
      outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground"
    }
  },
  defaultVariants: {
    variant: "default"
  }
});
function Badge({ className, variant, asChild = false, ...props }) {
  const Comp = asChild ? Slot4 : "span";
  return /* @__PURE__ */ jsx45(Comp, {
    "data-slot": "badge",
    className: clsx13(badgeVariants({ variant }), className),
    ...props
  });
}
function Breadcrumb({ ...props }) {
  return /* @__PURE__ */ jsx50("nav", {
    "aria-label": "breadcrumb",
    "data-slot": "breadcrumb",
    ...props
  });
}
function BreadcrumbList({ className, ...props }) {
  return /* @__PURE__ */ jsx50("ol", {
    "data-slot": "breadcrumb-list",
    className: clsx14("flex flex-wrap items-center gap-1.5 break-words text-muted-foreground text-sm sm:gap-2.5", className),
    ...props
  });
}
function BreadcrumbItem({ className, ...props }) {
  return /* @__PURE__ */ jsx50("li", {
    "data-slot": "breadcrumb-item",
    className: clsx14("inline-flex items-center gap-1.5", className),
    ...props
  });
}
function BreadcrumbLink({
  asChild,
  className,
  ...props
}) {
  const Comp = asChild ? Slot4 : "a";
  return /* @__PURE__ */ jsx50(Comp, {
    "data-slot": "breadcrumb-link",
    className: clsx14("transition-colors hover:text-foreground", className),
    ...props
  });
}
function BreadcrumbPage({ className, ...props }) {
  return /* @__PURE__ */ jsx50("span", {
    "data-slot": "breadcrumb-page",
    role: "link",
    "aria-disabled": "true",
    "aria-current": "page",
    className: clsx14("font-normal text-foreground", className),
    ...props
  });
}
function BreadcrumbSeparator({ children, className, ...props }) {
  return /* @__PURE__ */ jsx50("li", {
    "data-slot": "breadcrumb-separator",
    role: "presentation",
    "aria-hidden": "true",
    className: clsx14("[&>svg]:size-3.5", className),
    ...props,
    children: children ?? /* @__PURE__ */ jsx50(SvgIcon4, {
      iconId: "ChevronRight"
    })
  });
}
function BreadcrumbEllipsis({ className, ...props }) {
  return /* @__PURE__ */ jsxs17("span", {
    "data-slot": "breadcrumb-ellipsis",
    role: "presentation",
    "aria-hidden": "true",
    className: clsx14("flex size-9 items-center justify-center", className),
    ...props,
    children: [
      /* @__PURE__ */ jsx50(SvgIcon4, {
        iconId: "Ellipsis",
        className: "size-4"
      }),
      /* @__PURE__ */ jsx50("span", {
        className: "sr-only",
        children: "More"
      })
    ]
  });
}
var ENTRY_FOCUS3 = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS22 = { bubbles: false, cancelable: true };
var GROUP_NAME22 = "RovingFocusGroup";
var [Collection32, useCollection32, createCollectionScope32] = createCollection3(GROUP_NAME22);
var [createRovingFocusGroupContext3, createRovingFocusGroupScope3] = createContextScope3(GROUP_NAME22, [createCollectionScope32]);
var [RovingFocusProvider3, useRovingFocusContext3] = createRovingFocusGroupContext3(GROUP_NAME22);
var RovingFocusGroup3 = React452.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsx51(Collection32.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx51(Collection32.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx51(RovingFocusGroupImpl3, { ...props, ref: forwardedRef }) }) });
});
RovingFocusGroup3.displayName = GROUP_NAME22;
var RovingFocusGroupImpl3 = React452.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React452.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  const direction = useDirection3(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState3({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME22
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React452.useState(false);
  const handleEntryFocus = useCallbackRef6(onEntryFocus);
  const getItems = useCollection32(__scopeRovingFocusGroup);
  const isClickFocusRef = React452.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React452.useState(0);
  React452.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS3, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS3, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsx51(RovingFocusProvider3, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction,
    loop,
    currentTabStopId,
    onItemFocus: React452.useCallback((tabStopId) => setCurrentTabStopId(tabStopId), [setCurrentTabStopId]),
    onItemShiftTab: React452.useCallback(() => setIsTabbingBackOut(true), []),
    onFocusableItemAdd: React452.useCallback(() => setFocusableItemsCount((prevCount) => prevCount + 1), []),
    onFocusableItemRemove: React452.useCallback(() => setFocusableItemsCount((prevCount) => prevCount - 1), []),
    children: /* @__PURE__ */ jsx51(Primitive3.div, {
      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
      "data-orientation": orientation,
      ...groupProps,
      ref: composedRefs,
      style: { outline: "none", ...props.style },
      onMouseDown: composeEventHandlers3(props.onMouseDown, () => {
        isClickFocusRef.current = true;
      }),
      onFocus: composeEventHandlers3(props.onFocus, (event) => {
        const isKeyboardFocus = !isClickFocusRef.current;
        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
          const entryFocusEvent = new CustomEvent(ENTRY_FOCUS3, EVENT_OPTIONS22);
          event.currentTarget.dispatchEvent(entryFocusEvent);
          if (!entryFocusEvent.defaultPrevented) {
            const items = getItems().filter((item) => item.focusable);
            const activeItem = items.find((item) => item.active);
            const currentItem = items.find((item) => item.id === currentTabStopId);
            const candidateItems = [activeItem, currentItem, ...items].filter(Boolean);
            const candidateNodes = candidateItems.map((item) => item.ref.current);
            focusFirst22(candidateNodes, preventScrollOnEntryFocus);
          }
        }
        isClickFocusRef.current = false;
      }),
      onBlur: composeEventHandlers3(props.onBlur, () => setIsTabbingBackOut(false))
    })
  });
});
var ITEM_NAME32 = "RovingFocusGroupItem";
var RovingFocusGroupItem3 = React452.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    focusable = true,
    active = false,
    tabStopId,
    children,
    ...itemProps
  } = props;
  const autoId = useId3();
  const id = tabStopId || autoId;
  const context = useRovingFocusContext3(ITEM_NAME32, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = useCollection32(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
  React452.useEffect(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
  return /* @__PURE__ */ jsx51(Collection32.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id,
    focusable,
    active,
    children: /* @__PURE__ */ jsx51(Primitive3.span, {
      tabIndex: isCurrentTabStop ? 0 : -1,
      "data-orientation": context.orientation,
      ...itemProps,
      ref: forwardedRef,
      onMouseDown: composeEventHandlers3(props.onMouseDown, (event) => {
        if (!focusable)
          event.preventDefault();
        else
          context.onItemFocus(id);
      }),
      onFocus: composeEventHandlers3(props.onFocus, () => context.onItemFocus(id)),
      onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
        if (event.key === "Tab" && event.shiftKey) {
          context.onItemShiftTab();
          return;
        }
        if (event.target !== event.currentTarget)
          return;
        const focusIntent = getFocusIntent3(event, context.orientation, context.dir);
        if (focusIntent !== undefined) {
          if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)
            return;
          event.preventDefault();
          const items = getItems().filter((item) => item.focusable);
          let candidateNodes = items.map((item) => item.ref.current);
          if (focusIntent === "last")
            candidateNodes.reverse();
          else if (focusIntent === "prev" || focusIntent === "next") {
            if (focusIntent === "prev")
              candidateNodes.reverse();
            const currentIndex = candidateNodes.indexOf(event.currentTarget);
            candidateNodes = context.loop ? wrapArray22(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
          }
          setTimeout(() => focusFirst22(candidateNodes));
        }
      }),
      children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
    })
  });
});
RovingFocusGroupItem3.displayName = ITEM_NAME32;
var MAP_KEY_TO_FOCUS_INTENT3 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey3(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent3(event, orientation, dir) {
  const key = getDirectionAwareKey3(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return;
  return MAP_KEY_TO_FOCUS_INTENT3[key];
}
function focusFirst22(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray22(array, startIndex) {
  return array.map((_2, index22) => array[(startIndex + index22) % array.length]);
}
var Root9 = RovingFocusGroup3;
var Item32 = RovingFocusGroupItem3;
var SELECTION_KEYS22 = ["Enter", " "];
var FIRST_KEYS2 = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS2 = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS2 = [...FIRST_KEYS2, ...LAST_KEYS2];
var SUB_OPEN_KEYS2 = {
  ltr: [...SELECTION_KEYS22, "ArrowRight"],
  rtl: [...SELECTION_KEYS22, "ArrowLeft"]
};
var SUB_CLOSE_KEYS2 = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME3 = "Menu";
var [Collection42, useCollection42, createCollectionScope42] = createCollection3(MENU_NAME3);
var [createMenuContext2, createMenuScope2] = createContextScope3(MENU_NAME3, [
  createCollectionScope42,
  createPopperScope2,
  createRovingFocusGroupScope3
]);
var usePopperScope3 = createPopperScope2();
var useRovingFocusGroupScope5 = createRovingFocusGroupScope3();
var [MenuProvider2, useMenuContext2] = createMenuContext2(MENU_NAME3);
var [MenuRootProvider2, useMenuRootContext2] = createMenuContext2(MENU_NAME3);
var Menu2 = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope3(__scopeMenu);
  const [content, setContent] = React462.useState(null);
  const isUsingKeyboardRef = React462.useRef(false);
  const handleOpenChange = useCallbackRef6(onOpenChange);
  const direction = useDirection3(dir);
  React462.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsx522(Root22, { ...popperScope, children: /* @__PURE__ */ jsx522(MenuProvider2, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent,
    children: /* @__PURE__ */ jsx522(MenuRootProvider2, {
      scope: __scopeMenu,
      onClose: React462.useCallback(() => handleOpenChange(false), [handleOpenChange]),
      isUsingKeyboardRef,
      dir: direction,
      modal,
      children
    })
  }) });
};
Menu2.displayName = MENU_NAME3;
var ANCHOR_NAME22 = "MenuAnchor";
var MenuAnchor2 = React462.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...anchorProps } = props;
  const popperScope = usePopperScope3(__scopeMenu);
  return /* @__PURE__ */ jsx522(Anchor3, { ...popperScope, ...anchorProps, ref: forwardedRef });
});
MenuAnchor2.displayName = ANCHOR_NAME22;
var PORTAL_NAME6 = "MenuPortal";
var [PortalProvider32, usePortalContext32] = createMenuContext2(PORTAL_NAME6, {
  forceMount: undefined
});
var MenuPortal2 = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext2(PORTAL_NAME6, __scopeMenu);
  return /* @__PURE__ */ jsx522(PortalProvider32, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsx522(Presence3, { present: forceMount || context.open, children: /* @__PURE__ */ jsx522(Portal6, { asChild: true, container, children }) }) });
};
MenuPortal2.displayName = PORTAL_NAME6;
var CONTENT_NAME8 = "MenuContent";
var [MenuContentProvider2, useMenuContentContext2] = createMenuContext2(CONTENT_NAME8);
var MenuContent2 = React462.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext32(CONTENT_NAME8, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = useMenuContext2(CONTENT_NAME8, props.__scopeMenu);
  const rootContext = useMenuRootContext2(CONTENT_NAME8, props.__scopeMenu);
  return /* @__PURE__ */ jsx522(Collection42.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsx522(Presence3, { present: forceMount || context.open, children: /* @__PURE__ */ jsx522(Collection42.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsx522(MenuRootContentModal2, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx522(MenuRootContentNonModal2, { ...contentProps, ref: forwardedRef }) }) }) });
});
var MenuRootContentModal2 = React462.forwardRef((props, forwardedRef) => {
  const context = useMenuContext2(CONTENT_NAME8, props.__scopeMenu);
  const ref = React462.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  React462.useEffect(() => {
    const content = ref.current;
    if (content)
      return hideOthers3(content);
  }, []);
  return /* @__PURE__ */ jsx522(MenuContentImpl2, {
    ...props,
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: context.open,
    disableOutsideScroll: true,
    onFocusOutside: composeEventHandlers3(props.onFocusOutside, (event) => event.preventDefault(), { checkForDefaultPrevented: false }),
    onDismiss: () => context.onOpenChange(false)
  });
});
var MenuRootContentNonModal2 = React462.forwardRef((props, forwardedRef) => {
  const context = useMenuContext2(CONTENT_NAME8, props.__scopeMenu);
  return /* @__PURE__ */ jsx522(MenuContentImpl2, {
    ...props,
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    onDismiss: () => context.onOpenChange(false)
  });
});
var Slot42 = createSlot3("MenuContent.ScrollLock");
var MenuContentImpl2 = React462.forwardRef((props, forwardedRef) => {
  const {
    __scopeMenu,
    loop = false,
    trapFocus,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    onEntryFocus,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss,
    disableOutsideScroll,
    ...contentProps
  } = props;
  const context = useMenuContext2(CONTENT_NAME8, __scopeMenu);
  const rootContext = useMenuRootContext2(CONTENT_NAME8, __scopeMenu);
  const popperScope = usePopperScope3(__scopeMenu);
  const rovingFocusGroupScope = useRovingFocusGroupScope5(__scopeMenu);
  const getItems = useCollection42(__scopeMenu);
  const [currentItemId, setCurrentItemId] = React462.useState(null);
  const contentRef = React462.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, contentRef, context.onContentChange);
  const timerRef = React462.useRef(0);
  const searchRef = React462.useRef("");
  const pointerGraceTimerRef = React462.useRef(0);
  const pointerGraceIntentRef = React462.useRef(null);
  const pointerDirRef = React462.useRef("right");
  const lastPointerXRef = React462.useRef(0);
  const ScrollLockWrapper = disableOutsideScroll ? Combination_default3 : React462.Fragment;
  const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot42, allowPinchZoom: true } : undefined;
  const handleTypeaheadSearch = (key) => {
    const search = searchRef.current + key;
    const items = getItems().filter((item) => !item.disabled);
    const currentItem = document.activeElement;
    const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;
    const values = items.map((item) => item.textValue);
    const nextMatch = getNextMatch2(values, search, currentMatch);
    const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;
    (function updateSearch(value) {
      searchRef.current = value;
      window.clearTimeout(timerRef.current);
      if (value !== "")
        timerRef.current = window.setTimeout(() => updateSearch(""), 1000);
    })(search);
    if (newItem) {
      setTimeout(() => newItem.focus());
    }
  };
  React462.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  useFocusGuards3();
  const isPointerMovingToSubmenu = React462.useCallback((event) => {
    const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;
    return isMovingTowards && isPointerInGraceArea2(event, pointerGraceIntentRef.current?.area);
  }, []);
  return /* @__PURE__ */ jsx522(MenuContentProvider2, {
    scope: __scopeMenu,
    searchRef,
    onItemEnter: React462.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [isPointerMovingToSubmenu]),
    onItemLeave: React462.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        return;
      contentRef.current?.focus();
      setCurrentItemId(null);
    }, [isPointerMovingToSubmenu]),
    onTriggerLeave: React462.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [isPointerMovingToSubmenu]),
    pointerGraceTimerRef,
    onPointerGraceIntentChange: React462.useCallback((intent) => {
      pointerGraceIntentRef.current = intent;
    }, []),
    children: /* @__PURE__ */ jsx522(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsx522(FocusScope3, {
      asChild: true,
      trapped: trapFocus,
      onMountAutoFocus: composeEventHandlers3(onOpenAutoFocus, (event) => {
        event.preventDefault();
        contentRef.current?.focus({ preventScroll: true });
      }),
      onUnmountAutoFocus: onCloseAutoFocus,
      children: /* @__PURE__ */ jsx522(DismissableLayer3, {
        asChild: true,
        disableOutsidePointerEvents,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        children: /* @__PURE__ */ jsx522(Root9, {
          asChild: true,
          ...rovingFocusGroupScope,
          dir: rootContext.dir,
          orientation: "vertical",
          loop,
          currentTabStopId: currentItemId,
          onCurrentTabStopIdChange: setCurrentItemId,
          onEntryFocus: composeEventHandlers3(onEntryFocus, (event) => {
            if (!rootContext.isUsingKeyboardRef.current)
              event.preventDefault();
          }),
          preventScrollOnEntryFocus: true,
          children: /* @__PURE__ */ jsx522(Content5, {
            role: "menu",
            "aria-orientation": "vertical",
            "data-state": getOpenState2(context.open),
            "data-radix-menu-content": "",
            dir: rootContext.dir,
            ...popperScope,
            ...contentProps,
            ref: composedRefs,
            style: { outline: "none", ...contentProps.style },
            onKeyDown: composeEventHandlers3(contentProps.onKeyDown, (event) => {
              const target = event.target;
              const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
              const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
              const isCharacterKey = event.key.length === 1;
              if (isKeyDownInside) {
                if (event.key === "Tab")
                  event.preventDefault();
                if (!isModifierKey && isCharacterKey)
                  handleTypeaheadSearch(event.key);
              }
              const content = contentRef.current;
              if (event.target !== content)
                return;
              if (!FIRST_LAST_KEYS2.includes(event.key))
                return;
              event.preventDefault();
              const items = getItems().filter((item) => !item.disabled);
              const candidateNodes = items.map((item) => item.ref.current);
              if (LAST_KEYS2.includes(event.key))
                candidateNodes.reverse();
              focusFirst32(candidateNodes);
            }),
            onBlur: composeEventHandlers3(props.onBlur, (event) => {
              if (!event.currentTarget.contains(event.target)) {
                window.clearTimeout(timerRef.current);
                searchRef.current = "";
              }
            }),
            onPointerMove: composeEventHandlers3(props.onPointerMove, whenMouse2((event) => {
              const target = event.target;
              const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
              if (event.currentTarget.contains(target) && pointerXHasChanged) {
                const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                pointerDirRef.current = newDir;
                lastPointerXRef.current = event.clientX;
              }
            }))
          })
        })
      })
    }) })
  });
});
MenuContent2.displayName = CONTENT_NAME8;
var GROUP_NAME32 = "MenuGroup";
var MenuGroup2 = React462.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...groupProps } = props;
  return /* @__PURE__ */ jsx522(Primitive3.div, { role: "group", ...groupProps, ref: forwardedRef });
});
MenuGroup2.displayName = GROUP_NAME32;
var LABEL_NAME22 = "MenuLabel";
var MenuLabel2 = React462.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...labelProps } = props;
  return /* @__PURE__ */ jsx522(Primitive3.div, { ...labelProps, ref: forwardedRef });
});
MenuLabel2.displayName = LABEL_NAME22;
var ITEM_NAME42 = "MenuItem";
var ITEM_SELECT2 = "menu.itemSelect";
var MenuItem2 = React462.forwardRef((props, forwardedRef) => {
  const { disabled = false, onSelect, ...itemProps } = props;
  const ref = React462.useRef(null);
  const rootContext = useMenuRootContext2(ITEM_NAME42, props.__scopeMenu);
  const contentContext = useMenuContentContext2(ITEM_NAME42, props.__scopeMenu);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  const isPointerDownRef = React462.useRef(false);
  const handleSelect = () => {
    const menuItem = ref.current;
    if (!disabled && menuItem) {
      const itemSelectEvent = new CustomEvent(ITEM_SELECT2, { bubbles: true, cancelable: true });
      menuItem.addEventListener(ITEM_SELECT2, (event) => onSelect?.(event), { once: true });
      dispatchDiscreteCustomEvent3(menuItem, itemSelectEvent);
      if (itemSelectEvent.defaultPrevented) {
        isPointerDownRef.current = false;
      } else {
        rootContext.onClose();
      }
    }
  };
  return /* @__PURE__ */ jsx522(MenuItemImpl2, {
    ...itemProps,
    ref: composedRefs,
    disabled,
    onClick: composeEventHandlers3(props.onClick, handleSelect),
    onPointerDown: (event) => {
      props.onPointerDown?.(event);
      isPointerDownRef.current = true;
    },
    onPointerUp: composeEventHandlers3(props.onPointerUp, (event) => {
      if (!isPointerDownRef.current)
        event.currentTarget?.click();
    }),
    onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (disabled || isTypingAhead && event.key === " ")
        return;
      if (SELECTION_KEYS22.includes(event.key)) {
        event.currentTarget.click();
        event.preventDefault();
      }
    })
  });
});
MenuItem2.displayName = ITEM_NAME42;
var MenuItemImpl2 = React462.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
  const contentContext = useMenuContentContext2(ITEM_NAME42, __scopeMenu);
  const rovingFocusGroupScope = useRovingFocusGroupScope5(__scopeMenu);
  const ref = React462.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  const [isFocused, setIsFocused] = React462.useState(false);
  const [textContent, setTextContent] = React462.useState("");
  React462.useEffect(() => {
    const menuItem = ref.current;
    if (menuItem) {
      setTextContent((menuItem.textContent ?? "").trim());
    }
  }, [itemProps.children]);
  return /* @__PURE__ */ jsx522(Collection42.ItemSlot, {
    scope: __scopeMenu,
    disabled,
    textValue: textValue ?? textContent,
    children: /* @__PURE__ */ jsx522(Item32, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsx522(Primitive3.div, {
      role: "menuitem",
      "data-highlighted": isFocused ? "" : undefined,
      "aria-disabled": disabled || undefined,
      "data-disabled": disabled ? "" : undefined,
      ...itemProps,
      ref: composedRefs,
      onPointerMove: composeEventHandlers3(props.onPointerMove, whenMouse2((event) => {
        if (disabled) {
          contentContext.onItemLeave(event);
        } else {
          contentContext.onItemEnter(event);
          if (!event.defaultPrevented) {
            const item = event.currentTarget;
            item.focus({ preventScroll: true });
          }
        }
      })),
      onPointerLeave: composeEventHandlers3(props.onPointerLeave, whenMouse2((event) => contentContext.onItemLeave(event))),
      onFocus: composeEventHandlers3(props.onFocus, () => setIsFocused(true)),
      onBlur: composeEventHandlers3(props.onBlur, () => setIsFocused(false))
    }) })
  });
});
var CHECKBOX_ITEM_NAME3 = "MenuCheckboxItem";
var MenuCheckboxItem2 = React462.forwardRef((props, forwardedRef) => {
  const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
  return /* @__PURE__ */ jsx522(ItemIndicatorProvider2, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsx522(MenuItem2, {
    role: "menuitemcheckbox",
    "aria-checked": isIndeterminate2(checked) ? "mixed" : checked,
    ...checkboxItemProps,
    ref: forwardedRef,
    "data-state": getCheckedState2(checked),
    onSelect: composeEventHandlers3(checkboxItemProps.onSelect, () => onCheckedChange?.(isIndeterminate2(checked) ? true : !checked), { checkForDefaultPrevented: false })
  }) });
});
MenuCheckboxItem2.displayName = CHECKBOX_ITEM_NAME3;
var RADIO_GROUP_NAME3 = "MenuRadioGroup";
var [RadioGroupProvider2, useRadioGroupContext2] = createMenuContext2(RADIO_GROUP_NAME3, { value: undefined, onValueChange: () => {} });
var MenuRadioGroup2 = React462.forwardRef((props, forwardedRef) => {
  const { value, onValueChange, ...groupProps } = props;
  const handleValueChange = useCallbackRef6(onValueChange);
  return /* @__PURE__ */ jsx522(RadioGroupProvider2, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsx522(MenuGroup2, { ...groupProps, ref: forwardedRef }) });
});
MenuRadioGroup2.displayName = RADIO_GROUP_NAME3;
var RADIO_ITEM_NAME3 = "MenuRadioItem";
var MenuRadioItem2 = React462.forwardRef((props, forwardedRef) => {
  const { value, ...radioItemProps } = props;
  const context = useRadioGroupContext2(RADIO_ITEM_NAME3, props.__scopeMenu);
  const checked = value === context.value;
  return /* @__PURE__ */ jsx522(ItemIndicatorProvider2, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsx522(MenuItem2, {
    role: "menuitemradio",
    "aria-checked": checked,
    ...radioItemProps,
    ref: forwardedRef,
    "data-state": getCheckedState2(checked),
    onSelect: composeEventHandlers3(radioItemProps.onSelect, () => context.onValueChange?.(value), { checkForDefaultPrevented: false })
  }) });
});
MenuRadioItem2.displayName = RADIO_ITEM_NAME3;
var ITEM_INDICATOR_NAME22 = "MenuItemIndicator";
var [ItemIndicatorProvider2, useItemIndicatorContext2] = createMenuContext2(ITEM_INDICATOR_NAME22, { checked: false });
var MenuItemIndicator2 = React462.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
  const indicatorContext = useItemIndicatorContext2(ITEM_INDICATOR_NAME22, __scopeMenu);
  return /* @__PURE__ */ jsx522(Presence3, {
    present: forceMount || isIndeterminate2(indicatorContext.checked) || indicatorContext.checked === true,
    children: /* @__PURE__ */ jsx522(Primitive3.span, {
      ...itemIndicatorProps,
      ref: forwardedRef,
      "data-state": getCheckedState2(indicatorContext.checked)
    })
  });
});
MenuItemIndicator2.displayName = ITEM_INDICATOR_NAME22;
var SEPARATOR_NAME22 = "MenuSeparator";
var MenuSeparator2 = React462.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...separatorProps } = props;
  return /* @__PURE__ */ jsx522(Primitive3.div, {
    role: "separator",
    "aria-orientation": "horizontal",
    ...separatorProps,
    ref: forwardedRef
  });
});
MenuSeparator2.displayName = SEPARATOR_NAME22;
var ARROW_NAME42 = "MenuArrow";
var MenuArrow2 = React462.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...arrowProps } = props;
  const popperScope = usePopperScope3(__scopeMenu);
  return /* @__PURE__ */ jsx522(Arrow23, { ...popperScope, ...arrowProps, ref: forwardedRef });
});
MenuArrow2.displayName = ARROW_NAME42;
var SUB_NAME3 = "MenuSub";
var [MenuSubProvider2, useMenuSubContext2] = createMenuContext2(SUB_NAME3);
var MenuSub2 = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext2(SUB_NAME3, __scopeMenu);
  const popperScope = usePopperScope3(__scopeMenu);
  const [trigger, setTrigger] = React462.useState(null);
  const [content, setContent] = React462.useState(null);
  const handleOpenChange = useCallbackRef6(onOpenChange);
  React462.useEffect(() => {
    if (parentMenuContext.open === false)
      handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return /* @__PURE__ */ jsx522(Root22, { ...popperScope, children: /* @__PURE__ */ jsx522(MenuProvider2, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent,
    children: /* @__PURE__ */ jsx522(MenuSubProvider2, {
      scope: __scopeMenu,
      contentId: useId3(),
      triggerId: useId3(),
      trigger,
      onTriggerChange: setTrigger,
      children
    })
  }) });
};
MenuSub2.displayName = SUB_NAME3;
var SUB_TRIGGER_NAME3 = "MenuSubTrigger";
var MenuSubTrigger2 = React462.forwardRef((props, forwardedRef) => {
  const context = useMenuContext2(SUB_TRIGGER_NAME3, props.__scopeMenu);
  const rootContext = useMenuRootContext2(SUB_TRIGGER_NAME3, props.__scopeMenu);
  const subContext = useMenuSubContext2(SUB_TRIGGER_NAME3, props.__scopeMenu);
  const contentContext = useMenuContentContext2(SUB_TRIGGER_NAME3, props.__scopeMenu);
  const openTimerRef = React462.useRef(null);
  const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
  const scope = { __scopeMenu: props.__scopeMenu };
  const clearOpenTimer = React462.useCallback(() => {
    if (openTimerRef.current)
      window.clearTimeout(openTimerRef.current);
    openTimerRef.current = null;
  }, []);
  React462.useEffect(() => clearOpenTimer, [clearOpenTimer]);
  React462.useEffect(() => {
    const pointerGraceTimer = pointerGraceTimerRef.current;
    return () => {
      window.clearTimeout(pointerGraceTimer);
      onPointerGraceIntentChange(null);
    };
  }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
  return /* @__PURE__ */ jsx522(MenuAnchor2, { asChild: true, ...scope, children: /* @__PURE__ */ jsx522(MenuItemImpl2, {
    id: subContext.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open,
    "aria-controls": subContext.contentId,
    "data-state": getOpenState2(context.open),
    ...props,
    ref: composeRefs3(forwardedRef, subContext.onTriggerChange),
    onClick: (event) => {
      props.onClick?.(event);
      if (props.disabled || event.defaultPrevented)
        return;
      event.currentTarget.focus();
      if (!context.open)
        context.onOpenChange(true);
    },
    onPointerMove: composeEventHandlers3(props.onPointerMove, whenMouse2((event) => {
      contentContext.onItemEnter(event);
      if (event.defaultPrevented)
        return;
      if (!props.disabled && !context.open && !openTimerRef.current) {
        contentContext.onPointerGraceIntentChange(null);
        openTimerRef.current = window.setTimeout(() => {
          context.onOpenChange(true);
          clearOpenTimer();
        }, 100);
      }
    })),
    onPointerLeave: composeEventHandlers3(props.onPointerLeave, whenMouse2((event) => {
      clearOpenTimer();
      const contentRect = context.content?.getBoundingClientRect();
      if (contentRect) {
        const side = context.content?.dataset.side;
        const rightSide = side === "right";
        const bleed = rightSide ? -5 : 5;
        const contentNearEdge = contentRect[rightSide ? "left" : "right"];
        const contentFarEdge = contentRect[rightSide ? "right" : "left"];
        contentContext.onPointerGraceIntentChange({
          area: [
            { x: event.clientX + bleed, y: event.clientY },
            { x: contentNearEdge, y: contentRect.top },
            { x: contentFarEdge, y: contentRect.top },
            { x: contentFarEdge, y: contentRect.bottom },
            { x: contentNearEdge, y: contentRect.bottom }
          ],
          side
        });
        window.clearTimeout(pointerGraceTimerRef.current);
        pointerGraceTimerRef.current = window.setTimeout(() => contentContext.onPointerGraceIntentChange(null), 300);
      } else {
        contentContext.onTriggerLeave(event);
        if (event.defaultPrevented)
          return;
        contentContext.onPointerGraceIntentChange(null);
      }
    })),
    onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (props.disabled || isTypingAhead && event.key === " ")
        return;
      if (SUB_OPEN_KEYS2[rootContext.dir].includes(event.key)) {
        context.onOpenChange(true);
        context.content?.focus();
        event.preventDefault();
      }
    })
  }) });
});
MenuSubTrigger2.displayName = SUB_TRIGGER_NAME3;
var SUB_CONTENT_NAME3 = "MenuSubContent";
var MenuSubContent2 = React462.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext32(CONTENT_NAME8, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...subContentProps } = props;
  const context = useMenuContext2(CONTENT_NAME8, props.__scopeMenu);
  const rootContext = useMenuRootContext2(CONTENT_NAME8, props.__scopeMenu);
  const subContext = useMenuSubContext2(SUB_CONTENT_NAME3, props.__scopeMenu);
  const ref = React462.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  return /* @__PURE__ */ jsx522(Collection42.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsx522(Presence3, { present: forceMount || context.open, children: /* @__PURE__ */ jsx522(Collection42.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsx522(MenuContentImpl2, {
    id: subContext.contentId,
    "aria-labelledby": subContext.triggerId,
    ...subContentProps,
    ref: composedRefs,
    align: "start",
    side: rootContext.dir === "rtl" ? "left" : "right",
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    trapFocus: false,
    onOpenAutoFocus: (event) => {
      if (rootContext.isUsingKeyboardRef.current)
        ref.current?.focus();
      event.preventDefault();
    },
    onCloseAutoFocus: (event) => event.preventDefault(),
    onFocusOutside: composeEventHandlers3(props.onFocusOutside, (event) => {
      if (event.target !== subContext.trigger)
        context.onOpenChange(false);
    }),
    onEscapeKeyDown: composeEventHandlers3(props.onEscapeKeyDown, (event) => {
      rootContext.onClose();
      event.preventDefault();
    }),
    onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
      const isKeyDownInside = event.currentTarget.contains(event.target);
      const isCloseKey = SUB_CLOSE_KEYS2[rootContext.dir].includes(event.key);
      if (isKeyDownInside && isCloseKey) {
        context.onOpenChange(false);
        subContext.trigger?.focus();
        event.preventDefault();
      }
    })
  }) }) }) });
});
MenuSubContent2.displayName = SUB_CONTENT_NAME3;
function getOpenState2(open) {
  return open ? "open" : "closed";
}
function isIndeterminate2(checked) {
  return checked === "indeterminate";
}
function getCheckedState2(checked) {
  return isIndeterminate2(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst32(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray32(array, startIndex) {
  return array.map((_2, index22) => array[(startIndex + index22) % array.length]);
}
function getNextMatch2(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray32(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find((value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));
  return nextMatch !== currentMatch ? nextMatch : undefined;
}
function isPointInPolygon22(point, polygon) {
  const { x: x2, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1;i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x2 < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea2(event, area) {
  if (!area)
    return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon22(cursorPos, area);
}
function whenMouse2(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : undefined;
}
var Root332 = Menu2;
var Anchor22 = MenuAnchor2;
var Portal52 = MenuPortal2;
var Content25 = MenuContent2;
var Group22 = MenuGroup2;
var Label22 = MenuLabel2;
var Item222 = MenuItem2;
var CheckboxItem2 = MenuCheckboxItem2;
var RadioGroup2 = MenuRadioGroup2;
var RadioItem2 = MenuRadioItem2;
var ItemIndicator22 = MenuItemIndicator2;
var Separator22 = MenuSeparator2;
var Arrow232 = MenuArrow2;
var Sub2 = MenuSub2;
var SubTrigger2 = MenuSubTrigger2;
var SubContent2 = MenuSubContent2;
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope3(DROPDOWN_MENU_NAME, [createMenuScope2]);
var useMenuScope2 = createMenuScope2();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  const triggerRef = React472.useRef(null);
  const [open, setOpen] = useControllableState3({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return /* @__PURE__ */ jsx532(DropdownMenuProvider, {
    scope: __scopeDropdownMenu,
    triggerId: useId3(),
    triggerRef,
    contentId: useId3(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: React472.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
    modal,
    children: /* @__PURE__ */ jsx532(Root332, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
  });
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME7 = "DropdownMenuTrigger";
var DropdownMenuTrigger = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
  const context = useDropdownMenuContext(TRIGGER_NAME7, __scopeDropdownMenu);
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(Anchor22, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsx532(Primitive3.button, {
    type: "button",
    id: context.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open,
    "aria-controls": context.open ? context.contentId : undefined,
    "data-state": context.open ? "open" : "closed",
    "data-disabled": disabled ? "" : undefined,
    disabled,
    ...triggerProps,
    ref: composeRefs3(forwardedRef, context.triggerRef),
    onPointerDown: composeEventHandlers3(props.onPointerDown, (event) => {
      if (!disabled && event.button === 0 && event.ctrlKey === false) {
        context.onOpenToggle();
        if (!context.open)
          event.preventDefault();
      }
    }),
    onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
      if (disabled)
        return;
      if (["Enter", " "].includes(event.key))
        context.onOpenToggle();
      if (event.key === "ArrowDown")
        context.onOpenChange(true);
      if (["Enter", " ", "ArrowDown"].includes(event.key))
        event.preventDefault();
    })
  }) });
});
DropdownMenuTrigger.displayName = TRIGGER_NAME7;
var PORTAL_NAME72 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(Portal52, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME72;
var CONTENT_NAME9 = "DropdownMenuContent";
var DropdownMenuContent = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...contentProps } = props;
  const context = useDropdownMenuContext(CONTENT_NAME9, __scopeDropdownMenu);
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  const hasInteractedOutsideRef = React472.useRef(false);
  return /* @__PURE__ */ jsx532(Content25, {
    id: context.contentId,
    "aria-labelledby": context.triggerId,
    ...menuScope,
    ...contentProps,
    ref: forwardedRef,
    onCloseAutoFocus: composeEventHandlers3(props.onCloseAutoFocus, (event) => {
      if (!hasInteractedOutsideRef.current)
        context.triggerRef.current?.focus();
      hasInteractedOutsideRef.current = false;
      event.preventDefault();
    }),
    onInteractOutside: composeEventHandlers3(props.onInteractOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (!context.modal || isRightClick)
        hasInteractedOutsideRef.current = true;
    }),
    style: {
      ...props.style,
      ...{
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
DropdownMenuContent.displayName = CONTENT_NAME9;
var GROUP_NAME42 = "DropdownMenuGroup";
var DropdownMenuGroup = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...groupProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(Group22, { ...menuScope, ...groupProps, ref: forwardedRef });
});
DropdownMenuGroup.displayName = GROUP_NAME42;
var LABEL_NAME32 = "DropdownMenuLabel";
var DropdownMenuLabel = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...labelProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(Label22, { ...menuScope, ...labelProps, ref: forwardedRef });
});
DropdownMenuLabel.displayName = LABEL_NAME32;
var ITEM_NAME5 = "DropdownMenuItem";
var DropdownMenuItem = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(Item222, { ...menuScope, ...itemProps, ref: forwardedRef });
});
DropdownMenuItem.displayName = ITEM_NAME5;
var CHECKBOX_ITEM_NAME22 = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(CheckboxItem2, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME22;
var RADIO_GROUP_NAME22 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(RadioGroup2, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME22;
var RADIO_ITEM_NAME22 = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(RadioItem2, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME22;
var INDICATOR_NAME2 = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(ItemIndicator22, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME2;
var SEPARATOR_NAME32 = "DropdownMenuSeparator";
var DropdownMenuSeparator = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(Separator22, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME32;
var ARROW_NAME5 = "DropdownMenuArrow";
var DropdownMenuArrow = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...arrowProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(Arrow232, { ...menuScope, ...arrowProps, ref: forwardedRef });
});
DropdownMenuArrow.displayName = ARROW_NAME5;
var DropdownMenuSub = (props) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  const [open, setOpen] = useControllableState3({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ jsx532(Sub2, { ...menuScope, open, onOpenChange: setOpen, children });
};
var SUB_TRIGGER_NAME22 = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(SubTrigger2, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME22;
var SUB_CONTENT_NAME22 = "DropdownMenuSubContent";
var DropdownMenuSubContent = React472.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return /* @__PURE__ */ jsx532(SubContent2, {
    ...menuScope,
    ...subContentProps,
    ref: forwardedRef,
    style: {
      ...props.style,
      ...{
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME22;
var Root25 = DropdownMenu;
var Trigger5 = DropdownMenuTrigger;
var Portal23 = DropdownMenuPortal;
var Content26 = DropdownMenuContent;
var Group222 = DropdownMenuGroup;
var Label222 = DropdownMenuLabel;
var Item23 = DropdownMenuItem;
var CheckboxItem22 = DropdownMenuCheckboxItem;
var RadioGroup22 = DropdownMenuRadioGroup;
var RadioItem22 = DropdownMenuRadioItem;
var ItemIndicator222 = DropdownMenuItemIndicator;
var Separator222 = DropdownMenuSeparator;
var Sub22 = DropdownMenuSub;
var SubTrigger22 = DropdownMenuSubTrigger;
var SubContent22 = DropdownMenuSubContent;
function DropdownMenu2({ ...props }) {
  return /* @__PURE__ */ jsx54(Root25, {
    "data-slot": "dropdown-menu",
    ...props
  });
}
function DropdownMenuPortal2({ ...props }) {
  return /* @__PURE__ */ jsx54(Portal23, {
    "data-slot": "dropdown-menu-portal",
    ...props
  });
}
function DropdownMenuTrigger2({ ...props }) {
  return /* @__PURE__ */ jsx54(Trigger5, {
    "data-slot": "dropdown-menu-trigger",
    ...props
  });
}
function DropdownMenuContent2({ className, sideOffset = 4, ...props }) {
  return /* @__PURE__ */ jsx54(Portal23, {
    children: /* @__PURE__ */ jsx54(Content26, {
      "data-slot": "dropdown-menu-content",
      sideOffset,
      className: clsx15("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=closed]:animate-out data-[state=open]:animate-in", className),
      ...props
    })
  });
}
function DropdownMenuGroup2({ ...props }) {
  return /* @__PURE__ */ jsx54(Group222, {
    "data-slot": "dropdown-menu-group",
    ...props
  });
}
function DropdownMenuItem2({
  className,
  inset,
  variant = "default",
  ...props
}) {
  return /* @__PURE__ */ jsx54(Item23, {
    "data-slot": "dropdown-menu-item",
    "data-inset": inset,
    "data-variant": variant,
    className: clsx15("data-[variant=destructive]:*:[svg]:!text-destructive relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[inset]:pl-8 data-[variant=destructive]:text-destructive data-[disabled]:opacity-50 data-[variant=destructive]:focus:bg-destructive/10 data-[variant=destructive]:focus:text-destructive dark:data-[variant=destructive]:focus:bg-destructive/20 [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props
  });
}
function DropdownMenuCheckboxItem2({ className, children, checked, ...props }) {
  return /* @__PURE__ */ jsxs18(CheckboxItem22, {
    "data-slot": "dropdown-menu-checkbox-item",
    className: clsx15("relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    checked,
    ...props,
    children: [
      /* @__PURE__ */ jsx54("span", {
        className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center",
        children: /* @__PURE__ */ jsx54(ItemIndicator222, {
          children: /* @__PURE__ */ jsx54(SvgIcon4, {
            iconId: "Check",
            className: "size-4"
          })
        })
      }),
      children
    ]
  });
}
function DropdownMenuRadioGroup2({ ...props }) {
  return /* @__PURE__ */ jsx54(RadioGroup22, {
    "data-slot": "dropdown-menu-radio-group",
    ...props
  });
}
function DropdownMenuRadioItem2({ className, children, ...props }) {
  return /* @__PURE__ */ jsxs18(RadioItem22, {
    "data-slot": "dropdown-menu-radio-item",
    className: clsx15("relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props,
    children: [
      /* @__PURE__ */ jsx54("span", {
        className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center",
        children: /* @__PURE__ */ jsx54(ItemIndicator222, {
          children: /* @__PURE__ */ jsx54(SvgIcon4, {
            iconId: "Circle",
            className: "size-2 fill-current"
          })
        })
      }),
      children
    ]
  });
}
function DropdownMenuLabel2({
  className,
  inset,
  ...props
}) {
  return /* @__PURE__ */ jsx54(Label222, {
    "data-slot": "dropdown-menu-label",
    "data-inset": inset,
    className: clsx15("px-2 py-1.5 font-medium text-sm data-[inset]:pl-8", className),
    ...props
  });
}
function DropdownMenuSeparator2({ className, ...props }) {
  return /* @__PURE__ */ jsx54(Separator222, {
    "data-slot": "dropdown-menu-separator",
    className: clsx15("-mx-1 my-1 h-px bg-border", className),
    ...props
  });
}
function DropdownMenuShortcut({ className, ...props }) {
  return /* @__PURE__ */ jsx54("span", {
    "data-slot": "dropdown-menu-shortcut",
    className: clsx15("ml-auto text-muted-foreground text-xs tracking-widest", className),
    ...props
  });
}
function DropdownMenuSub2({ ...props }) {
  return /* @__PURE__ */ jsx54(Sub22, {
    "data-slot": "dropdown-menu-sub",
    ...props
  });
}
function DropdownMenuSubTrigger2({
  className,
  inset,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxs18(SubTrigger22, {
    "data-slot": "dropdown-menu-sub-trigger",
    "data-inset": inset,
    className: clsx15("flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[inset]:pl-8 data-[state=open]:text-accent-foreground [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsx54(SvgIcon4, {
        iconId: "ChevronRight",
        className: "ml-auto size-4"
      })
    ]
  });
}
function DropdownMenuSubContent2({ className, ...props }) {
  return /* @__PURE__ */ jsx54(SubContent22, {
    "data-slot": "dropdown-menu-sub-content",
    className: clsx15("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=closed]:animate-out data-[state=open]:animate-in", className),
    ...props
  });
}
function Card({ className, ...props }) {
  return /* @__PURE__ */ jsx70("div", {
    "data-slot": "card",
    className: clsx16("flex flex-col gap-6 rounded-xl border bg-card py-6 text-card-foreground shadow-sm", className),
    ...props
  });
}
function CardHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx70("div", {
    "data-slot": "card-header",
    className: clsx16("@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6", className),
    ...props
  });
}
function CardTitle({ className, ...props }) {
  return /* @__PURE__ */ jsx70("div", {
    "data-slot": "card-title",
    className: clsx16("font-semibold leading-none", className),
    ...props
  });
}
function CardDescription({ className, ...props }) {
  return /* @__PURE__ */ jsx70("div", {
    "data-slot": "card-description",
    className: clsx16("text-muted-foreground text-sm", className),
    ...props
  });
}
function CardAction({ className, ...props }) {
  return /* @__PURE__ */ jsx70("div", {
    "data-slot": "card-action",
    className: clsx16("col-start-2 row-span-2 row-start-1 self-start justify-self-end", className),
    ...props
  });
}
function CardContent({ className, ...props }) {
  return /* @__PURE__ */ jsx70("div", {
    "data-slot": "card-content",
    className: clsx16("px-6", className),
    ...props
  });
}
function CardFooter({ className, ...props }) {
  return /* @__PURE__ */ jsx70("div", {
    "data-slot": "card-footer",
    className: clsx16("flex items-center px-6 [.border-t]:pt-6", className),
    ...props
  });
}
function Input({ className, type, ...props }) {
  return /* @__PURE__ */ jsx71("input", {
    type,
    "data-slot": "input",
    className: clsx17("h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs outline-none transition-[color,box-shadow] selection:bg-primary selection:text-primary-foreground file:inline-flex file:h-7 file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30", "focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50", "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40", className),
    ...props
  });
}
var NAME4 = "Label";
var Label3 = React482.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsx722(Primitive3.label, {
    ...props,
    ref: forwardedRef,
    onMouseDown: (event) => {
      const target = event.target;
      if (target.closest("button, input, select, textarea"))
        return;
      props.onMouseDown?.(event);
      if (!event.defaultPrevented && event.detail > 1)
        event.preventDefault();
    }
  });
});
Label3.displayName = NAME4;
var Root10 = Label3;
function Label4({ className, ...props }) {
  return /* @__PURE__ */ jsx73(Root10, {
    "data-slot": "label",
    className: clsx18("flex select-none items-center gap-2 font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-50 group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50", className),
    ...props
  });
}
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope3(CHECKBOX_NAME);
var [CheckboxProviderImpl, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
function CheckboxProvider(props) {
  const {
    __scopeCheckbox,
    checked: checkedProp,
    children,
    defaultChecked,
    disabled,
    form,
    name,
    onCheckedChange,
    required,
    value = "on",
    internal_do_not_use_render
  } = props;
  const [checked, setChecked] = useControllableState3({
    prop: checkedProp,
    defaultProp: defaultChecked ?? false,
    onChange: onCheckedChange,
    caller: CHECKBOX_NAME
  });
  const [control, setControl] = React502.useState(null);
  const [bubbleInput, setBubbleInput] = React502.useState(null);
  const hasConsumerStoppedPropagationRef = React502.useRef(false);
  const isFormControl = control ? !!form || !!control.closest("form") : true;
  const context = {
    checked,
    disabled,
    setChecked,
    control,
    setControl,
    name,
    form,
    value,
    hasConsumerStoppedPropagationRef,
    required,
    defaultChecked: isIndeterminate22(defaultChecked) ? false : defaultChecked,
    isFormControl,
    bubbleInput,
    setBubbleInput
  };
  return /* @__PURE__ */ jsx76(CheckboxProviderImpl, {
    scope: __scopeCheckbox,
    ...context,
    children: isFunction22(internal_do_not_use_render) ? internal_do_not_use_render(context) : children
  });
}
var TRIGGER_NAME8 = "CheckboxTrigger";
var CheckboxTrigger = React502.forwardRef(({ __scopeCheckbox, onKeyDown, onClick, ...checkboxProps }, forwardedRef) => {
  const {
    control,
    value,
    disabled,
    checked,
    required,
    setControl,
    setChecked,
    hasConsumerStoppedPropagationRef,
    isFormControl,
    bubbleInput
  } = useCheckboxContext(TRIGGER_NAME8, __scopeCheckbox);
  const composedRefs = useComposedRefs3(forwardedRef, setControl);
  const initialCheckedStateRef = React502.useRef(checked);
  React502.useEffect(() => {
    const form = control?.form;
    if (form) {
      const reset = () => setChecked(initialCheckedStateRef.current);
      form.addEventListener("reset", reset);
      return () => form.removeEventListener("reset", reset);
    }
  }, [control, setChecked]);
  return /* @__PURE__ */ jsx76(Primitive3.button, {
    type: "button",
    role: "checkbox",
    "aria-checked": isIndeterminate22(checked) ? "mixed" : checked,
    "aria-required": required,
    "data-state": getState4(checked),
    "data-disabled": disabled ? "" : undefined,
    disabled,
    value,
    ...checkboxProps,
    ref: composedRefs,
    onKeyDown: composeEventHandlers3(onKeyDown, (event) => {
      if (event.key === "Enter")
        event.preventDefault();
    }),
    onClick: composeEventHandlers3(onClick, (event) => {
      setChecked((prevChecked) => isIndeterminate22(prevChecked) ? true : !prevChecked);
      if (bubbleInput && isFormControl) {
        hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
        if (!hasConsumerStoppedPropagationRef.current)
          event.stopPropagation();
      }
    })
  });
});
CheckboxTrigger.displayName = TRIGGER_NAME8;
var Checkbox = React502.forwardRef((props, forwardedRef) => {
  const {
    __scopeCheckbox,
    name,
    checked,
    defaultChecked,
    required,
    disabled,
    value,
    onCheckedChange,
    form,
    ...checkboxProps
  } = props;
  return /* @__PURE__ */ jsx76(CheckboxProvider, {
    __scopeCheckbox,
    checked,
    defaultChecked,
    disabled,
    required,
    onCheckedChange,
    name,
    form,
    value,
    internal_do_not_use_render: ({ isFormControl }) => /* @__PURE__ */ jsxs28(Fragment10, { children: [
      /* @__PURE__ */ jsx76(CheckboxTrigger, {
        ...checkboxProps,
        ref: forwardedRef,
        __scopeCheckbox
      }),
      isFormControl && /* @__PURE__ */ jsx76(CheckboxBubbleInput, {
        __scopeCheckbox
      })
    ] })
  });
});
Checkbox.displayName = CHECKBOX_NAME;
var INDICATOR_NAME22 = "CheckboxIndicator";
var CheckboxIndicator = React502.forwardRef((props, forwardedRef) => {
  const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
  const context = useCheckboxContext(INDICATOR_NAME22, __scopeCheckbox);
  return /* @__PURE__ */ jsx76(Presence3, {
    present: forceMount || isIndeterminate22(context.checked) || context.checked === true,
    children: /* @__PURE__ */ jsx76(Primitive3.span, {
      "data-state": getState4(context.checked),
      "data-disabled": context.disabled ? "" : undefined,
      ...indicatorProps,
      ref: forwardedRef,
      style: { pointerEvents: "none", ...props.style }
    })
  });
});
CheckboxIndicator.displayName = INDICATOR_NAME22;
var BUBBLE_INPUT_NAME2 = "CheckboxBubbleInput";
var CheckboxBubbleInput = React502.forwardRef(({ __scopeCheckbox, ...props }, forwardedRef) => {
  const {
    control,
    hasConsumerStoppedPropagationRef,
    checked,
    defaultChecked,
    required,
    disabled,
    name,
    value,
    form,
    bubbleInput,
    setBubbleInput
  } = useCheckboxContext(BUBBLE_INPUT_NAME2, __scopeCheckbox);
  const composedRefs = useComposedRefs3(forwardedRef, setBubbleInput);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize2(control);
  React502.useEffect(() => {
    const input = bubbleInput;
    if (!input)
      return;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    const bubbles = !hasConsumerStoppedPropagationRef.current;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      input.indeterminate = isIndeterminate22(checked);
      setChecked.call(input, isIndeterminate22(checked) ? false : checked);
      input.dispatchEvent(event);
    }
  }, [bubbleInput, prevChecked, checked, hasConsumerStoppedPropagationRef]);
  const defaultCheckedRef = React502.useRef(isIndeterminate22(checked) ? false : checked);
  return /* @__PURE__ */ jsx76(Primitive3.input, {
    type: "checkbox",
    "aria-hidden": true,
    defaultChecked: defaultChecked ?? defaultCheckedRef.current,
    required,
    disabled,
    name,
    value,
    form,
    ...props,
    tabIndex: -1,
    ref: composedRefs,
    style: {
      ...props.style,
      ...controlSize,
      position: "absolute",
      pointerEvents: "none",
      opacity: 0,
      margin: 0,
      transform: "translateX(-100%)"
    }
  });
});
CheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME2;
function isFunction22(value) {
  return typeof value === "function";
}
function isIndeterminate22(checked) {
  return checked === "indeterminate";
}
function getState4(checked) {
  return isIndeterminate22(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function Collapsible2({ ...props }) {
  return /* @__PURE__ */ jsx83(Root5, {
    "data-slot": "collapsible",
    ...props
  });
}
function CollapsibleTrigger2({ ...props }) {
  return /* @__PURE__ */ jsx83(CollapsibleTrigger, {
    "data-slot": "collapsible-trigger",
    ...props
  });
}
function CollapsibleContent2({ ...props }) {
  return /* @__PURE__ */ jsx83(CollapsibleContent, {
    "data-slot": "collapsible-content",
    ...props
  });
}
function Dialog22({ ...props }) {
  return /* @__PURE__ */ jsx85(Root62, {
    "data-slot": "dialog",
    ...props
  });
}
function DialogTrigger22({ ...props }) {
  return /* @__PURE__ */ jsx85(Trigger4, {
    "data-slot": "dialog-trigger",
    ...props
  });
}
function DialogPortal22({ ...props }) {
  return /* @__PURE__ */ jsx85(Portal4, {
    "data-slot": "dialog-portal",
    ...props
  });
}
function DialogClose22({ ...props }) {
  return /* @__PURE__ */ jsx85(Close, {
    "data-slot": "dialog-close",
    ...props
  });
}
function DialogOverlay22({ className, ...props }) {
  return /* @__PURE__ */ jsx85(Overlay2, {
    "data-slot": "dialog-overlay",
    className: clsx20("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50 data-[state=closed]:animate-out data-[state=open]:animate-in", className),
    ...props
  });
}
function DialogContent22({
  className,
  children,
  showCloseButton = true,
  ...props
}) {
  return /* @__PURE__ */ jsxs35(DialogPortal22, {
    "data-slot": "dialog-portal",
    children: [
      /* @__PURE__ */ jsx85(DialogOverlay22, {}),
      /* @__PURE__ */ jsxs35(Content52, {
        "data-slot": "dialog-content",
        className: clsx20("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=open]:animate-in sm:max-w-lg", className),
        ...props,
        children: [
          children,
          showCloseButton && /* @__PURE__ */ jsxs35(Close, {
            "data-slot": "dialog-close",
            className: "absolute top-4 right-4 rounded-xs opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
            children: [
              /* @__PURE__ */ jsx85(SvgIcon4, {
                iconId: "X"
              }),
              /* @__PURE__ */ jsx85("span", {
                className: "sr-only",
                children: "Close"
              })
            ]
          })
        ]
      })
    ]
  });
}
function DialogHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx85("div", {
    "data-slot": "dialog-header",
    className: clsx20("flex flex-col gap-2 text-center sm:text-left", className),
    ...props
  });
}
function DialogFooter({ className, ...props }) {
  return /* @__PURE__ */ jsx85("div", {
    "data-slot": "dialog-footer",
    className: clsx20("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className),
    ...props
  });
}
function DialogTitle22({ className, ...props }) {
  return /* @__PURE__ */ jsx85(Title, {
    "data-slot": "dialog-title",
    className: clsx20("font-semibold text-lg leading-none", className),
    ...props
  });
}
function DialogDescription22({ className, ...props }) {
  return /* @__PURE__ */ jsx85(Description, {
    "data-slot": "dialog-description",
    className: clsx20("text-muted-foreground text-sm", className),
    ...props
  });
}
function Command({ className, ...props }) {
  return /* @__PURE__ */ jsx86(_e, {
    "data-slot": "command",
    className: clsx21("flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground", className),
    ...props
  });
}
function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  className,
  showCloseButton = true,
  ...props
}) {
  return /* @__PURE__ */ jsxs36(Dialog22, {
    ...props,
    children: [
      /* @__PURE__ */ jsxs36(DialogHeader, {
        className: "sr-only",
        children: [
          /* @__PURE__ */ jsx86(DialogTitle22, {
            children: title
          }),
          /* @__PURE__ */ jsx86(DialogDescription22, {
            children: description
          })
        ]
      }),
      /* @__PURE__ */ jsx86(DialogContent22, {
        className: clsx21("overflow-hidden p-0", className),
        showCloseButton,
        children: /* @__PURE__ */ jsx86(Command, {
          className: "**:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5",
          children
        })
      })
    ]
  });
}
function CommandInput({ className, ...props }) {
  return /* @__PURE__ */ jsxs36("div", {
    "data-slot": "command-input-wrapper",
    className: "flex h-9 items-center gap-2 border-b px-3",
    children: [
      /* @__PURE__ */ jsx86(SvgIcon4, {
        iconId: "Search",
        className: "size-4 shrink-0 opacity-50"
      }),
      /* @__PURE__ */ jsx86(_e.Input, {
        "data-slot": "command-input",
        className: clsx21("flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50", className),
        ...props
      })
    ]
  });
}
function CommandList({ className, ...props }) {
  return /* @__PURE__ */ jsx86(_e.List, {
    "data-slot": "command-list",
    className: clsx21("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", className),
    ...props
  });
}
function CommandEmpty({ ...props }) {
  return /* @__PURE__ */ jsx86(_e.Empty, {
    "data-slot": "command-empty",
    className: "py-6 text-center text-sm",
    ...props
  });
}
function CommandGroup({ className, ...props }) {
  return /* @__PURE__ */ jsx86(_e.Group, {
    "data-slot": "command-group",
    className: clsx21("overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group-heading]]:text-xs", className),
    ...props
  });
}
function CommandSeparator({ className, ...props }) {
  return /* @__PURE__ */ jsx86(_e.Separator, {
    "data-slot": "command-separator",
    className: clsx21("-mx-1 h-px bg-border", className),
    ...props
  });
}
function CommandItem({ className, ...props }) {
  return /* @__PURE__ */ jsx86(_e.Item, {
    "data-slot": "command-item",
    className: clsx21("relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props
  });
}
function CommandShortcut({ className, ...props }) {
  return /* @__PURE__ */ jsx86("span", {
    "data-slot": "command-shortcut",
    className: clsx21("ml-auto text-muted-foreground text-xs tracking-widest", className),
    ...props
  });
}
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope3(POPOVER_NAME, [
  createPopperScope2
]);
var usePopperScope4 = createPopperScope2();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope4(__scopePopover);
  const triggerRef = React572.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React572.useState(false);
  const [open, setOpen] = useControllableState3({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return /* @__PURE__ */ jsx87(Root22, { ...popperScope, children: /* @__PURE__ */ jsx87(PopoverProvider, {
    scope: __scopePopover,
    contentId: useId3(),
    triggerRef,
    open,
    onOpenChange: setOpen,
    onOpenToggle: React572.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
    hasCustomAnchor,
    onCustomAnchorAdd: React572.useCallback(() => setHasCustomAnchor(true), []),
    onCustomAnchorRemove: React572.useCallback(() => setHasCustomAnchor(false), []),
    modal,
    children
  }) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME32 = "PopoverAnchor";
var PopoverAnchor = React572.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...anchorProps } = props;
  const context = usePopoverContext(ANCHOR_NAME32, __scopePopover);
  const popperScope = usePopperScope4(__scopePopover);
  const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
  React572.useEffect(() => {
    onCustomAnchorAdd();
    return () => onCustomAnchorRemove();
  }, [onCustomAnchorAdd, onCustomAnchorRemove]);
  return /* @__PURE__ */ jsx87(Anchor3, { ...popperScope, ...anchorProps, ref: forwardedRef });
});
PopoverAnchor.displayName = ANCHOR_NAME32;
var TRIGGER_NAME9 = "PopoverTrigger";
var PopoverTrigger = React572.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...triggerProps } = props;
  const context = usePopoverContext(TRIGGER_NAME9, __scopePopover);
  const popperScope = usePopperScope4(__scopePopover);
  const composedTriggerRef = useComposedRefs3(forwardedRef, context.triggerRef);
  const trigger = /* @__PURE__ */ jsx87(Primitive3.button, {
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": getState5(context.open),
    ...triggerProps,
    ref: composedTriggerRef,
    onClick: composeEventHandlers3(props.onClick, context.onOpenToggle)
  });
  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ jsx87(Anchor3, { asChild: true, ...popperScope, children: trigger });
});
PopoverTrigger.displayName = TRIGGER_NAME9;
var PORTAL_NAME82 = "PopoverPortal";
var [PortalProvider4, usePortalContext4] = createPopoverContext(PORTAL_NAME82, {
  forceMount: undefined
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME82, __scopePopover);
  return /* @__PURE__ */ jsx87(PortalProvider4, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ jsx87(Presence3, { present: forceMount || context.open, children: /* @__PURE__ */ jsx87(Portal6, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME82;
var CONTENT_NAME10 = "PopoverContent";
var PopoverContent = React572.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext4(CONTENT_NAME10, props.__scopePopover);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = usePopoverContext(CONTENT_NAME10, props.__scopePopover);
  return /* @__PURE__ */ jsx87(Presence3, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsx87(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx87(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
});
PopoverContent.displayName = CONTENT_NAME10;
var Slot5 = createSlot3("PopoverContent.RemoveScroll");
var PopoverContentModal = React572.forwardRef((props, forwardedRef) => {
  const context = usePopoverContext(CONTENT_NAME10, props.__scopePopover);
  const contentRef = React572.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, contentRef);
  const isRightClickOutsideRef = React572.useRef(false);
  React572.useEffect(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers3(content);
  }, []);
  return /* @__PURE__ */ jsx87(Combination_default3, { as: Slot5, allowPinchZoom: true, children: /* @__PURE__ */ jsx87(PopoverContentImpl, {
    ...props,
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: composeEventHandlers3(props.onCloseAutoFocus, (event) => {
      event.preventDefault();
      if (!isRightClickOutsideRef.current)
        context.triggerRef.current?.focus();
    }),
    onPointerDownOutside: composeEventHandlers3(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClickOutsideRef.current = isRightClick;
    }, { checkForDefaultPrevented: false }),
    onFocusOutside: composeEventHandlers3(props.onFocusOutside, (event) => event.preventDefault(), { checkForDefaultPrevented: false })
  }) });
});
var PopoverContentNonModal = React572.forwardRef((props, forwardedRef) => {
  const context = usePopoverContext(CONTENT_NAME10, props.__scopePopover);
  const hasInteractedOutsideRef = React572.useRef(false);
  const hasPointerDownOutsideRef = React572.useRef(false);
  return /* @__PURE__ */ jsx87(PopoverContentImpl, {
    ...props,
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      props.onCloseAutoFocus?.(event);
      if (!event.defaultPrevented) {
        if (!hasInteractedOutsideRef.current)
          context.triggerRef.current?.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      props.onInteractOutside?.(event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown") {
          hasPointerDownOutsideRef.current = true;
        }
      }
      const target = event.target;
      const targetIsTrigger = context.triggerRef.current?.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
        event.preventDefault();
      }
    }
  });
});
var PopoverContentImpl = React572.forwardRef((props, forwardedRef) => {
  const {
    __scopePopover,
    trapFocus,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    ...contentProps
  } = props;
  const context = usePopoverContext(CONTENT_NAME10, __scopePopover);
  const popperScope = usePopperScope4(__scopePopover);
  useFocusGuards3();
  return /* @__PURE__ */ jsx87(FocusScope3, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus,
    children: /* @__PURE__ */ jsx87(DismissableLayer3, {
      asChild: true,
      disableOutsidePointerEvents,
      onInteractOutside,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onDismiss: () => context.onOpenChange(false),
      children: /* @__PURE__ */ jsx87(Content5, {
        "data-state": getState5(context.open),
        role: "dialog",
        id: context.contentId,
        ...popperScope,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...contentProps.style,
          ...{
            "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
            "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
            "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      })
    })
  });
});
var CLOSE_NAME22 = "PopoverClose";
var PopoverClose = React572.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...closeProps } = props;
  const context = usePopoverContext(CLOSE_NAME22, __scopePopover);
  return /* @__PURE__ */ jsx87(Primitive3.button, {
    type: "button",
    ...closeProps,
    ref: forwardedRef,
    onClick: composeEventHandlers3(props.onClick, () => context.onOpenChange(false))
  });
});
PopoverClose.displayName = CLOSE_NAME22;
var ARROW_NAME6 = "PopoverArrow";
var PopoverArrow = React572.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...arrowProps } = props;
  const popperScope = usePopperScope4(__scopePopover);
  return /* @__PURE__ */ jsx87(Arrow23, { ...popperScope, ...arrowProps, ref: forwardedRef });
});
PopoverArrow.displayName = ARROW_NAME6;
function getState5(open) {
  return open ? "open" : "closed";
}
var Root26 = Popover;
var Anchor222 = PopoverAnchor;
var Trigger6 = PopoverTrigger;
var Portal62 = PopoverPortal;
var Content27 = PopoverContent;
function Popover2({ ...props }) {
  return /* @__PURE__ */ jsx88(Root26, {
    "data-slot": "popover",
    ...props
  });
}
function PopoverTrigger2({ ...props }) {
  return /* @__PURE__ */ jsx88(Trigger6, {
    "data-slot": "popover-trigger",
    ...props
  });
}
function PopoverContent2({ className, align = "center", sideOffset = 4, ...props }) {
  return /* @__PURE__ */ jsx88(Portal62, {
    children: /* @__PURE__ */ jsx88(Content27, {
      "data-slot": "popover-content",
      align,
      sideOffset,
      className: clsx222("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-hidden data-[state=closed]:animate-out data-[state=open]:animate-in", className),
      ...props
    })
  });
}
function PopoverAnchor2({ ...props }) {
  return /* @__PURE__ */ jsx88(Anchor222, {
    "data-slot": "popover-anchor",
    ...props
  });
}
var CONTEXT_MENU_NAME = "ContextMenu";
var [createContextMenuContext, createContextMenuScope] = createContextScope3(CONTEXT_MENU_NAME, [
  createMenuScope2
]);
var useMenuScope22 = createMenuScope2();
var [ContextMenuProvider, useContextMenuContext] = createContextMenuContext(CONTEXT_MENU_NAME);
var ContextMenu = (props) => {
  const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props;
  const [open, setOpen] = React622.useState(false);
  const menuScope = useMenuScope22(__scopeContextMenu);
  const handleOpenChangeProp = useCallbackRef6(onOpenChange);
  const handleOpenChange = React622.useCallback((open2) => {
    setOpen(open2);
    handleOpenChangeProp(open2);
  }, [handleOpenChangeProp]);
  return /* @__PURE__ */ jsx93(ContextMenuProvider, {
    scope: __scopeContextMenu,
    open,
    onOpenChange: handleOpenChange,
    modal,
    children: /* @__PURE__ */ jsx93(Root332, {
      ...menuScope,
      dir,
      open,
      onOpenChange: handleOpenChange,
      modal,
      children
    })
  });
};
ContextMenu.displayName = CONTEXT_MENU_NAME;
var TRIGGER_NAME10 = "ContextMenuTrigger";
var ContextMenuTrigger = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, disabled = false, ...triggerProps } = props;
  const context = useContextMenuContext(TRIGGER_NAME10, __scopeContextMenu);
  const menuScope = useMenuScope22(__scopeContextMenu);
  const pointRef = React622.useRef({ x: 0, y: 0 });
  const virtualRef = React622.useRef({
    getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...pointRef.current })
  });
  const longPressTimerRef = React622.useRef(0);
  const clearLongPress = React622.useCallback(() => window.clearTimeout(longPressTimerRef.current), []);
  const handleOpen = (event) => {
    pointRef.current = { x: event.clientX, y: event.clientY };
    context.onOpenChange(true);
  };
  React622.useEffect(() => clearLongPress, [clearLongPress]);
  React622.useEffect(() => void (disabled && clearLongPress()), [disabled, clearLongPress]);
  return /* @__PURE__ */ jsxs41(Fragment112, { children: [
    /* @__PURE__ */ jsx93(Anchor22, { ...menuScope, virtualRef }),
    /* @__PURE__ */ jsx93(Primitive3.span, {
      "data-state": context.open ? "open" : "closed",
      "data-disabled": disabled ? "" : undefined,
      ...triggerProps,
      ref: forwardedRef,
      style: { WebkitTouchCallout: "none", ...props.style },
      onContextMenu: disabled ? props.onContextMenu : composeEventHandlers3(props.onContextMenu, (event) => {
        clearLongPress();
        handleOpen(event);
        event.preventDefault();
      }),
      onPointerDown: disabled ? props.onPointerDown : composeEventHandlers3(props.onPointerDown, whenTouchOrPen((event) => {
        clearLongPress();
        longPressTimerRef.current = window.setTimeout(() => handleOpen(event), 700);
      })),
      onPointerMove: disabled ? props.onPointerMove : composeEventHandlers3(props.onPointerMove, whenTouchOrPen(clearLongPress)),
      onPointerCancel: disabled ? props.onPointerCancel : composeEventHandlers3(props.onPointerCancel, whenTouchOrPen(clearLongPress)),
      onPointerUp: disabled ? props.onPointerUp : composeEventHandlers3(props.onPointerUp, whenTouchOrPen(clearLongPress))
    })
  ] });
});
ContextMenuTrigger.displayName = TRIGGER_NAME10;
var PORTAL_NAME9 = "ContextMenuPortal";
var ContextMenuPortal = (props) => {
  const { __scopeContextMenu, ...portalProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(Portal52, { ...menuScope, ...portalProps });
};
ContextMenuPortal.displayName = PORTAL_NAME9;
var CONTENT_NAME11 = "ContextMenuContent";
var ContextMenuContent = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...contentProps } = props;
  const context = useContextMenuContext(CONTENT_NAME11, __scopeContextMenu);
  const menuScope = useMenuScope22(__scopeContextMenu);
  const hasInteractedOutsideRef = React622.useRef(false);
  return /* @__PURE__ */ jsx93(Content25, {
    ...menuScope,
    ...contentProps,
    ref: forwardedRef,
    side: "right",
    sideOffset: 2,
    align: "start",
    onCloseAutoFocus: (event) => {
      props.onCloseAutoFocus?.(event);
      if (!event.defaultPrevented && hasInteractedOutsideRef.current) {
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      props.onInteractOutside?.(event);
      if (!event.defaultPrevented && !context.modal)
        hasInteractedOutsideRef.current = true;
    },
    style: {
      ...props.style,
      ...{
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
ContextMenuContent.displayName = CONTENT_NAME11;
var GROUP_NAME5 = "ContextMenuGroup";
var ContextMenuGroup = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...groupProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(Group22, { ...menuScope, ...groupProps, ref: forwardedRef });
});
ContextMenuGroup.displayName = GROUP_NAME5;
var LABEL_NAME4 = "ContextMenuLabel";
var ContextMenuLabel = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...labelProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(Label22, { ...menuScope, ...labelProps, ref: forwardedRef });
});
ContextMenuLabel.displayName = LABEL_NAME4;
var ITEM_NAME62 = "ContextMenuItem";
var ContextMenuItem = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...itemProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(Item222, { ...menuScope, ...itemProps, ref: forwardedRef });
});
ContextMenuItem.displayName = ITEM_NAME62;
var CHECKBOX_ITEM_NAME32 = "ContextMenuCheckboxItem";
var ContextMenuCheckboxItem = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(CheckboxItem2, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
ContextMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME32;
var RADIO_GROUP_NAME32 = "ContextMenuRadioGroup";
var ContextMenuRadioGroup = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(RadioGroup2, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
ContextMenuRadioGroup.displayName = RADIO_GROUP_NAME32;
var RADIO_ITEM_NAME32 = "ContextMenuRadioItem";
var ContextMenuRadioItem = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(RadioItem2, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
ContextMenuRadioItem.displayName = RADIO_ITEM_NAME32;
var INDICATOR_NAME3 = "ContextMenuItemIndicator";
var ContextMenuItemIndicator = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(ItemIndicator22, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
ContextMenuItemIndicator.displayName = INDICATOR_NAME3;
var SEPARATOR_NAME4 = "ContextMenuSeparator";
var ContextMenuSeparator = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...separatorProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(Separator22, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
ContextMenuSeparator.displayName = SEPARATOR_NAME4;
var ARROW_NAME7 = "ContextMenuArrow";
var ContextMenuArrow = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...arrowProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(Arrow232, { ...menuScope, ...arrowProps, ref: forwardedRef });
});
ContextMenuArrow.displayName = ARROW_NAME7;
var SUB_NAME22 = "ContextMenuSub";
var ContextMenuSub = (props) => {
  const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  const [open, setOpen] = useControllableState3({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SUB_NAME22
  });
  return /* @__PURE__ */ jsx93(Sub2, { ...menuScope, open, onOpenChange: setOpen, children });
};
ContextMenuSub.displayName = SUB_NAME22;
var SUB_TRIGGER_NAME32 = "ContextMenuSubTrigger";
var ContextMenuSubTrigger = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...triggerItemProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(SubTrigger2, { ...menuScope, ...triggerItemProps, ref: forwardedRef });
});
ContextMenuSubTrigger.displayName = SUB_TRIGGER_NAME32;
var SUB_CONTENT_NAME32 = "ContextMenuSubContent";
var ContextMenuSubContent = React622.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...subContentProps } = props;
  const menuScope = useMenuScope22(__scopeContextMenu);
  return /* @__PURE__ */ jsx93(SubContent2, {
    ...menuScope,
    ...subContentProps,
    ref: forwardedRef,
    style: {
      ...props.style,
      ...{
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
ContextMenuSubContent.displayName = SUB_CONTENT_NAME32;
function whenTouchOrPen(handler) {
  return (event) => event.pointerType !== "mouse" ? handler(event) : undefined;
}
var Root27 = ContextMenu;
var Trigger7 = ContextMenuTrigger;
var Portal24 = ContextMenuPortal;
var Content28 = ContextMenuContent;
var Group23 = ContextMenuGroup;
var Label23 = ContextMenuLabel;
var Item24 = ContextMenuItem;
var CheckboxItem222 = ContextMenuCheckboxItem;
var RadioGroup222 = ContextMenuRadioGroup;
var RadioItem222 = ContextMenuRadioItem;
var ItemIndicator23 = ContextMenuItemIndicator;
var Separator23 = ContextMenuSeparator;
var Sub222 = ContextMenuSub;
var SubTrigger222 = ContextMenuSubTrigger;
var SubContent222 = ContextMenuSubContent;
function ContextMenu2({ ...props }) {
  return /* @__PURE__ */ jsx94(Root27, {
    "data-slot": "context-menu",
    ...props
  });
}
function ContextMenuTrigger2({ ...props }) {
  return /* @__PURE__ */ jsx94(Trigger7, {
    "data-slot": "context-menu-trigger",
    ...props
  });
}
function ContextMenuGroup2({ ...props }) {
  return /* @__PURE__ */ jsx94(Group23, {
    "data-slot": "context-menu-group",
    ...props
  });
}
function ContextMenuPortal2({ ...props }) {
  return /* @__PURE__ */ jsx94(Portal24, {
    "data-slot": "context-menu-portal",
    ...props
  });
}
function ContextMenuSub2({ ...props }) {
  return /* @__PURE__ */ jsx94(Sub222, {
    "data-slot": "context-menu-sub",
    ...props
  });
}
function ContextMenuRadioGroup2({ ...props }) {
  return /* @__PURE__ */ jsx94(RadioGroup222, {
    "data-slot": "context-menu-radio-group",
    ...props
  });
}
function ContextMenuSubTrigger2({
  className,
  inset,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxs422(SubTrigger222, {
    "data-slot": "context-menu-sub-trigger",
    "data-inset": inset,
    className: clsx25("flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[inset]:pl-8 data-[state=open]:text-accent-foreground [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsx94(SvgIcon4, {
        iconId: "ChevronRight",
        className: "ml-auto"
      })
    ]
  });
}
function ContextMenuSubContent2({ className, ...props }) {
  return /* @__PURE__ */ jsx94(SubContent222, {
    "data-slot": "context-menu-sub-content",
    className: clsx25("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=closed]:animate-out data-[state=open]:animate-in", className),
    ...props
  });
}
function ContextMenuContent2({ className, ...props }) {
  return /* @__PURE__ */ jsx94(Portal24, {
    children: /* @__PURE__ */ jsx94(Content28, {
      "data-slot": "context-menu-content",
      className: clsx25("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=closed]:animate-out data-[state=open]:animate-in", className),
      ...props
    })
  });
}
function ContextMenuItem2({
  className,
  inset,
  variant = "default",
  ...props
}) {
  return /* @__PURE__ */ jsx94(Item24, {
    "data-slot": "context-menu-item",
    "data-inset": inset,
    "data-variant": variant,
    className: clsx25("data-[variant=destructive]:*:[svg]:!text-destructive relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[inset]:pl-8 data-[variant=destructive]:text-destructive data-[disabled]:opacity-50 data-[variant=destructive]:focus:bg-destructive/10 data-[variant=destructive]:focus:text-destructive dark:data-[variant=destructive]:focus:bg-destructive/20 [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props
  });
}
function ContextMenuCheckboxItem2({ className, children, checked, ...props }) {
  return /* @__PURE__ */ jsxs422(CheckboxItem222, {
    "data-slot": "context-menu-checkbox-item",
    className: clsx25("relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    checked,
    ...props,
    children: [
      /* @__PURE__ */ jsx94("span", {
        className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center",
        children: /* @__PURE__ */ jsx94(ItemIndicator23, {
          children: /* @__PURE__ */ jsx94(SvgIcon4, {
            iconId: "Check",
            className: "size-4"
          })
        })
      }),
      children
    ]
  });
}
function ContextMenuRadioItem2({ className, children, ...props }) {
  return /* @__PURE__ */ jsxs422(RadioItem222, {
    "data-slot": "context-menu-radio-item",
    className: clsx25("relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props,
    children: [
      /* @__PURE__ */ jsx94("span", {
        className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center",
        children: /* @__PURE__ */ jsx94(ItemIndicator23, {
          children: /* @__PURE__ */ jsx94(SvgIcon4, {
            iconId: "Circle",
            className: "size-2 fill-current"
          })
        })
      }),
      children
    ]
  });
}
function ContextMenuLabel2({
  className,
  inset,
  ...props
}) {
  return /* @__PURE__ */ jsx94(Label23, {
    "data-slot": "context-menu-label",
    "data-inset": inset,
    className: clsx25("px-2 py-1.5 font-medium text-foreground text-sm data-[inset]:pl-8", className),
    ...props
  });
}
function ContextMenuSeparator2({ className, ...props }) {
  return /* @__PURE__ */ jsx94(Separator23, {
    "data-slot": "context-menu-separator",
    className: clsx25("-mx-1 my-1 h-px bg-border", className),
    ...props
  });
}
function ContextMenuShortcut({ className, ...props }) {
  return /* @__PURE__ */ jsx94("span", {
    "data-slot": "context-menu-shortcut",
    className: clsx25("ml-auto text-muted-foreground text-xs tracking-widest", className),
    ...props
  });
}
var originalBodyUserSelect;
var HOVERCARD_NAME = "HoverCard";
var [createHoverCardContext, createHoverCardScope] = createContextScope3(HOVERCARD_NAME, [
  createPopperScope2
]);
var usePopperScope5 = createPopperScope2();
var [HoverCardProvider, useHoverCardContext] = createHoverCardContext(HOVERCARD_NAME);
var HoverCard = (props) => {
  const {
    __scopeHoverCard,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    openDelay = 700,
    closeDelay = 300
  } = props;
  const popperScope = usePopperScope5(__scopeHoverCard);
  const openTimerRef = React672.useRef(0);
  const closeTimerRef = React672.useRef(0);
  const hasSelectionRef = React672.useRef(false);
  const isPointerDownOnContentRef = React672.useRef(false);
  const [open, setOpen] = useControllableState3({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: HOVERCARD_NAME
  });
  const handleOpen = React672.useCallback(() => {
    clearTimeout(closeTimerRef.current);
    openTimerRef.current = window.setTimeout(() => setOpen(true), openDelay);
  }, [openDelay, setOpen]);
  const handleClose = React672.useCallback(() => {
    clearTimeout(openTimerRef.current);
    if (!hasSelectionRef.current && !isPointerDownOnContentRef.current) {
      closeTimerRef.current = window.setTimeout(() => setOpen(false), closeDelay);
    }
  }, [closeDelay, setOpen]);
  const handleDismiss = React672.useCallback(() => setOpen(false), [setOpen]);
  React672.useEffect(() => {
    return () => {
      clearTimeout(openTimerRef.current);
      clearTimeout(closeTimerRef.current);
    };
  }, []);
  return /* @__PURE__ */ jsx101(HoverCardProvider, {
    scope: __scopeHoverCard,
    open,
    onOpenChange: setOpen,
    onOpen: handleOpen,
    onClose: handleClose,
    onDismiss: handleDismiss,
    hasSelectionRef,
    isPointerDownOnContentRef,
    children: /* @__PURE__ */ jsx101(Root22, { ...popperScope, children })
  });
};
HoverCard.displayName = HOVERCARD_NAME;
var TRIGGER_NAME11 = "HoverCardTrigger";
var HoverCardTrigger = React672.forwardRef((props, forwardedRef) => {
  const { __scopeHoverCard, ...triggerProps } = props;
  const context = useHoverCardContext(TRIGGER_NAME11, __scopeHoverCard);
  const popperScope = usePopperScope5(__scopeHoverCard);
  return /* @__PURE__ */ jsx101(Anchor3, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsx101(Primitive3.a, {
    "data-state": context.open ? "open" : "closed",
    ...triggerProps,
    ref: forwardedRef,
    onPointerEnter: composeEventHandlers3(props.onPointerEnter, excludeTouch(context.onOpen)),
    onPointerLeave: composeEventHandlers3(props.onPointerLeave, excludeTouch(context.onClose)),
    onFocus: composeEventHandlers3(props.onFocus, context.onOpen),
    onBlur: composeEventHandlers3(props.onBlur, context.onClose),
    onTouchStart: composeEventHandlers3(props.onTouchStart, (event) => event.preventDefault())
  }) });
});
HoverCardTrigger.displayName = TRIGGER_NAME11;
var PORTAL_NAME10 = "HoverCardPortal";
var [PortalProvider52, usePortalContext52] = createHoverCardContext(PORTAL_NAME10, {
  forceMount: undefined
});
var HoverCardPortal = (props) => {
  const { __scopeHoverCard, forceMount, children, container } = props;
  const context = useHoverCardContext(PORTAL_NAME10, __scopeHoverCard);
  return /* @__PURE__ */ jsx101(PortalProvider52, { scope: __scopeHoverCard, forceMount, children: /* @__PURE__ */ jsx101(Presence3, { present: forceMount || context.open, children: /* @__PURE__ */ jsx101(Portal6, { asChild: true, container, children }) }) });
};
HoverCardPortal.displayName = PORTAL_NAME10;
var CONTENT_NAME12 = "HoverCardContent";
var HoverCardContent = React672.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext52(CONTENT_NAME12, props.__scopeHoverCard);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = useHoverCardContext(CONTENT_NAME12, props.__scopeHoverCard);
  return /* @__PURE__ */ jsx101(Presence3, { present: forceMount || context.open, children: /* @__PURE__ */ jsx101(HoverCardContentImpl, {
    "data-state": context.open ? "open" : "closed",
    ...contentProps,
    onPointerEnter: composeEventHandlers3(props.onPointerEnter, excludeTouch(context.onOpen)),
    onPointerLeave: composeEventHandlers3(props.onPointerLeave, excludeTouch(context.onClose)),
    ref: forwardedRef
  }) });
});
HoverCardContent.displayName = CONTENT_NAME12;
var HoverCardContentImpl = React672.forwardRef((props, forwardedRef) => {
  const {
    __scopeHoverCard,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    ...contentProps
  } = props;
  const context = useHoverCardContext(CONTENT_NAME12, __scopeHoverCard);
  const popperScope = usePopperScope5(__scopeHoverCard);
  const ref = React672.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  const [containSelection, setContainSelection] = React672.useState(false);
  React672.useEffect(() => {
    if (containSelection) {
      const body = document.body;
      originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
      body.style.userSelect = "none";
      body.style.webkitUserSelect = "none";
      return () => {
        body.style.userSelect = originalBodyUserSelect;
        body.style.webkitUserSelect = originalBodyUserSelect;
      };
    }
  }, [containSelection]);
  React672.useEffect(() => {
    if (ref.current) {
      const handlePointerUp = () => {
        setContainSelection(false);
        context.isPointerDownOnContentRef.current = false;
        setTimeout(() => {
          const hasSelection = document.getSelection()?.toString() !== "";
          if (hasSelection)
            context.hasSelectionRef.current = true;
        });
      };
      document.addEventListener("pointerup", handlePointerUp);
      return () => {
        document.removeEventListener("pointerup", handlePointerUp);
        context.hasSelectionRef.current = false;
        context.isPointerDownOnContentRef.current = false;
      };
    }
  }, [context.isPointerDownOnContentRef, context.hasSelectionRef]);
  React672.useEffect(() => {
    if (ref.current) {
      const tabbables = getTabbableNodes(ref.current);
      tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
    }
  });
  return /* @__PURE__ */ jsx101(DismissableLayer3, {
    asChild: true,
    disableOutsidePointerEvents: false,
    onInteractOutside,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside: composeEventHandlers3(onFocusOutside, (event) => {
      event.preventDefault();
    }),
    onDismiss: context.onDismiss,
    children: /* @__PURE__ */ jsx101(Content5, {
      ...popperScope,
      ...contentProps,
      onPointerDown: composeEventHandlers3(contentProps.onPointerDown, (event) => {
        if (event.currentTarget.contains(event.target)) {
          setContainSelection(true);
        }
        context.hasSelectionRef.current = false;
        context.isPointerDownOnContentRef.current = true;
      }),
      ref: composedRefs,
      style: {
        ...contentProps.style,
        userSelect: containSelection ? "text" : undefined,
        WebkitUserSelect: containSelection ? "text" : undefined,
        ...{
          "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
          "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
          "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    })
  });
});
var ARROW_NAME8 = "HoverCardArrow";
var HoverCardArrow = React672.forwardRef((props, forwardedRef) => {
  const { __scopeHoverCard, ...arrowProps } = props;
  const popperScope = usePopperScope5(__scopeHoverCard);
  return /* @__PURE__ */ jsx101(Arrow23, { ...popperScope, ...arrowProps, ref: forwardedRef });
});
HoverCardArrow.displayName = ARROW_NAME8;
function excludeTouch(eventHandler) {
  return (event) => event.pointerType === "touch" ? undefined : eventHandler();
}
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
var Root28 = HoverCard;
var Trigger8 = HoverCardTrigger;
var Portal7 = HoverCardPortal;
var Content29 = HoverCardContent;
function HoverCard2({ ...props }) {
  return /* @__PURE__ */ jsx1022(Root28, {
    "data-slot": "hover-card",
    ...props
  });
}
function HoverCardTrigger2({ ...props }) {
  return /* @__PURE__ */ jsx1022(Trigger8, {
    "data-slot": "hover-card-trigger",
    ...props
  });
}
function HoverCardContent2({ className, align = "center", sideOffset = 4, ...props }) {
  return /* @__PURE__ */ jsx1022(Portal7, {
    "data-slot": "hover-card-portal",
    children: /* @__PURE__ */ jsx1022(Content29, {
      "data-slot": "hover-card-content",
      align,
      sideOffset,
      className: clsx26("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-hidden data-[state=closed]:animate-out data-[state=open]:animate-in", className),
      ...props
    })
  });
}
var MENUBAR_NAME2 = "Menubar";
var [Collection5, useCollection5, createCollectionScope5] = createCollection3(MENUBAR_NAME2);
var [createMenubarContext2, createMenubarScope2] = createContextScope3(MENUBAR_NAME2, [
  createCollectionScope5,
  createRovingFocusGroupScope3
]);
var useMenuScope3 = createMenuScope2();
var useRovingFocusGroupScope22 = createRovingFocusGroupScope3();
var [MenubarContextProvider2, useMenubarContext2] = createMenubarContext2(MENUBAR_NAME2);
var Menubar2 = React722.forwardRef((props, forwardedRef) => {
  const {
    __scopeMenubar,
    value: valueProp,
    onValueChange,
    defaultValue,
    loop = true,
    dir,
    ...menubarProps
  } = props;
  const direction = useDirection3(dir);
  const rovingFocusGroupScope = useRovingFocusGroupScope22(__scopeMenubar);
  const [value, setValue] = useControllableState3({
    prop: valueProp,
    onChange: onValueChange,
    defaultProp: defaultValue ?? "",
    caller: MENUBAR_NAME2
  });
  const [currentTabStopId, setCurrentTabStopId] = React722.useState(null);
  return /* @__PURE__ */ jsx1122(MenubarContextProvider2, {
    scope: __scopeMenubar,
    value,
    onMenuOpen: React722.useCallback((value2) => {
      setValue(value2);
      setCurrentTabStopId(value2);
    }, [setValue]),
    onMenuClose: React722.useCallback(() => setValue(""), [setValue]),
    onMenuToggle: React722.useCallback((value2) => {
      setValue((prevValue) => prevValue ? "" : value2);
      setCurrentTabStopId(value2);
    }, [setValue]),
    dir: direction,
    loop,
    children: /* @__PURE__ */ jsx1122(Collection5.Provider, { scope: __scopeMenubar, children: /* @__PURE__ */ jsx1122(Collection5.Slot, { scope: __scopeMenubar, children: /* @__PURE__ */ jsx1122(Root9, {
      asChild: true,
      ...rovingFocusGroupScope,
      orientation: "horizontal",
      loop,
      dir: direction,
      currentTabStopId,
      onCurrentTabStopIdChange: setCurrentTabStopId,
      children: /* @__PURE__ */ jsx1122(Primitive3.div, { role: "menubar", ...menubarProps, ref: forwardedRef })
    }) }) })
  });
});
Menubar2.displayName = MENUBAR_NAME2;
var MENU_NAME22 = "MenubarMenu";
var [MenubarMenuProvider2, useMenubarMenuContext2] = createMenubarContext2(MENU_NAME22);
var MenubarMenu2 = (props) => {
  const { __scopeMenubar, value: valueProp, ...menuProps } = props;
  const autoValue = useId3();
  const value = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
  const context = useMenubarContext2(MENU_NAME22, __scopeMenubar);
  const menuScope = useMenuScope3(__scopeMenubar);
  const triggerRef = React722.useRef(null);
  const wasKeyboardTriggerOpenRef = React722.useRef(false);
  const open = context.value === value;
  React722.useEffect(() => {
    if (!open)
      wasKeyboardTriggerOpenRef.current = false;
  }, [open]);
  return /* @__PURE__ */ jsx1122(MenubarMenuProvider2, {
    scope: __scopeMenubar,
    value,
    triggerId: useId3(),
    triggerRef,
    contentId: useId3(),
    wasKeyboardTriggerOpenRef,
    children: /* @__PURE__ */ jsx1122(Root332, {
      ...menuScope,
      open,
      onOpenChange: (open2) => {
        if (!open2)
          context.onMenuClose();
      },
      modal: false,
      dir: context.dir,
      ...menuProps
    })
  });
};
MenubarMenu2.displayName = MENU_NAME22;
var TRIGGER_NAME12 = "MenubarTrigger";
var MenubarTrigger2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, disabled = false, ...triggerProps } = props;
  const rovingFocusGroupScope = useRovingFocusGroupScope22(__scopeMenubar);
  const menuScope = useMenuScope3(__scopeMenubar);
  const context = useMenubarContext2(TRIGGER_NAME12, __scopeMenubar);
  const menuContext = useMenubarMenuContext2(TRIGGER_NAME12, __scopeMenubar);
  const ref = React722.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref, menuContext.triggerRef);
  const [isFocused, setIsFocused] = React722.useState(false);
  const open = context.value === menuContext.value;
  return /* @__PURE__ */ jsx1122(Collection5.ItemSlot, { scope: __scopeMenubar, value: menuContext.value, disabled, children: /* @__PURE__ */ jsx1122(Item32, {
    asChild: true,
    ...rovingFocusGroupScope,
    focusable: !disabled,
    tabStopId: menuContext.value,
    children: /* @__PURE__ */ jsx1122(Anchor22, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsx1122(Primitive3.button, {
      type: "button",
      role: "menuitem",
      id: menuContext.triggerId,
      "aria-haspopup": "menu",
      "aria-expanded": open,
      "aria-controls": open ? menuContext.contentId : undefined,
      "data-highlighted": isFocused ? "" : undefined,
      "data-state": open ? "open" : "closed",
      "data-disabled": disabled ? "" : undefined,
      disabled,
      ...triggerProps,
      ref: composedRefs,
      onPointerDown: composeEventHandlers3(props.onPointerDown, (event) => {
        if (!disabled && event.button === 0 && event.ctrlKey === false) {
          context.onMenuOpen(menuContext.value);
          if (!open)
            event.preventDefault();
        }
      }),
      onPointerEnter: composeEventHandlers3(props.onPointerEnter, () => {
        const menubarOpen = Boolean(context.value);
        if (menubarOpen && !open) {
          context.onMenuOpen(menuContext.value);
          ref.current?.focus();
        }
      }),
      onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
        if (disabled)
          return;
        if (["Enter", " "].includes(event.key))
          context.onMenuToggle(menuContext.value);
        if (event.key === "ArrowDown")
          context.onMenuOpen(menuContext.value);
        if (["Enter", " ", "ArrowDown"].includes(event.key)) {
          menuContext.wasKeyboardTriggerOpenRef.current = true;
          event.preventDefault();
        }
      }),
      onFocus: composeEventHandlers3(props.onFocus, () => setIsFocused(true)),
      onBlur: composeEventHandlers3(props.onBlur, () => setIsFocused(false))
    }) })
  }) });
});
MenubarTrigger2.displayName = TRIGGER_NAME12;
var PORTAL_NAME11 = "MenubarPortal";
var MenubarPortal2 = (props) => {
  const { __scopeMenubar, ...portalProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(Portal52, { ...menuScope, ...portalProps });
};
MenubarPortal2.displayName = PORTAL_NAME11;
var CONTENT_NAME13 = "MenubarContent";
var MenubarContent2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, align = "start", ...contentProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  const context = useMenubarContext2(CONTENT_NAME13, __scopeMenubar);
  const menuContext = useMenubarMenuContext2(CONTENT_NAME13, __scopeMenubar);
  const getItems = useCollection5(__scopeMenubar);
  const hasInteractedOutsideRef = React722.useRef(false);
  return /* @__PURE__ */ jsx1122(Content25, {
    id: menuContext.contentId,
    "aria-labelledby": menuContext.triggerId,
    "data-radix-menubar-content": "",
    ...menuScope,
    ...contentProps,
    ref: forwardedRef,
    align,
    onCloseAutoFocus: composeEventHandlers3(props.onCloseAutoFocus, (event) => {
      const menubarOpen = Boolean(context.value);
      if (!menubarOpen && !hasInteractedOutsideRef.current) {
        menuContext.triggerRef.current?.focus();
      }
      hasInteractedOutsideRef.current = false;
      event.preventDefault();
    }),
    onFocusOutside: composeEventHandlers3(props.onFocusOutside, (event) => {
      const target = event.target;
      const isMenubarTrigger = getItems().some((item) => item.ref.current?.contains(target));
      if (isMenubarTrigger)
        event.preventDefault();
    }),
    onInteractOutside: composeEventHandlers3(props.onInteractOutside, () => {
      hasInteractedOutsideRef.current = true;
    }),
    onEntryFocus: (event) => {
      if (!menuContext.wasKeyboardTriggerOpenRef.current)
        event.preventDefault();
    },
    onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
      if (["ArrowRight", "ArrowLeft"].includes(event.key)) {
        const target = event.target;
        const targetIsSubTrigger = target.hasAttribute("data-radix-menubar-subtrigger");
        const isKeyDownInsideSubMenu = target.closest("[data-radix-menubar-content]") !== event.currentTarget;
        const prevMenuKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
        const isPrevKey = prevMenuKey === event.key;
        const isNextKey = !isPrevKey;
        if (isNextKey && targetIsSubTrigger)
          return;
        if (isKeyDownInsideSubMenu && isPrevKey)
          return;
        const items2 = getItems().filter((item) => !item.disabled);
        let candidateValues = items2.map((item) => item.value);
        if (isPrevKey)
          candidateValues.reverse();
        const currentIndex = candidateValues.indexOf(menuContext.value);
        candidateValues = context.loop ? wrapArray42(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
        const [nextValue] = candidateValues;
        if (nextValue)
          context.onMenuOpen(nextValue);
      }
    }, { checkForDefaultPrevented: false }),
    style: {
      ...props.style,
      ...{
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
MenubarContent2.displayName = CONTENT_NAME13;
var GROUP_NAME62 = "MenubarGroup";
var MenubarGroup2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...groupProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(Group22, { ...menuScope, ...groupProps, ref: forwardedRef });
});
MenubarGroup2.displayName = GROUP_NAME62;
var LABEL_NAME5 = "MenubarLabel";
var MenubarLabel2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...labelProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(Label22, { ...menuScope, ...labelProps, ref: forwardedRef });
});
MenubarLabel2.displayName = LABEL_NAME5;
var ITEM_NAME7 = "MenubarItem";
var MenubarItem2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...itemProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(Item222, { ...menuScope, ...itemProps, ref: forwardedRef });
});
MenubarItem2.displayName = ITEM_NAME7;
var CHECKBOX_ITEM_NAME4 = "MenubarCheckboxItem";
var MenubarCheckboxItem2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...checkboxItemProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(CheckboxItem2, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
MenubarCheckboxItem2.displayName = CHECKBOX_ITEM_NAME4;
var RADIO_GROUP_NAME4 = "MenubarRadioGroup";
var MenubarRadioGroup2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...radioGroupProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(RadioGroup2, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
MenubarRadioGroup2.displayName = RADIO_GROUP_NAME4;
var RADIO_ITEM_NAME4 = "MenubarRadioItem";
var MenubarRadioItem2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...radioItemProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(RadioItem2, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
MenubarRadioItem2.displayName = RADIO_ITEM_NAME4;
var INDICATOR_NAME4 = "MenubarItemIndicator";
var MenubarItemIndicator2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(ItemIndicator22, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
MenubarItemIndicator2.displayName = INDICATOR_NAME4;
var SEPARATOR_NAME5 = "MenubarSeparator";
var MenubarSeparator2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...separatorProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(Separator22, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
MenubarSeparator2.displayName = SEPARATOR_NAME5;
var ARROW_NAME9 = "MenubarArrow";
var MenubarArrow2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...arrowProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(Arrow232, { ...menuScope, ...arrowProps, ref: forwardedRef });
});
MenubarArrow2.displayName = ARROW_NAME9;
var SUB_NAME32 = "MenubarSub";
var MenubarSub2 = (props) => {
  const { __scopeMenubar, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  const [open, setOpen] = useControllableState3({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SUB_NAME32
  });
  return /* @__PURE__ */ jsx1122(Sub2, { ...menuScope, open, onOpenChange: setOpen, children });
};
MenubarSub2.displayName = SUB_NAME32;
var SUB_TRIGGER_NAME4 = "MenubarSubTrigger";
var MenubarSubTrigger2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...subTriggerProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(SubTrigger2, {
    "data-radix-menubar-subtrigger": "",
    ...menuScope,
    ...subTriggerProps,
    ref: forwardedRef
  });
});
MenubarSubTrigger2.displayName = SUB_TRIGGER_NAME4;
var SUB_CONTENT_NAME4 = "MenubarSubContent";
var MenubarSubContent2 = React722.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...subContentProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return /* @__PURE__ */ jsx1122(SubContent2, {
    ...menuScope,
    "data-radix-menubar-content": "",
    ...subContentProps,
    ref: forwardedRef,
    style: {
      ...props.style,
      ...{
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
MenubarSubContent2.displayName = SUB_CONTENT_NAME4;
function wrapArray42(array, startIndex) {
  return array.map((_2, index22) => array[(startIndex + index22) % array.length]);
}
var Root34 = Menubar2;
var Menu22 = MenubarMenu2;
var Trigger9 = MenubarTrigger2;
var Portal25 = MenubarPortal2;
var Content210 = MenubarContent2;
var Group24 = MenubarGroup2;
var Label24 = MenubarLabel2;
var Item322 = MenubarItem2;
var CheckboxItem23 = MenubarCheckboxItem2;
var RadioGroup23 = MenubarRadioGroup2;
var RadioItem23 = MenubarRadioItem2;
var ItemIndicator24 = MenubarItemIndicator2;
var Separator24 = MenubarSeparator2;
var Sub23 = MenubarSub2;
var SubTrigger23 = MenubarSubTrigger2;
var SubContent23 = MenubarSubContent2;
function Menubar22({ className, ...props }) {
  return /* @__PURE__ */ jsx113(Root34, {
    "data-slot": "menubar",
    className: clsx27("flex h-9 items-center gap-1 rounded-md border bg-background p-1 shadow-xs", className),
    ...props
  });
}
function MenubarMenu22({ ...props }) {
  return /* @__PURE__ */ jsx113(Menu22, {
    "data-slot": "menubar-menu",
    ...props
  });
}
function MenubarGroup22({ ...props }) {
  return /* @__PURE__ */ jsx113(Group24, {
    "data-slot": "menubar-group",
    ...props
  });
}
function MenubarPortal22({ ...props }) {
  return /* @__PURE__ */ jsx113(Portal25, {
    "data-slot": "menubar-portal",
    ...props
  });
}
function MenubarRadioGroup22({ ...props }) {
  return /* @__PURE__ */ jsx113(RadioGroup23, {
    "data-slot": "menubar-radio-group",
    ...props
  });
}
function MenubarTrigger22({ className, ...props }) {
  return /* @__PURE__ */ jsx113(Trigger9, {
    "data-slot": "menubar-trigger",
    className: clsx27("flex select-none items-center rounded-sm px-2 py-1 font-medium text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground", className),
    ...props
  });
}
function MenubarContent22({ className, align = "start", alignOffset = -4, sideOffset = 8, ...props }) {
  return /* @__PURE__ */ jsx113(MenubarPortal22, {
    children: /* @__PURE__ */ jsx113(Content210, {
      "data-slot": "menubar-content",
      align,
      alignOffset,
      sideOffset,
      className: clsx27("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in", className),
      ...props
    })
  });
}
function MenubarItem22({
  className,
  inset,
  variant = "default",
  ...props
}) {
  return /* @__PURE__ */ jsx113(Item322, {
    "data-slot": "menubar-item",
    "data-inset": inset,
    "data-variant": variant,
    className: clsx27("data-[variant=destructive]:*:[svg]:!text-destructive relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[inset]:pl-8 data-[variant=destructive]:text-destructive data-[disabled]:opacity-50 data-[variant=destructive]:focus:bg-destructive/10 data-[variant=destructive]:focus:text-destructive dark:data-[variant=destructive]:focus:bg-destructive/20 [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props
  });
}
function MenubarCheckboxItem22({ className, children, checked, ...props }) {
  return /* @__PURE__ */ jsxs56(CheckboxItem23, {
    "data-slot": "menubar-checkbox-item",
    className: clsx27("relative flex cursor-default select-none items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    checked,
    ...props,
    children: [
      /* @__PURE__ */ jsx113("span", {
        className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center",
        children: /* @__PURE__ */ jsx113(ItemIndicator24, {
          children: /* @__PURE__ */ jsx113(SvgIcon4, {
            iconId: "Check",
            className: "size-4"
          })
        })
      }),
      children
    ]
  });
}
function MenubarRadioItem22({ className, children, ...props }) {
  return /* @__PURE__ */ jsxs56(RadioItem23, {
    "data-slot": "menubar-radio-item",
    className: clsx27("relative flex cursor-default select-none items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props,
    children: [
      /* @__PURE__ */ jsx113("span", {
        className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center",
        children: /* @__PURE__ */ jsx113(ItemIndicator24, {
          children: /* @__PURE__ */ jsx113(SvgIcon4, {
            iconId: "Circle",
            className: "size-2 fill-current"
          })
        })
      }),
      children
    ]
  });
}
function MenubarLabel22({
  className,
  inset,
  ...props
}) {
  return /* @__PURE__ */ jsx113(Label24, {
    "data-slot": "menubar-label",
    "data-inset": inset,
    className: clsx27("px-2 py-1.5 font-medium text-sm data-[inset]:pl-8", className),
    ...props
  });
}
function MenubarSeparator22({ className, ...props }) {
  return /* @__PURE__ */ jsx113(Separator24, {
    "data-slot": "menubar-separator",
    className: clsx27("-mx-1 my-1 h-px bg-border", className),
    ...props
  });
}
function MenubarShortcut({ className, ...props }) {
  return /* @__PURE__ */ jsx113("span", {
    "data-slot": "menubar-shortcut",
    className: clsx27("ml-auto text-muted-foreground text-xs tracking-widest", className),
    ...props
  });
}
function MenubarSub22({ ...props }) {
  return /* @__PURE__ */ jsx113(Sub23, {
    "data-slot": "menubar-sub",
    ...props
  });
}
function MenubarSubTrigger22({
  className,
  inset,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxs56(SubTrigger23, {
    "data-slot": "menubar-sub-trigger",
    "data-inset": inset,
    className: clsx27("flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[inset]:pl-8 data-[state=open]:text-accent-foreground", className),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsx113(SvgIcon4, {
        iconId: "ChevronRight",
        className: "ml-auto h-4 w-4"
      })
    ]
  });
}
function MenubarSubContent22({ className, ...props }) {
  return /* @__PURE__ */ jsx113(SubContent23, {
    "data-slot": "menubar-sub-content",
    className: clsx27("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=closed]:animate-out data-[state=open]:animate-in", className),
    ...props
  });
}
var import_react_dom32 = __toESM3(require_react_dom2(), 1);
var NAVIGATION_MENU_NAME = "NavigationMenu";
var [Collection62, useCollection62, createCollectionScope62] = createCollection3(NAVIGATION_MENU_NAME);
var [FocusGroupCollection, useFocusGroupCollection, createFocusGroupCollectionScope] = createCollection3(NAVIGATION_MENU_NAME);
var [createNavigationMenuContext, createNavigationMenuScope] = createContextScope3(NAVIGATION_MENU_NAME, [createCollectionScope62, createFocusGroupCollectionScope]);
var [NavigationMenuProviderImpl, useNavigationMenuContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);
var [ViewportContentProvider, useViewportContentContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);
var NavigationMenu = React73.forwardRef((props, forwardedRef) => {
  const {
    __scopeNavigationMenu,
    value: valueProp,
    onValueChange,
    defaultValue,
    delayDuration = 200,
    skipDelayDuration = 300,
    orientation = "horizontal",
    dir,
    ...NavigationMenuProps
  } = props;
  const [navigationMenu, setNavigationMenu] = React73.useState(null);
  const composedRef = useComposedRefs3(forwardedRef, (node) => setNavigationMenu(node));
  const direction = useDirection3(dir);
  const openTimerRef = React73.useRef(0);
  const closeTimerRef = React73.useRef(0);
  const skipDelayTimerRef = React73.useRef(0);
  const [isOpenDelayed, setIsOpenDelayed] = React73.useState(true);
  const [value, setValue] = useControllableState3({
    prop: valueProp,
    onChange: (value2) => {
      const isOpen = value2 !== "";
      const hasSkipDelayDuration = skipDelayDuration > 0;
      if (isOpen) {
        window.clearTimeout(skipDelayTimerRef.current);
        if (hasSkipDelayDuration)
          setIsOpenDelayed(false);
      } else {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(() => setIsOpenDelayed(true), skipDelayDuration);
      }
      onValueChange?.(value2);
    },
    defaultProp: defaultValue ?? "",
    caller: NAVIGATION_MENU_NAME
  });
  const startCloseTimer = React73.useCallback(() => {
    window.clearTimeout(closeTimerRef.current);
    closeTimerRef.current = window.setTimeout(() => setValue(""), 150);
  }, [setValue]);
  const handleOpen = React73.useCallback((itemValue) => {
    window.clearTimeout(closeTimerRef.current);
    setValue(itemValue);
  }, [setValue]);
  const handleDelayedOpen = React73.useCallback((itemValue) => {
    const isOpenItem = value === itemValue;
    if (isOpenItem) {
      window.clearTimeout(closeTimerRef.current);
    } else {
      openTimerRef.current = window.setTimeout(() => {
        window.clearTimeout(closeTimerRef.current);
        setValue(itemValue);
      }, delayDuration);
    }
  }, [value, setValue, delayDuration]);
  React73.useEffect(() => {
    return () => {
      window.clearTimeout(openTimerRef.current);
      window.clearTimeout(closeTimerRef.current);
      window.clearTimeout(skipDelayTimerRef.current);
    };
  }, []);
  return /* @__PURE__ */ jsx116(NavigationMenuProvider, {
    scope: __scopeNavigationMenu,
    isRootMenu: true,
    value,
    dir: direction,
    orientation,
    rootNavigationMenu: navigationMenu,
    onTriggerEnter: (itemValue) => {
      window.clearTimeout(openTimerRef.current);
      if (isOpenDelayed)
        handleDelayedOpen(itemValue);
      else
        handleOpen(itemValue);
    },
    onTriggerLeave: () => {
      window.clearTimeout(openTimerRef.current);
      startCloseTimer();
    },
    onContentEnter: () => window.clearTimeout(closeTimerRef.current),
    onContentLeave: startCloseTimer,
    onItemSelect: (itemValue) => {
      setValue((prevValue) => prevValue === itemValue ? "" : itemValue);
    },
    onItemDismiss: () => setValue(""),
    children: /* @__PURE__ */ jsx116(Primitive3.nav, {
      "aria-label": "Main",
      "data-orientation": orientation,
      dir: direction,
      ...NavigationMenuProps,
      ref: composedRef
    })
  });
});
NavigationMenu.displayName = NAVIGATION_MENU_NAME;
var SUB_NAME4 = "NavigationMenuSub";
var NavigationMenuSub = React73.forwardRef((props, forwardedRef) => {
  const {
    __scopeNavigationMenu,
    value: valueProp,
    onValueChange,
    defaultValue,
    orientation = "horizontal",
    ...subProps
  } = props;
  const context = useNavigationMenuContext(SUB_NAME4, __scopeNavigationMenu);
  const [value, setValue] = useControllableState3({
    prop: valueProp,
    onChange: onValueChange,
    defaultProp: defaultValue ?? "",
    caller: SUB_NAME4
  });
  return /* @__PURE__ */ jsx116(NavigationMenuProvider, {
    scope: __scopeNavigationMenu,
    isRootMenu: false,
    value,
    dir: context.dir,
    orientation,
    rootNavigationMenu: context.rootNavigationMenu,
    onTriggerEnter: (itemValue) => setValue(itemValue),
    onItemSelect: (itemValue) => setValue(itemValue),
    onItemDismiss: () => setValue(""),
    children: /* @__PURE__ */ jsx116(Primitive3.div, { "data-orientation": orientation, ...subProps, ref: forwardedRef })
  });
});
NavigationMenuSub.displayName = SUB_NAME4;
var NavigationMenuProvider = (props) => {
  const {
    scope,
    isRootMenu,
    rootNavigationMenu,
    dir,
    orientation,
    children,
    value,
    onItemSelect,
    onItemDismiss,
    onTriggerEnter,
    onTriggerLeave,
    onContentEnter,
    onContentLeave
  } = props;
  const [viewport, setViewport] = React73.useState(null);
  const [viewportContent, setViewportContent] = React73.useState(/* @__PURE__ */ new Map);
  const [indicatorTrack, setIndicatorTrack] = React73.useState(null);
  return /* @__PURE__ */ jsx116(NavigationMenuProviderImpl, {
    scope,
    isRootMenu,
    rootNavigationMenu,
    value,
    previousValue: usePrevious(value),
    baseId: useId3(),
    dir,
    orientation,
    viewport,
    onViewportChange: setViewport,
    indicatorTrack,
    onIndicatorTrackChange: setIndicatorTrack,
    onTriggerEnter: useCallbackRef6(onTriggerEnter),
    onTriggerLeave: useCallbackRef6(onTriggerLeave),
    onContentEnter: useCallbackRef6(onContentEnter),
    onContentLeave: useCallbackRef6(onContentLeave),
    onItemSelect: useCallbackRef6(onItemSelect),
    onItemDismiss: useCallbackRef6(onItemDismiss),
    onViewportContentChange: React73.useCallback((contentValue, contentData) => {
      setViewportContent((prevContent) => {
        prevContent.set(contentValue, contentData);
        return new Map(prevContent);
      });
    }, []),
    onViewportContentRemove: React73.useCallback((contentValue) => {
      setViewportContent((prevContent) => {
        if (!prevContent.has(contentValue))
          return prevContent;
        prevContent.delete(contentValue);
        return new Map(prevContent);
      });
    }, []),
    children: /* @__PURE__ */ jsx116(Collection62.Provider, { scope, children: /* @__PURE__ */ jsx116(ViewportContentProvider, { scope, items: viewportContent, children }) })
  });
};
var LIST_NAME = "NavigationMenuList";
var NavigationMenuList = React73.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, ...listProps } = props;
  const context = useNavigationMenuContext(LIST_NAME, __scopeNavigationMenu);
  const list = /* @__PURE__ */ jsx116(Primitive3.ul, { "data-orientation": context.orientation, ...listProps, ref: forwardedRef });
  return /* @__PURE__ */ jsx116(Primitive3.div, { style: { position: "relative" }, ref: context.onIndicatorTrackChange, children: /* @__PURE__ */ jsx116(Collection62.Slot, { scope: __scopeNavigationMenu, children: context.isRootMenu ? /* @__PURE__ */ jsx116(FocusGroup, { asChild: true, children: list }) : list }) });
});
NavigationMenuList.displayName = LIST_NAME;
var ITEM_NAME8 = "NavigationMenuItem";
var [NavigationMenuItemContextProvider, useNavigationMenuItemContext] = createNavigationMenuContext(ITEM_NAME8);
var NavigationMenuItem = React73.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, value: valueProp, ...itemProps } = props;
  const autoValue = useId3();
  const value = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
  const contentRef = React73.useRef(null);
  const triggerRef = React73.useRef(null);
  const focusProxyRef = React73.useRef(null);
  const restoreContentTabOrderRef = React73.useRef(() => {});
  const wasEscapeCloseRef = React73.useRef(false);
  const handleContentEntry = React73.useCallback((side = "start") => {
    if (contentRef.current) {
      restoreContentTabOrderRef.current();
      const candidates = getTabbableCandidates22(contentRef.current);
      if (candidates.length)
        focusFirst42(side === "start" ? candidates : candidates.reverse());
    }
  }, []);
  const handleContentExit = React73.useCallback(() => {
    if (contentRef.current) {
      const candidates = getTabbableCandidates22(contentRef.current);
      if (candidates.length)
        restoreContentTabOrderRef.current = removeFromTabOrder(candidates);
    }
  }, []);
  return /* @__PURE__ */ jsx116(NavigationMenuItemContextProvider, {
    scope: __scopeNavigationMenu,
    value,
    triggerRef,
    contentRef,
    focusProxyRef,
    wasEscapeCloseRef,
    onEntryKeyDown: handleContentEntry,
    onFocusProxyEnter: handleContentEntry,
    onRootContentClose: handleContentExit,
    onContentFocusOutside: handleContentExit,
    children: /* @__PURE__ */ jsx116(Primitive3.li, { ...itemProps, ref: forwardedRef })
  });
});
NavigationMenuItem.displayName = ITEM_NAME8;
var TRIGGER_NAME13 = "NavigationMenuTrigger";
var NavigationMenuTrigger = React73.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, disabled, ...triggerProps } = props;
  const context = useNavigationMenuContext(TRIGGER_NAME13, props.__scopeNavigationMenu);
  const itemContext = useNavigationMenuItemContext(TRIGGER_NAME13, props.__scopeNavigationMenu);
  const ref = React73.useRef(null);
  const composedRefs = useComposedRefs3(ref, itemContext.triggerRef, forwardedRef);
  const triggerId = makeTriggerId(context.baseId, itemContext.value);
  const contentId = makeContentId(context.baseId, itemContext.value);
  const hasPointerMoveOpenedRef = React73.useRef(false);
  const wasClickCloseRef = React73.useRef(false);
  const open = itemContext.value === context.value;
  return /* @__PURE__ */ jsxs59(Fragment122, { children: [
    /* @__PURE__ */ jsx116(Collection62.ItemSlot, { scope: __scopeNavigationMenu, value: itemContext.value, children: /* @__PURE__ */ jsx116(FocusGroupItem, { asChild: true, children: /* @__PURE__ */ jsx116(Primitive3.button, {
      id: triggerId,
      disabled,
      "data-disabled": disabled ? "" : undefined,
      "data-state": getOpenState22(open),
      "aria-expanded": open,
      "aria-controls": contentId,
      ...triggerProps,
      ref: composedRefs,
      onPointerEnter: composeEventHandlers3(props.onPointerEnter, () => {
        wasClickCloseRef.current = false;
        itemContext.wasEscapeCloseRef.current = false;
      }),
      onPointerMove: composeEventHandlers3(props.onPointerMove, whenMouse22(() => {
        if (disabled || wasClickCloseRef.current || itemContext.wasEscapeCloseRef.current || hasPointerMoveOpenedRef.current)
          return;
        context.onTriggerEnter(itemContext.value);
        hasPointerMoveOpenedRef.current = true;
      })),
      onPointerLeave: composeEventHandlers3(props.onPointerLeave, whenMouse22(() => {
        if (disabled)
          return;
        context.onTriggerLeave();
        hasPointerMoveOpenedRef.current = false;
      })),
      onClick: composeEventHandlers3(props.onClick, () => {
        context.onItemSelect(itemContext.value);
        wasClickCloseRef.current = open;
      }),
      onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
        const verticalEntryKey = context.dir === "rtl" ? "ArrowLeft" : "ArrowRight";
        const entryKey = { horizontal: "ArrowDown", vertical: verticalEntryKey }[context.orientation];
        if (open && event.key === entryKey) {
          itemContext.onEntryKeyDown();
          event.preventDefault();
        }
      })
    }) }) }),
    open && /* @__PURE__ */ jsxs59(Fragment122, { children: [
      /* @__PURE__ */ jsx116(Root33, {
        "aria-hidden": true,
        tabIndex: 0,
        ref: itemContext.focusProxyRef,
        onFocus: (event) => {
          const content = itemContext.contentRef.current;
          const prevFocusedElement = event.relatedTarget;
          const wasTriggerFocused = prevFocusedElement === ref.current;
          const wasFocusFromContent = content?.contains(prevFocusedElement);
          if (wasTriggerFocused || !wasFocusFromContent) {
            itemContext.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
          }
        }
      }),
      context.viewport && /* @__PURE__ */ jsx116("span", { "aria-owns": contentId })
    ] })
  ] });
});
NavigationMenuTrigger.displayName = TRIGGER_NAME13;
var LINK_NAME = "NavigationMenuLink";
var LINK_SELECT = "navigationMenu.linkSelect";
var NavigationMenuLink = React73.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, active, onSelect, ...linkProps } = props;
  return /* @__PURE__ */ jsx116(FocusGroupItem, { asChild: true, children: /* @__PURE__ */ jsx116(Primitive3.a, {
    "data-active": active ? "" : undefined,
    "aria-current": active ? "page" : undefined,
    ...linkProps,
    ref: forwardedRef,
    onClick: composeEventHandlers3(props.onClick, (event) => {
      const target = event.target;
      const linkSelectEvent = new CustomEvent(LINK_SELECT, {
        bubbles: true,
        cancelable: true
      });
      target.addEventListener(LINK_SELECT, (event2) => onSelect?.(event2), { once: true });
      dispatchDiscreteCustomEvent3(target, linkSelectEvent);
      if (!linkSelectEvent.defaultPrevented && !event.metaKey) {
        const rootContentDismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {
          bubbles: true,
          cancelable: true
        });
        dispatchDiscreteCustomEvent3(target, rootContentDismissEvent);
      }
    }, { checkForDefaultPrevented: false })
  }) });
});
NavigationMenuLink.displayName = LINK_NAME;
var INDICATOR_NAME5 = "NavigationMenuIndicator";
var NavigationMenuIndicator = React73.forwardRef((props, forwardedRef) => {
  const { forceMount, ...indicatorProps } = props;
  const context = useNavigationMenuContext(INDICATOR_NAME5, props.__scopeNavigationMenu);
  const isVisible = Boolean(context.value);
  return context.indicatorTrack ? import_react_dom32.default.createPortal(/* @__PURE__ */ jsx116(Presence3, { present: forceMount || isVisible, children: /* @__PURE__ */ jsx116(NavigationMenuIndicatorImpl, { ...indicatorProps, ref: forwardedRef }) }), context.indicatorTrack) : null;
});
NavigationMenuIndicator.displayName = INDICATOR_NAME5;
var NavigationMenuIndicatorImpl = React73.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, ...indicatorProps } = props;
  const context = useNavigationMenuContext(INDICATOR_NAME5, __scopeNavigationMenu);
  const getItems = useCollection62(__scopeNavigationMenu);
  const [activeTrigger, setActiveTrigger] = React73.useState(null);
  const [position, setPosition] = React73.useState(null);
  const isHorizontal = context.orientation === "horizontal";
  const isVisible = Boolean(context.value);
  React73.useEffect(() => {
    const items2 = getItems();
    const triggerNode = items2.find((item) => item.value === context.value)?.ref.current;
    if (triggerNode)
      setActiveTrigger(triggerNode);
  }, [getItems, context.value]);
  const handlePositionChange = () => {
    if (activeTrigger) {
      setPosition({
        size: isHorizontal ? activeTrigger.offsetWidth : activeTrigger.offsetHeight,
        offset: isHorizontal ? activeTrigger.offsetLeft : activeTrigger.offsetTop
      });
    }
  };
  useResizeObserver(activeTrigger, handlePositionChange);
  useResizeObserver(context.indicatorTrack, handlePositionChange);
  return position ? /* @__PURE__ */ jsx116(Primitive3.div, {
    "aria-hidden": true,
    "data-state": isVisible ? "visible" : "hidden",
    "data-orientation": context.orientation,
    ...indicatorProps,
    ref: forwardedRef,
    style: {
      position: "absolute",
      ...isHorizontal ? {
        left: 0,
        width: position.size + "px",
        transform: `translateX(${position.offset}px)`
      } : {
        top: 0,
        height: position.size + "px",
        transform: `translateY(${position.offset}px)`
      },
      ...indicatorProps.style
    }
  }) : null;
});
var CONTENT_NAME14 = "NavigationMenuContent";
var NavigationMenuContent = React73.forwardRef((props, forwardedRef) => {
  const { forceMount, ...contentProps } = props;
  const context = useNavigationMenuContext(CONTENT_NAME14, props.__scopeNavigationMenu);
  const itemContext = useNavigationMenuItemContext(CONTENT_NAME14, props.__scopeNavigationMenu);
  const composedRefs = useComposedRefs3(itemContext.contentRef, forwardedRef);
  const open = itemContext.value === context.value;
  const commonProps = {
    value: itemContext.value,
    triggerRef: itemContext.triggerRef,
    focusProxyRef: itemContext.focusProxyRef,
    wasEscapeCloseRef: itemContext.wasEscapeCloseRef,
    onContentFocusOutside: itemContext.onContentFocusOutside,
    onRootContentClose: itemContext.onRootContentClose,
    ...contentProps
  };
  return !context.viewport ? /* @__PURE__ */ jsx116(Presence3, { present: forceMount || open, children: /* @__PURE__ */ jsx116(NavigationMenuContentImpl, {
    "data-state": getOpenState22(open),
    ...commonProps,
    ref: composedRefs,
    onPointerEnter: composeEventHandlers3(props.onPointerEnter, context.onContentEnter),
    onPointerLeave: composeEventHandlers3(props.onPointerLeave, whenMouse22(context.onContentLeave)),
    style: {
      pointerEvents: !open && context.isRootMenu ? "none" : undefined,
      ...commonProps.style
    }
  }) }) : /* @__PURE__ */ jsx116(ViewportContentMounter, { forceMount, ...commonProps, ref: composedRefs });
});
NavigationMenuContent.displayName = CONTENT_NAME14;
var ViewportContentMounter = React73.forwardRef((props, forwardedRef) => {
  const context = useNavigationMenuContext(CONTENT_NAME14, props.__scopeNavigationMenu);
  const { onViewportContentChange, onViewportContentRemove } = context;
  useLayoutEffect24(() => {
    onViewportContentChange(props.value, {
      ref: forwardedRef,
      ...props
    });
  }, [props, forwardedRef, onViewportContentChange]);
  useLayoutEffect24(() => {
    return () => onViewportContentRemove(props.value);
  }, [props.value, onViewportContentRemove]);
  return null;
});
var ROOT_CONTENT_DISMISS = "navigationMenu.rootContentDismiss";
var NavigationMenuContentImpl = React73.forwardRef((props, forwardedRef) => {
  const {
    __scopeNavigationMenu,
    value,
    triggerRef,
    focusProxyRef,
    wasEscapeCloseRef,
    onRootContentClose,
    onContentFocusOutside,
    ...contentProps
  } = props;
  const context = useNavigationMenuContext(CONTENT_NAME14, __scopeNavigationMenu);
  const ref = React73.useRef(null);
  const composedRefs = useComposedRefs3(ref, forwardedRef);
  const triggerId = makeTriggerId(context.baseId, value);
  const contentId = makeContentId(context.baseId, value);
  const getItems = useCollection62(__scopeNavigationMenu);
  const prevMotionAttributeRef = React73.useRef(null);
  const { onItemDismiss } = context;
  React73.useEffect(() => {
    const content = ref.current;
    if (context.isRootMenu && content) {
      const handleClose = () => {
        onItemDismiss();
        onRootContentClose();
        if (content.contains(document.activeElement))
          triggerRef.current?.focus();
      };
      content.addEventListener(ROOT_CONTENT_DISMISS, handleClose);
      return () => content.removeEventListener(ROOT_CONTENT_DISMISS, handleClose);
    }
  }, [context.isRootMenu, props.value, triggerRef, onItemDismiss, onRootContentClose]);
  const motionAttribute = React73.useMemo(() => {
    const items2 = getItems();
    const values = items2.map((item) => item.value);
    if (context.dir === "rtl")
      values.reverse();
    const index22 = values.indexOf(context.value);
    const prevIndex = values.indexOf(context.previousValue);
    const isSelected = value === context.value;
    const wasSelected = prevIndex === values.indexOf(value);
    if (!isSelected && !wasSelected)
      return prevMotionAttributeRef.current;
    const attribute = (() => {
      if (index22 !== prevIndex) {
        if (isSelected && prevIndex !== -1)
          return index22 > prevIndex ? "from-end" : "from-start";
        if (wasSelected && index22 !== -1)
          return index22 > prevIndex ? "to-start" : "to-end";
      }
      return null;
    })();
    prevMotionAttributeRef.current = attribute;
    return attribute;
  }, [context.previousValue, context.value, context.dir, getItems, value]);
  return /* @__PURE__ */ jsx116(FocusGroup, { asChild: true, children: /* @__PURE__ */ jsx116(DismissableLayer3, {
    id: contentId,
    "aria-labelledby": triggerId,
    "data-motion": motionAttribute,
    "data-orientation": context.orientation,
    ...contentProps,
    ref: composedRefs,
    disableOutsidePointerEvents: false,
    onDismiss: () => {
      const rootContentDismissEvent = new Event(ROOT_CONTENT_DISMISS, {
        bubbles: true,
        cancelable: true
      });
      ref.current?.dispatchEvent(rootContentDismissEvent);
    },
    onFocusOutside: composeEventHandlers3(props.onFocusOutside, (event) => {
      onContentFocusOutside();
      const target = event.target;
      if (context.rootNavigationMenu?.contains(target))
        event.preventDefault();
    }),
    onPointerDownOutside: composeEventHandlers3(props.onPointerDownOutside, (event) => {
      const target = event.target;
      const isTrigger = getItems().some((item) => item.ref.current?.contains(target));
      const isRootViewport = context.isRootMenu && context.viewport?.contains(target);
      if (isTrigger || isRootViewport || !context.isRootMenu)
        event.preventDefault();
    }),
    onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
      const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
      const isTabKey = event.key === "Tab" && !isMetaKey;
      if (isTabKey) {
        const candidates = getTabbableCandidates22(event.currentTarget);
        const focusedElement = document.activeElement;
        const index22 = candidates.findIndex((candidate) => candidate === focusedElement);
        const isMovingBackwards = event.shiftKey;
        const nextCandidates = isMovingBackwards ? candidates.slice(0, index22).reverse() : candidates.slice(index22 + 1, candidates.length);
        if (focusFirst42(nextCandidates)) {
          event.preventDefault();
        } else {
          focusProxyRef.current?.focus();
        }
      }
    }),
    onEscapeKeyDown: composeEventHandlers3(props.onEscapeKeyDown, (_event) => {
      wasEscapeCloseRef.current = true;
    })
  }) });
});
var VIEWPORT_NAME2 = "NavigationMenuViewport";
var NavigationMenuViewport = React73.forwardRef((props, forwardedRef) => {
  const { forceMount, ...viewportProps } = props;
  const context = useNavigationMenuContext(VIEWPORT_NAME2, props.__scopeNavigationMenu);
  const open = Boolean(context.value);
  return /* @__PURE__ */ jsx116(Presence3, { present: forceMount || open, children: /* @__PURE__ */ jsx116(NavigationMenuViewportImpl, { ...viewportProps, ref: forwardedRef }) });
});
NavigationMenuViewport.displayName = VIEWPORT_NAME2;
var NavigationMenuViewportImpl = React73.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, children, ...viewportImplProps } = props;
  const context = useNavigationMenuContext(VIEWPORT_NAME2, __scopeNavigationMenu);
  const composedRefs = useComposedRefs3(forwardedRef, context.onViewportChange);
  const viewportContentContext = useViewportContentContext(CONTENT_NAME14, props.__scopeNavigationMenu);
  const [size42, setSize] = React73.useState(null);
  const [content, setContent] = React73.useState(null);
  const viewportWidth = size42 ? size42?.width + "px" : undefined;
  const viewportHeight = size42 ? size42?.height + "px" : undefined;
  const open = Boolean(context.value);
  const activeContentValue = open ? context.value : context.previousValue;
  const handleSizeChange = () => {
    if (content)
      setSize({ width: content.offsetWidth, height: content.offsetHeight });
  };
  useResizeObserver(content, handleSizeChange);
  return /* @__PURE__ */ jsx116(Primitive3.div, {
    "data-state": getOpenState22(open),
    "data-orientation": context.orientation,
    ...viewportImplProps,
    ref: composedRefs,
    style: {
      pointerEvents: !open && context.isRootMenu ? "none" : undefined,
      ["--radix-navigation-menu-viewport-width"]: viewportWidth,
      ["--radix-navigation-menu-viewport-height"]: viewportHeight,
      ...viewportImplProps.style
    },
    onPointerEnter: composeEventHandlers3(props.onPointerEnter, context.onContentEnter),
    onPointerLeave: composeEventHandlers3(props.onPointerLeave, whenMouse22(context.onContentLeave)),
    children: Array.from(viewportContentContext.items).map(([value, { ref, forceMount, ...props2 }]) => {
      const isActive = activeContentValue === value;
      return /* @__PURE__ */ jsx116(Presence3, { present: forceMount || isActive, children: /* @__PURE__ */ jsx116(NavigationMenuContentImpl, {
        ...props2,
        ref: composeRefs3(ref, (node) => {
          if (isActive && node)
            setContent(node);
        })
      }) }, value);
    })
  });
});
var FOCUS_GROUP_NAME = "FocusGroup";
var FocusGroup = React73.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, ...groupProps } = props;
  const context = useNavigationMenuContext(FOCUS_GROUP_NAME, __scopeNavigationMenu);
  return /* @__PURE__ */ jsx116(FocusGroupCollection.Provider, { scope: __scopeNavigationMenu, children: /* @__PURE__ */ jsx116(FocusGroupCollection.Slot, { scope: __scopeNavigationMenu, children: /* @__PURE__ */ jsx116(Primitive3.div, { dir: context.dir, ...groupProps, ref: forwardedRef }) }) });
});
var ARROW_KEYS = ["ArrowRight", "ArrowLeft", "ArrowUp", "ArrowDown"];
var FOCUS_GROUP_ITEM_NAME = "FocusGroupItem";
var FocusGroupItem = React73.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, ...groupProps } = props;
  const getItems = useFocusGroupCollection(__scopeNavigationMenu);
  const context = useNavigationMenuContext(FOCUS_GROUP_ITEM_NAME, __scopeNavigationMenu);
  return /* @__PURE__ */ jsx116(FocusGroupCollection.ItemSlot, { scope: __scopeNavigationMenu, children: /* @__PURE__ */ jsx116(Primitive3.button, {
    ...groupProps,
    ref: forwardedRef,
    onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
      const isFocusNavigationKey = ["Home", "End", ...ARROW_KEYS].includes(event.key);
      if (isFocusNavigationKey) {
        let candidateNodes = getItems().map((item) => item.ref.current);
        const prevItemKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
        const prevKeys = [prevItemKey, "ArrowUp", "End"];
        if (prevKeys.includes(event.key))
          candidateNodes.reverse();
        if (ARROW_KEYS.includes(event.key)) {
          const currentIndex = candidateNodes.indexOf(event.currentTarget);
          candidateNodes = candidateNodes.slice(currentIndex + 1);
        }
        setTimeout(() => focusFirst42(candidateNodes));
        event.preventDefault();
      }
    })
  }) });
});
function getTabbableCandidates22(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst42(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement)
      return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef6(onResize);
  useLayoutEffect24(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
function getOpenState22(open) {
  return open ? "open" : "closed";
}
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
function whenMouse22(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : undefined;
}
var Root29 = NavigationMenu;
var List = NavigationMenuList;
var Item4 = NavigationMenuItem;
var Trigger10 = NavigationMenuTrigger;
var Link32 = NavigationMenuLink;
var Indicator = NavigationMenuIndicator;
var Content6 = NavigationMenuContent;
var Viewport2 = NavigationMenuViewport;
function NavigationMenu2({
  className,
  children,
  viewport = true,
  ...props
}) {
  return /* @__PURE__ */ jsxs60(Root29, {
    "data-slot": "navigation-menu",
    "data-viewport": viewport,
    className: clsx28("group/navigation-menu relative flex max-w-max flex-1 items-center justify-center", className),
    ...props,
    children: [
      children,
      viewport && /* @__PURE__ */ jsx117(NavigationMenuViewport2, {})
    ]
  });
}
function NavigationMenuList2({ className, ...props }) {
  return /* @__PURE__ */ jsx117(List, {
    "data-slot": "navigation-menu-list",
    className: clsx28("group flex flex-1 list-none items-center justify-center gap-1", className),
    ...props
  });
}
function NavigationMenuItem2({ className, ...props }) {
  return /* @__PURE__ */ jsx117(Item4, {
    "data-slot": "navigation-menu-item",
    className: clsx28("relative", className),
    ...props
  });
}
var navigationMenuTriggerStyle = cva("group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 outline-none transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1");
function NavigationMenuTrigger2({ className, children, ...props }) {
  return /* @__PURE__ */ jsxs60(Trigger10, {
    "data-slot": "navigation-menu-trigger",
    className: clsx28(navigationMenuTriggerStyle(), "group", className),
    ...props,
    children: [
      children,
      " ",
      /* @__PURE__ */ jsx117(SvgIcon4, {
        iconId: "ChevronDown",
        className: "relative top-[1px] ml-1 size-3 transition duration-300 group-data-[state=open]:rotate-180",
        "aria-hidden": "true"
      })
    ]
  });
}
function NavigationMenuContent2({ className, ...props }) {
  return /* @__PURE__ */ jsx117(Content6, {
    "data-slot": "navigation-menu-content",
    className: clsx28("data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 top-0 left-0 w-full p-2 pr-2.5 data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out md:absolute md:w-auto", "group-data-[viewport=false]/navigation-menu:data-[state=closed]:zoom-out-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:zoom-in-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:fade-in-0 group-data-[viewport=false]/navigation-menu:data-[state=closed]:fade-out-0 **:data-[slot=navigation-menu-link]:focus:outline-none **:data-[slot=navigation-menu-link]:focus:ring-0 group-data-[viewport=false]/navigation-menu:top-full group-data-[viewport=false]/navigation-menu:mt-1.5 group-data-[viewport=false]/navigation-menu:overflow-hidden group-data-[viewport=false]/navigation-menu:rounded-md group-data-[viewport=false]/navigation-menu:border group-data-[viewport=false]/navigation-menu:bg-popover group-data-[viewport=false]/navigation-menu:text-popover-foreground group-data-[viewport=false]/navigation-menu:shadow group-data-[viewport=false]/navigation-menu:duration-200 group-data-[viewport=false]/navigation-menu:data-[state=closed]:animate-out group-data-[viewport=false]/navigation-menu:data-[state=open]:animate-in", className),
    ...props
  });
}
function NavigationMenuViewport2({ className, ...props }) {
  return /* @__PURE__ */ jsx117("div", {
    className: clsx28("absolute top-full left-0 isolate z-50 flex justify-center"),
    children: /* @__PURE__ */ jsx117(Viewport2, {
      "data-slot": "navigation-menu-viewport",
      className: clsx28("data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full origin-top-center overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=closed]:animate-out data-[state=open]:animate-in md:w-[var(--radix-navigation-menu-viewport-width)]", className),
      ...props
    })
  });
}
function NavigationMenuLink2({ className, ...props }) {
  return /* @__PURE__ */ jsx117(Link32, {
    "data-slot": "navigation-menu-link",
    className: clsx28("flex flex-col gap-1 rounded-sm p-2 text-sm outline-none transition-all hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus-visible:outline-1 focus-visible:ring-[3px] focus-visible:ring-ring/50 data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground", className),
    ...props
  });
}
function NavigationMenuIndicator2({ className, ...props }) {
  return /* @__PURE__ */ jsx117(Indicator, {
    "data-slot": "navigation-menu-indicator",
    className: clsx28("data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=hidden]:animate-out data-[state=visible]:animate-in", className),
    ...props,
    children: /* @__PURE__ */ jsx117("div", {
      className: "relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md"
    })
  });
}
var PROGRESS_NAME = "Progress";
var DEFAULT_MAX = 100;
var [createProgressContext, createProgressScope] = createContextScope3(PROGRESS_NAME);
var [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME);
var Progress = React75.forwardRef((props, forwardedRef) => {
  const {
    __scopeProgress,
    value: valueProp = null,
    max: maxProp,
    getValueLabel = defaultGetValueLabel,
    ...progressProps
  } = props;
  if ((maxProp || maxProp === 0) && !isValidMaxNumber(maxProp)) {
    console.error(getInvalidMaxError(`${maxProp}`, "Progress"));
  }
  const max22 = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;
  if (valueProp !== null && !isValidValueNumber(valueProp, max22)) {
    console.error(getInvalidValueError(`${valueProp}`, "Progress"));
  }
  const value = isValidValueNumber(valueProp, max22) ? valueProp : null;
  const valueLabel = isNumber(value) ? getValueLabel(value, max22) : undefined;
  return /* @__PURE__ */ jsx121(ProgressProvider, { scope: __scopeProgress, value, max: max22, children: /* @__PURE__ */ jsx121(Primitive3.div, {
    "aria-valuemax": max22,
    "aria-valuemin": 0,
    "aria-valuenow": isNumber(value) ? value : undefined,
    "aria-valuetext": valueLabel,
    role: "progressbar",
    "data-state": getProgressState(value, max22),
    "data-value": value ?? undefined,
    "data-max": max22,
    ...progressProps,
    ref: forwardedRef
  }) });
});
Progress.displayName = PROGRESS_NAME;
var INDICATOR_NAME6 = "ProgressIndicator";
var ProgressIndicator = React75.forwardRef((props, forwardedRef) => {
  const { __scopeProgress, ...indicatorProps } = props;
  const context = useProgressContext(INDICATOR_NAME6, __scopeProgress);
  return /* @__PURE__ */ jsx121(Primitive3.div, {
    "data-state": getProgressState(context.value, context.max),
    "data-value": context.value ?? undefined,
    "data-max": context.max,
    ...indicatorProps,
    ref: forwardedRef
  });
});
ProgressIndicator.displayName = INDICATOR_NAME6;
function defaultGetValueLabel(value, max22) {
  return `${Math.round(value / max22 * 100)}%`;
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function isNumber(value) {
  return typeof value === "number";
}
function isValidMaxNumber(max22) {
  return isNumber(max22) && !isNaN(max22) && max22 > 0;
}
function isValidValueNumber(value, max22) {
  return isNumber(value) && !isNaN(value) && value <= max22 && value >= 0;
}
function getInvalidMaxError(propValue, componentName) {
  return `Invalid prop \`max\` of value \`${propValue}\` supplied to \`${componentName}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`;
}
function getInvalidValueError(propValue, componentName) {
  return `Invalid prop \`value\` of value \`${propValue}\` supplied to \`${componentName}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
var RADIO_NAME = "Radio";
var [createRadioContext, createRadioScope] = createContextScope3(RADIO_NAME);
var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
var Radio = React77.forwardRef((props, forwardedRef) => {
  const {
    __scopeRadio,
    name,
    checked = false,
    required,
    disabled,
    value = "on",
    onCheck,
    form,
    ...radioProps
  } = props;
  const [button, setButton] = React77.useState(null);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setButton(node));
  const hasConsumerStoppedPropagationRef = React77.useRef(false);
  const isFormControl = button ? form || !!button.closest("form") : true;
  return /* @__PURE__ */ jsxs64(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
    /* @__PURE__ */ jsx124(Primitive3.button, {
      type: "button",
      role: "radio",
      "aria-checked": checked,
      "data-state": getState6(checked),
      "data-disabled": disabled ? "" : undefined,
      disabled,
      value,
      ...radioProps,
      ref: composedRefs,
      onClick: composeEventHandlers3(props.onClick, (event) => {
        if (!checked)
          onCheck?.();
        if (isFormControl) {
          hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
          if (!hasConsumerStoppedPropagationRef.current)
            event.stopPropagation();
        }
      })
    }),
    isFormControl && /* @__PURE__ */ jsx124(RadioBubbleInput, {
      control: button,
      bubbles: !hasConsumerStoppedPropagationRef.current,
      name,
      value,
      checked,
      required,
      disabled,
      form,
      style: { transform: "translateX(-100%)" }
    })
  ] });
});
Radio.displayName = RADIO_NAME;
var INDICATOR_NAME7 = "RadioIndicator";
var RadioIndicator = React77.forwardRef((props, forwardedRef) => {
  const { __scopeRadio, forceMount, ...indicatorProps } = props;
  const context = useRadioContext(INDICATOR_NAME7, __scopeRadio);
  return /* @__PURE__ */ jsx124(Presence3, { present: forceMount || context.checked, children: /* @__PURE__ */ jsx124(Primitive3.span, {
    "data-state": getState6(context.checked),
    "data-disabled": context.disabled ? "" : undefined,
    ...indicatorProps,
    ref: forwardedRef
  }) });
});
RadioIndicator.displayName = INDICATOR_NAME7;
var BUBBLE_INPUT_NAME3 = "RadioBubbleInput";
var RadioBubbleInput = React77.forwardRef(({
  __scopeRadio,
  control,
  checked,
  bubbles = true,
  ...props
}, forwardedRef) => {
  const ref = React77.useRef(null);
  const composedRefs = useComposedRefs3(ref, forwardedRef);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize2(control);
  React77.useEffect(() => {
    const input = ref.current;
    if (!input)
      return;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input, checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsx124(Primitive3.input, {
    type: "radio",
    "aria-hidden": true,
    defaultChecked: checked,
    ...props,
    tabIndex: -1,
    ref: composedRefs,
    style: {
      ...props.style,
      ...controlSize,
      position: "absolute",
      pointerEvents: "none",
      opacity: 0,
      margin: 0
    }
  });
});
RadioBubbleInput.displayName = BUBBLE_INPUT_NAME3;
function getState6(checked) {
  return checked ? "checked" : "unchecked";
}
var ARROW_KEYS2 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var RADIO_GROUP_NAME5 = "RadioGroup";
var [createRadioGroupContext, createRadioGroupScope] = createContextScope3(RADIO_GROUP_NAME5, [
  createRovingFocusGroupScope3,
  createRadioScope
]);
var useRovingFocusGroupScope32 = createRovingFocusGroupScope3();
var useRadioScope = createRadioScope();
var [RadioGroupProvider22, useRadioGroupContext22] = createRadioGroupContext(RADIO_GROUP_NAME5);
var RadioGroup3 = React2102.forwardRef((props, forwardedRef) => {
  const {
    __scopeRadioGroup,
    name,
    defaultValue,
    value: valueProp,
    required = false,
    disabled = false,
    orientation,
    dir,
    loop = true,
    onValueChange,
    ...groupProps
  } = props;
  const rovingFocusGroupScope = useRovingFocusGroupScope32(__scopeRadioGroup);
  const direction = useDirection3(dir);
  const [value, setValue] = useControllableState3({
    prop: valueProp,
    defaultProp: defaultValue ?? null,
    onChange: onValueChange,
    caller: RADIO_GROUP_NAME5
  });
  return /* @__PURE__ */ jsx242(RadioGroupProvider22, {
    scope: __scopeRadioGroup,
    name,
    required,
    disabled,
    value,
    onValueChange: setValue,
    children: /* @__PURE__ */ jsx242(Root9, {
      asChild: true,
      ...rovingFocusGroupScope,
      orientation,
      dir: direction,
      loop,
      children: /* @__PURE__ */ jsx242(Primitive3.div, {
        role: "radiogroup",
        "aria-required": required,
        "aria-orientation": orientation,
        "data-disabled": disabled ? "" : undefined,
        dir: direction,
        ...groupProps,
        ref: forwardedRef
      })
    })
  });
});
RadioGroup3.displayName = RADIO_GROUP_NAME5;
var ITEM_NAME9 = "RadioGroupItem";
var RadioGroupItem = React2102.forwardRef((props, forwardedRef) => {
  const { __scopeRadioGroup, disabled, ...itemProps } = props;
  const context = useRadioGroupContext22(ITEM_NAME9, __scopeRadioGroup);
  const isDisabled = context.disabled || disabled;
  const rovingFocusGroupScope = useRovingFocusGroupScope32(__scopeRadioGroup);
  const radioScope = useRadioScope(__scopeRadioGroup);
  const ref = React2102.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  const checked = context.value === itemProps.value;
  const isArrowKeyPressedRef = React2102.useRef(false);
  React2102.useEffect(() => {
    const handleKeyDown = (event) => {
      if (ARROW_KEYS2.includes(event.key)) {
        isArrowKeyPressedRef.current = true;
      }
    };
    const handleKeyUp = () => isArrowKeyPressedRef.current = false;
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
    };
  }, []);
  return /* @__PURE__ */ jsx242(Item32, {
    asChild: true,
    ...rovingFocusGroupScope,
    focusable: !isDisabled,
    active: checked,
    children: /* @__PURE__ */ jsx242(Radio, {
      disabled: isDisabled,
      required: context.required,
      checked,
      ...radioScope,
      ...itemProps,
      name: context.name,
      ref: composedRefs,
      onCheck: () => context.onValueChange(itemProps.value),
      onKeyDown: composeEventHandlers3((event) => {
        if (event.key === "Enter")
          event.preventDefault();
      }),
      onFocus: composeEventHandlers3(itemProps.onFocus, () => {
        if (isArrowKeyPressedRef.current)
          ref.current?.click();
      })
    })
  });
});
RadioGroupItem.displayName = ITEM_NAME9;
var INDICATOR_NAME222 = "RadioGroupIndicator";
var RadioGroupIndicator = React2102.forwardRef((props, forwardedRef) => {
  const { __scopeRadioGroup, ...indicatorProps } = props;
  const radioScope = useRadioScope(__scopeRadioGroup);
  return /* @__PURE__ */ jsx242(RadioIndicator, { ...radioScope, ...indicatorProps, ref: forwardedRef });
});
RadioGroupIndicator.displayName = INDICATOR_NAME222;
var Root210 = RadioGroup3;
var Item25 = RadioGroupItem;
var Indicator3 = RadioGroupIndicator;
function RadioGroup5({ className, ...props }) {
  return /* @__PURE__ */ jsx125(Root210, {
    "data-slot": "radio-group",
    className: clsx30("grid gap-3", className),
    ...props
  });
}
function RadioGroupItem2({ className, ...props }) {
  return /* @__PURE__ */ jsx125(Item25, {
    "data-slot": "radio-group-item",
    className: clsx30("aspect-square size-4 shrink-0 rounded-full border border-input text-primary shadow-xs outline-none transition-[color,box-shadow] focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:cursor-not-allowed disabled:opacity-50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:bg-input/30 dark:aria-invalid:ring-destructive/40", className),
    ...props,
    children: /* @__PURE__ */ jsx125(Indicator3, {
      "data-slot": "radio-group-indicator",
      className: "relative flex items-center justify-center",
      children: /* @__PURE__ */ jsx125(SvgIcon4, {
        iconId: "Circle",
        className: "-translate-x-1/2 -translate-y-1/2 absolute top-1/2 left-1/2 size-2 fill-primary"
      })
    })
  });
}
function useStateMachine22(initialState, machine) {
  return React79.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var SCROLL_AREA_NAME = "ScrollArea";
var [createScrollAreaContext, createScrollAreaScope] = createContextScope3(SCROLL_AREA_NAME);
var [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);
var ScrollArea = React2122.forwardRef((props, forwardedRef) => {
  const {
    __scopeScrollArea,
    type = "hover",
    dir,
    scrollHideDelay = 600,
    ...scrollAreaProps
  } = props;
  const [scrollArea, setScrollArea] = React2122.useState(null);
  const [viewport, setViewport] = React2122.useState(null);
  const [content, setContent] = React2122.useState(null);
  const [scrollbarX, setScrollbarX] = React2122.useState(null);
  const [scrollbarY, setScrollbarY] = React2122.useState(null);
  const [cornerWidth, setCornerWidth] = React2122.useState(0);
  const [cornerHeight, setCornerHeight] = React2122.useState(0);
  const [scrollbarXEnabled, setScrollbarXEnabled] = React2122.useState(false);
  const [scrollbarYEnabled, setScrollbarYEnabled] = React2122.useState(false);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setScrollArea(node));
  const direction = useDirection3(dir);
  return /* @__PURE__ */ jsx128(ScrollAreaProvider, {
    scope: __scopeScrollArea,
    type,
    dir: direction,
    scrollHideDelay,
    scrollArea,
    viewport,
    onViewportChange: setViewport,
    content,
    onContentChange: setContent,
    scrollbarX,
    onScrollbarXChange: setScrollbarX,
    scrollbarXEnabled,
    onScrollbarXEnabledChange: setScrollbarXEnabled,
    scrollbarY,
    onScrollbarYChange: setScrollbarY,
    scrollbarYEnabled,
    onScrollbarYEnabledChange: setScrollbarYEnabled,
    onCornerWidthChange: setCornerWidth,
    onCornerHeightChange: setCornerHeight,
    children: /* @__PURE__ */ jsx128(Primitive3.div, {
      dir: direction,
      ...scrollAreaProps,
      ref: composedRefs,
      style: {
        position: "relative",
        ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
        ["--radix-scroll-area-corner-height"]: cornerHeight + "px",
        ...props.style
      }
    })
  });
});
ScrollArea.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME3 = "ScrollAreaViewport";
var ScrollAreaViewport = React2122.forwardRef((props, forwardedRef) => {
  const { __scopeScrollArea, children, nonce, ...viewportProps } = props;
  const context = useScrollAreaContext(VIEWPORT_NAME3, __scopeScrollArea);
  const ref = React2122.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref, context.onViewportChange);
  return /* @__PURE__ */ jsxs67(Fragment132, { children: [
    /* @__PURE__ */ jsx128("style", {
      dangerouslySetInnerHTML: {
        __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`
      },
      nonce
    }),
    /* @__PURE__ */ jsx128(Primitive3.div, {
      "data-radix-scroll-area-viewport": "",
      ...viewportProps,
      ref: composedRefs,
      style: {
        overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
        overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
        ...props.style
      },
      children: /* @__PURE__ */ jsx128("div", { ref: context.onContentChange, style: { minWidth: "100%", display: "table" }, children })
    })
  ] });
});
ScrollAreaViewport.displayName = VIEWPORT_NAME3;
var SCROLLBAR_NAME = "ScrollAreaScrollbar";
var ScrollAreaScrollbar = React2122.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
  const isHorizontal = props.orientation === "horizontal";
  React2122.useEffect(() => {
    isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
    return () => {
      isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
    };
  }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);
  return context.type === "hover" ? /* @__PURE__ */ jsx128(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? /* @__PURE__ */ jsx128(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? /* @__PURE__ */ jsx128(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? /* @__PURE__ */ jsx128(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
});
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = React2122.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [visible, setVisible] = React2122.useState(false);
  React2122.useEffect(() => {
    const scrollArea = context.scrollArea;
    let hideTimer = 0;
    if (scrollArea) {
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        setVisible(true);
      };
      const handlePointerLeave = () => {
        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
      };
      scrollArea.addEventListener("pointerenter", handlePointerEnter);
      scrollArea.addEventListener("pointerleave", handlePointerLeave);
      return () => {
        window.clearTimeout(hideTimer);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      };
    }
  }, [context.scrollArea, context.scrollHideDelay]);
  return /* @__PURE__ */ jsx128(Presence3, { present: forceMount || visible, children: /* @__PURE__ */ jsx128(ScrollAreaScrollbarAuto, {
    "data-state": visible ? "visible" : "hidden",
    ...scrollbarProps,
    ref: forwardedRef
  }) });
});
var ScrollAreaScrollbarScroll = React2122.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const isHorizontal = props.orientation === "horizontal";
  const debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100);
  const [state, send] = useStateMachine22("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  React2122.useEffect(() => {
    if (state === "idle") {
      const hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
      return () => window.clearTimeout(hideTimer);
    }
  }, [state, context.scrollHideDelay, send]);
  React2122.useEffect(() => {
    const viewport = context.viewport;
    const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
    if (viewport) {
      let prevScrollPos = viewport[scrollDirection];
      const handleScroll22 = () => {
        const scrollPos = viewport[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          send("SCROLL");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);
  return /* @__PURE__ */ jsx128(Presence3, { present: forceMount || state !== "hidden", children: /* @__PURE__ */ jsx128(ScrollAreaScrollbarVisible, {
    "data-state": state === "hidden" ? "hidden" : "visible",
    ...scrollbarProps,
    ref: forwardedRef,
    onPointerEnter: composeEventHandlers3(props.onPointerEnter, () => send("POINTER_ENTER")),
    onPointerLeave: composeEventHandlers3(props.onPointerLeave, () => send("POINTER_LEAVE"))
  }) });
});
var ScrollAreaScrollbarAuto = React2122.forwardRef((props, forwardedRef) => {
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const { forceMount, ...scrollbarProps } = props;
  const [visible, setVisible] = React2122.useState(false);
  const isHorizontal = props.orientation === "horizontal";
  const handleResize = useDebounceCallback(() => {
    if (context.viewport) {
      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
      setVisible(isHorizontal ? isOverflowX : isOverflowY);
    }
  }, 10);
  useResizeObserver2(context.viewport, handleResize);
  useResizeObserver2(context.content, handleResize);
  return /* @__PURE__ */ jsx128(Presence3, { present: forceMount || visible, children: /* @__PURE__ */ jsx128(ScrollAreaScrollbarVisible, {
    "data-state": visible ? "visible" : "hidden",
    ...scrollbarProps,
    ref: forwardedRef
  }) });
});
var ScrollAreaScrollbarVisible = React2122.forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const thumbRef = React2122.useRef(null);
  const pointerOffsetRef = React2122.useRef(0);
  const [sizes, setSizes] = React2122.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  });
  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
  const commonProps = {
    ...scrollbarProps,
    sizes,
    onSizesChange: setSizes,
    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
    onThumbChange: (thumb) => thumbRef.current = thumb,
    onThumbPointerUp: () => pointerOffsetRef.current = 0,
    onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
  };
  function getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
  }
  if (orientation === "horizontal") {
    return /* @__PURE__ */ jsx128(ScrollAreaScrollbarX, {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context.viewport && thumbRef.current) {
          const scrollPos = context.viewport.scrollLeft;
          const offset42 = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
          thumbRef.current.style.transform = `translate3d(${offset42}px, 0, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        if (context.viewport)
          context.viewport.scrollLeft = scrollPos;
      },
      onDragScroll: (pointerPos) => {
        if (context.viewport) {
          context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);
        }
      }
    });
  }
  if (orientation === "vertical") {
    return /* @__PURE__ */ jsx128(ScrollAreaScrollbarY, {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context.viewport && thumbRef.current) {
          const scrollPos = context.viewport.scrollTop;
          const offset42 = getThumbOffsetFromScroll(scrollPos, sizes);
          thumbRef.current.style.transform = `translate3d(0, ${offset42}px, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        if (context.viewport)
          context.viewport.scrollTop = scrollPos;
      },
      onDragScroll: (pointerPos) => {
        if (context.viewport)
          context.viewport.scrollTop = getScrollPosition(pointerPos);
      }
    });
  }
  return null;
});
var ScrollAreaScrollbarX = React2122.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = React2122.useState();
  const ref = React2122.useRef(null);
  const composeRefs22 = useComposedRefs3(forwardedRef, ref, context.onScrollbarXChange);
  React2122.useEffect(() => {
    if (ref.current)
      setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsx128(ScrollAreaScrollbarImpl, {
    "data-orientation": "horizontal",
    ...scrollbarProps,
    ref: composeRefs22,
    sizes,
    style: {
      bottom: 0,
      left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
      right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
      ["--radix-scroll-area-thumb-width"]: getThumbSize(sizes) + "px",
      ...props.style
    },
    onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
    onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
    onWheelScroll: (event, maxScrollPos) => {
      if (context.viewport) {
        const scrollPos = context.viewport.scrollLeft + event.deltaX;
        props.onWheelScroll(scrollPos);
        if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
          event.preventDefault();
        }
      }
    },
    onResize: () => {
      if (ref.current && context.viewport && computedStyle) {
        onSizesChange({
          content: context.viewport.scrollWidth,
          viewport: context.viewport.offsetWidth,
          scrollbar: {
            size: ref.current.clientWidth,
            paddingStart: toInt(computedStyle.paddingLeft),
            paddingEnd: toInt(computedStyle.paddingRight)
          }
        });
      }
    }
  });
});
var ScrollAreaScrollbarY = React2122.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = React2122.useState();
  const ref = React2122.useRef(null);
  const composeRefs22 = useComposedRefs3(forwardedRef, ref, context.onScrollbarYChange);
  React2122.useEffect(() => {
    if (ref.current)
      setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsx128(ScrollAreaScrollbarImpl, {
    "data-orientation": "vertical",
    ...scrollbarProps,
    ref: composeRefs22,
    sizes,
    style: {
      top: 0,
      right: context.dir === "ltr" ? 0 : undefined,
      left: context.dir === "rtl" ? 0 : undefined,
      bottom: "var(--radix-scroll-area-corner-height)",
      ["--radix-scroll-area-thumb-height"]: getThumbSize(sizes) + "px",
      ...props.style
    },
    onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
    onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
    onWheelScroll: (event, maxScrollPos) => {
      if (context.viewport) {
        const scrollPos = context.viewport.scrollTop + event.deltaY;
        props.onWheelScroll(scrollPos);
        if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
          event.preventDefault();
        }
      }
    },
    onResize: () => {
      if (ref.current && context.viewport && computedStyle) {
        onSizesChange({
          content: context.viewport.scrollHeight,
          viewport: context.viewport.offsetHeight,
          scrollbar: {
            size: ref.current.clientHeight,
            paddingStart: toInt(computedStyle.paddingTop),
            paddingEnd: toInt(computedStyle.paddingBottom)
          }
        });
      }
    }
  });
});
var [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);
var ScrollAreaScrollbarImpl = React2122.forwardRef((props, forwardedRef) => {
  const {
    __scopeScrollArea,
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);
  const [scrollbar, setScrollbar] = React2122.useState(null);
  const composeRefs22 = useComposedRefs3(forwardedRef, (node) => setScrollbar(node));
  const rectRef = React2122.useRef(null);
  const prevWebkitUserSelectRef = React2122.useRef("");
  const viewport = context.viewport;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = useCallbackRef6(onWheelScroll);
  const handleThumbPositionChange = useCallbackRef6(onThumbPositionChange);
  const handleResize = useDebounceCallback(onResize, 10);
  function handleDragScroll(event) {
    if (rectRef.current) {
      const x2 = event.clientX - rectRef.current.left;
      const y = event.clientY - rectRef.current.top;
      onDragScroll({ x: x2, y });
    }
  }
  React2122.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar?.contains(element);
      if (isScrollbarWheel)
        handleWheelScroll(event, maxScrollPos);
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);
  React2122.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver2(scrollbar, handleResize);
  useResizeObserver2(context.content, handleResize);
  return /* @__PURE__ */ jsx128(ScrollbarProvider, {
    scope: __scopeScrollArea,
    scrollbar,
    hasThumb,
    onThumbChange: useCallbackRef6(onThumbChange),
    onThumbPointerUp: useCallbackRef6(onThumbPointerUp),
    onThumbPositionChange: handleThumbPositionChange,
    onThumbPointerDown: useCallbackRef6(onThumbPointerDown),
    children: /* @__PURE__ */ jsx128(Primitive3.div, {
      ...scrollbarProps,
      ref: composeRefs22,
      style: { position: "absolute", ...scrollbarProps.style },
      onPointerDown: composeEventHandlers3(props.onPointerDown, (event) => {
        const mainPointer = 0;
        if (event.button === mainPointer) {
          const element = event.target;
          element.setPointerCapture(event.pointerId);
          rectRef.current = scrollbar.getBoundingClientRect();
          prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
          document.body.style.webkitUserSelect = "none";
          if (context.viewport)
            context.viewport.style.scrollBehavior = "auto";
          handleDragScroll(event);
        }
      }),
      onPointerMove: composeEventHandlers3(props.onPointerMove, handleDragScroll),
      onPointerUp: composeEventHandlers3(props.onPointerUp, (event) => {
        const element = event.target;
        if (element.hasPointerCapture(event.pointerId)) {
          element.releasePointerCapture(event.pointerId);
        }
        document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
        if (context.viewport)
          context.viewport.style.scrollBehavior = "";
        rectRef.current = null;
      })
    })
  });
});
var THUMB_NAME = "ScrollAreaThumb";
var ScrollAreaThumb = React2122.forwardRef((props, forwardedRef) => {
  const { forceMount, ...thumbProps } = props;
  const scrollbarContext = useScrollbarContext(THUMB_NAME, props.__scopeScrollArea);
  return /* @__PURE__ */ jsx128(Presence3, { present: forceMount || scrollbarContext.hasThumb, children: /* @__PURE__ */ jsx128(ScrollAreaThumbImpl, { ref: forwardedRef, ...thumbProps }) });
});
var ScrollAreaThumbImpl = React2122.forwardRef((props, forwardedRef) => {
  const { __scopeScrollArea, style, ...thumbProps } = props;
  const scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea);
  const scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea);
  const { onThumbPositionChange } = scrollbarContext;
  const composedRef = useComposedRefs3(forwardedRef, (node) => scrollbarContext.onThumbChange(node));
  const removeUnlinkedScrollListenerRef = React2122.useRef(undefined);
  const debounceScrollEnd = useDebounceCallback(() => {
    if (removeUnlinkedScrollListenerRef.current) {
      removeUnlinkedScrollListenerRef.current();
      removeUnlinkedScrollListenerRef.current = undefined;
    }
  }, 100);
  React2122.useEffect(() => {
    const viewport = scrollAreaContext.viewport;
    if (viewport) {
      const handleScroll22 = () => {
        debounceScrollEnd();
        if (!removeUnlinkedScrollListenerRef.current) {
          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
          removeUnlinkedScrollListenerRef.current = listener;
          onThumbPositionChange();
        }
      };
      onThumbPositionChange();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);
  return /* @__PURE__ */ jsx128(Primitive3.div, {
    "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
    ...thumbProps,
    ref: composedRef,
    style: {
      width: "var(--radix-scroll-area-thumb-width)",
      height: "var(--radix-scroll-area-thumb-height)",
      ...style
    },
    onPointerDownCapture: composeEventHandlers3(props.onPointerDownCapture, (event) => {
      const thumb = event.target;
      const thumbRect = thumb.getBoundingClientRect();
      const x2 = event.clientX - thumbRect.left;
      const y = event.clientY - thumbRect.top;
      scrollbarContext.onThumbPointerDown({ x: x2, y });
    }),
    onPointerUp: composeEventHandlers3(props.onPointerUp, scrollbarContext.onThumbPointerUp)
  });
});
ScrollAreaThumb.displayName = THUMB_NAME;
var CORNER_NAME = "ScrollAreaCorner";
var ScrollAreaCorner = React2122.forwardRef((props, forwardedRef) => {
  const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);
  const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
  const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
  return hasCorner ? /* @__PURE__ */ jsx128(ScrollAreaCornerImpl, { ...props, ref: forwardedRef }) : null;
});
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = React2122.forwardRef((props, forwardedRef) => {
  const { __scopeScrollArea, ...cornerProps } = props;
  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);
  const [width, setWidth] = React2122.useState(0);
  const [height, setHeight] = React2122.useState(0);
  const hasSize = Boolean(width && height);
  useResizeObserver2(context.scrollbarX, () => {
    const height2 = context.scrollbarX?.offsetHeight || 0;
    context.onCornerHeightChange(height2);
    setHeight(height2);
  });
  useResizeObserver2(context.scrollbarY, () => {
    const width2 = context.scrollbarY?.offsetWidth || 0;
    context.onCornerWidthChange(width2);
    setWidth(width2);
  });
  return hasSize ? /* @__PURE__ */ jsx128(Primitive3.div, {
    ...cornerProps,
    ref: forwardedRef,
    style: {
      width,
      height,
      position: "absolute",
      right: context.dir === "ltr" ? 0 : undefined,
      left: context.dir === "rtl" ? 0 : undefined,
      bottom: 0,
      ...props.style
    }
  }) : null;
});
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset42 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset42;
  const minPointerPos = sizes.scrollbar.paddingStart + offset42;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp3(scrollPos, scrollClampRange);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
var addUnlinkedScrollListener = (node, handler = () => {}) => {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll)
      handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
};
function useDebounceCallback(callback, delay) {
  const handleCallback = useCallbackRef6(callback);
  const debounceTimerRef = React2122.useRef(0);
  React2122.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);
  return React2122.useCallback(() => {
    window.clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = window.setTimeout(handleCallback, delay);
  }, [handleCallback, delay]);
}
function useResizeObserver2(element, onResize) {
  const handleResize = useCallbackRef6(onResize);
  useLayoutEffect24(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
var Root12 = ScrollArea;
var Viewport3 = ScrollAreaViewport;
var Corner = ScrollAreaCorner;
function ScrollArea2({ className, children, ...props }) {
  return /* @__PURE__ */ jsxs68(Root12, {
    "data-slot": "scroll-area",
    className: clsx31("relative", className),
    ...props,
    children: [
      /* @__PURE__ */ jsx129(Viewport3, {
        "data-slot": "scroll-area-viewport",
        className: "size-full rounded-[inherit] outline-none transition-[color,box-shadow] focus-visible:outline-1 focus-visible:ring-[3px] focus-visible:ring-ring/50",
        children
      }),
      /* @__PURE__ */ jsx129(ScrollBar, {}),
      /* @__PURE__ */ jsx129(Corner, {})
    ]
  });
}
function ScrollBar({ className, orientation = "vertical", ...props }) {
  return /* @__PURE__ */ jsx129(ScrollAreaScrollbar, {
    "data-slot": "scroll-area-scrollbar",
    orientation,
    className: clsx31("flex touch-none select-none p-px transition-colors", orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent", orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent", className),
    ...props,
    children: /* @__PURE__ */ jsx129(ScrollAreaThumb, {
      "data-slot": "scroll-area-thumb",
      className: "relative flex-1 rounded-full bg-border"
    })
  });
}
var NAME5 = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = ["horizontal", "vertical"];
var Separator3 = React80.forwardRef((props, forwardedRef) => {
  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
  const ariaOrientation = orientation === "vertical" ? orientation : undefined;
  const semanticProps = decorative ? { role: "none" } : { "aria-orientation": ariaOrientation, role: "separator" };
  return /* @__PURE__ */ jsx130(Primitive3.div, {
    "data-orientation": orientation,
    ...semanticProps,
    ...domProps,
    ref: forwardedRef
  });
});
Separator3.displayName = NAME5;
function isValidOrientation(orientation) {
  return ORIENTATIONS.includes(orientation);
}
var Root13 = Separator3;
function Separator4({ className, orientation = "horizontal", decorative = true, ...props }) {
  return /* @__PURE__ */ jsx131(Root13, {
    "data-slot": "separator",
    decorative,
    orientation,
    className: clsx322("shrink-0 bg-border data-[orientation=horizontal]:h-px data-[orientation=vertical]:h-full data-[orientation=horizontal]:w-full data-[orientation=vertical]:w-px", className),
    ...props
  });
}
var tags = Array.from({ length: 50 }).map((_2, i, a) => `v1.2.0-beta.${a.length - i}`);
function Sheet({ ...props }) {
  return /* @__PURE__ */ jsx138(Root62, {
    "data-slot": "sheet",
    ...props
  });
}
function SheetTrigger({ ...props }) {
  return /* @__PURE__ */ jsx138(Trigger4, {
    "data-slot": "sheet-trigger",
    ...props
  });
}
function SheetClose({ ...props }) {
  return /* @__PURE__ */ jsx138(Close, {
    "data-slot": "sheet-close",
    ...props
  });
}
function SheetPortal({ ...props }) {
  return /* @__PURE__ */ jsx138(Portal4, {
    "data-slot": "sheet-portal",
    ...props
  });
}
function SheetOverlay({ className, ...props }) {
  return /* @__PURE__ */ jsx138(Overlay2, {
    "data-slot": "sheet-overlay",
    className: clsx332("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50 data-[state=closed]:animate-out data-[state=open]:animate-in", className),
    ...props
  });
}
function SheetContent({
  className,
  children,
  side = "right",
  ...props
}) {
  return /* @__PURE__ */ jsxs75(SheetPortal, {
    children: [
      /* @__PURE__ */ jsx138(SheetOverlay, {}),
      /* @__PURE__ */ jsxs75(Content52, {
        "data-slot": "sheet-content",
        className: clsx332("fixed z-50 flex flex-col gap-4 bg-background shadow-lg transition ease-in-out data-[state=closed]:animate-out data-[state=open]:animate-in data-[state=closed]:duration-300 data-[state=open]:duration-500", side === "right" && "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm", side === "left" && "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm", side === "top" && "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b", side === "bottom" && "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t", className),
        ...props,
        children: [
          children,
          /* @__PURE__ */ jsxs75(Close, {
            className: "absolute top-4 right-4 rounded-xs opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary",
            children: [
              /* @__PURE__ */ jsx138(SvgIcon4, {
                iconId: "X",
                className: "size-4"
              }),
              /* @__PURE__ */ jsx138("span", {
                className: "sr-only",
                children: "Close"
              })
            ]
          })
        ]
      })
    ]
  });
}
function SheetHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx138("div", {
    "data-slot": "sheet-header",
    className: clsx332("flex flex-col gap-1.5 p-4", className),
    ...props
  });
}
function SheetFooter({ className, ...props }) {
  return /* @__PURE__ */ jsx138("div", {
    "data-slot": "sheet-footer",
    className: clsx332("mt-auto flex flex-col gap-2 p-4", className),
    ...props
  });
}
function SheetTitle({ className, ...props }) {
  return /* @__PURE__ */ jsx138(Title, {
    "data-slot": "sheet-title",
    className: clsx332("font-semibold text-foreground", className),
    ...props
  });
}
function SheetDescription({ className, ...props }) {
  return /* @__PURE__ */ jsx138(Description, {
    "data-slot": "sheet-description",
    className: clsx332("text-muted-foreground text-sm", className),
    ...props
  });
}
function Skeleton({ className, ...props }) {
  return /* @__PURE__ */ jsx141("div", {
    "data-slot": "skeleton",
    className: clsx34("animate-pulse rounded-md bg-accent", className),
    ...props
  });
}
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS3 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var SLIDER_NAME = "Slider";
var [Collection72, useCollection72, createCollectionScope72] = createCollection3(SLIDER_NAME);
var [createSliderContext, createSliderScope] = createContextScope3(SLIDER_NAME, [
  createCollectionScope72
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider = React84.forwardRef((props, forwardedRef) => {
  const {
    name,
    min: min22 = 0,
    max: max22 = 100,
    step = 1,
    orientation = "horizontal",
    disabled = false,
    minStepsBetweenThumbs = 0,
    defaultValue = [min22],
    value,
    onValueChange = () => {},
    onValueCommit = () => {},
    inverted = false,
    form,
    ...sliderProps
  } = props;
  const thumbRefs = React84.useRef(/* @__PURE__ */ new Set);
  const valueIndexToChangeRef = React84.useRef(0);
  const isHorizontal = orientation === "horizontal";
  const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
  const [values = [], setValues] = useControllableState3({
    prop: value,
    defaultProp: defaultValue,
    onChange: (value2) => {
      const thumbs = [...thumbRefs.current];
      thumbs[valueIndexToChangeRef.current]?.focus();
      onValueChange(value2);
    }
  });
  const valuesBeforeSlideStartRef = React84.useRef(values);
  function handleSlideStart(value2) {
    const closestIndex = getClosestValueIndex(values, value2);
    updateValues(value2, closestIndex);
  }
  function handleSlideMove(value2) {
    updateValues(value2, valueIndexToChangeRef.current);
  }
  function handleSlideEnd() {
    const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
    const nextValue = values[valueIndexToChangeRef.current];
    const hasChanged = nextValue !== prevValue;
    if (hasChanged)
      onValueCommit(values);
  }
  function updateValues(value2, atIndex, { commit } = { commit: false }) {
    const decimalCount = getDecimalCount(step);
    const snapToStep = roundValue(Math.round((value2 - min22) / step) * step + min22, decimalCount);
    const nextValue = clamp3(snapToStep, [min22, max22]);
    setValues((prevValues = []) => {
      const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
      if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
        valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
        const hasChanged = String(nextValues) !== String(prevValues);
        if (hasChanged && commit)
          onValueCommit(nextValues);
        return hasChanged ? nextValues : prevValues;
      } else {
        return prevValues;
      }
    });
  }
  return /* @__PURE__ */ jsx144(SliderProvider, {
    scope: props.__scopeSlider,
    name,
    disabled,
    min: min22,
    max: max22,
    valueIndexToChangeRef,
    thumbs: thumbRefs.current,
    values,
    orientation,
    form,
    children: /* @__PURE__ */ jsx144(Collection72.Provider, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsx144(Collection72.Slot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsx144(SliderOrientation, {
      "aria-disabled": disabled,
      "data-disabled": disabled ? "" : undefined,
      ...sliderProps,
      ref: forwardedRef,
      onPointerDown: composeEventHandlers3(sliderProps.onPointerDown, () => {
        if (!disabled)
          valuesBeforeSlideStartRef.current = values;
      }),
      min: min22,
      max: max22,
      inverted,
      onSlideStart: disabled ? undefined : handleSlideStart,
      onSlideMove: disabled ? undefined : handleSlideMove,
      onSlideEnd: disabled ? undefined : handleSlideEnd,
      onHomeKeyDown: () => !disabled && updateValues(min22, 0, { commit: true }),
      onEndKeyDown: () => !disabled && updateValues(max22, values.length - 1, { commit: true }),
      onStepKeyDown: ({ event, direction: stepDirection }) => {
        if (!disabled) {
          const isPageKey = PAGE_KEYS.includes(event.key);
          const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS3.includes(event.key);
          const multiplier = isSkipKey ? 10 : 1;
          const atIndex = valueIndexToChangeRef.current;
          const value2 = values[atIndex];
          const stepInDirection = step * multiplier * stepDirection;
          updateValues(value2 + stepInDirection, atIndex, { commit: true });
        }
      }
    }) }) })
  });
});
Slider.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
});
var SliderHorizontal = React84.forwardRef((props, forwardedRef) => {
  const {
    min: min22,
    max: max22,
    dir,
    inverted,
    onSlideStart,
    onSlideMove,
    onSlideEnd,
    onStepKeyDown,
    ...sliderProps
  } = props;
  const [slider, setSlider] = React84.useState(null);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setSlider(node));
  const rectRef = React84.useRef(undefined);
  const direction = useDirection3(dir);
  const isDirectionLTR = direction === "ltr";
  const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
  function getValueFromPointer(pointerPosition) {
    const rect = rectRef.current || slider.getBoundingClientRect();
    const input = [0, rect.width];
    const output = isSlidingFromLeft ? [min22, max22] : [max22, min22];
    const value = linearScale2(input, output);
    rectRef.current = rect;
    return value(pointerPosition - rect.left);
  }
  return /* @__PURE__ */ jsx144(SliderOrientationProvider, {
    scope: props.__scopeSlider,
    startEdge: isSlidingFromLeft ? "left" : "right",
    endEdge: isSlidingFromLeft ? "right" : "left",
    direction: isSlidingFromLeft ? 1 : -1,
    size: "width",
    children: /* @__PURE__ */ jsx144(SliderImpl, {
      dir: direction,
      "data-orientation": "horizontal",
      ...sliderProps,
      ref: composedRefs,
      style: {
        ...sliderProps.style,
        ["--radix-slider-thumb-transform"]: "translateX(-50%)"
      },
      onSlideStart: (event) => {
        const value = getValueFromPointer(event.clientX);
        onSlideStart?.(value);
      },
      onSlideMove: (event) => {
        const value = getValueFromPointer(event.clientX);
        onSlideMove?.(value);
      },
      onSlideEnd: () => {
        rectRef.current = undefined;
        onSlideEnd?.();
      },
      onStepKeyDown: (event) => {
        const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
        const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
        onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
      }
    })
  });
});
var SliderVertical = React84.forwardRef((props, forwardedRef) => {
  const {
    min: min22,
    max: max22,
    inverted,
    onSlideStart,
    onSlideMove,
    onSlideEnd,
    onStepKeyDown,
    ...sliderProps
  } = props;
  const sliderRef = React84.useRef(null);
  const ref = useComposedRefs3(forwardedRef, sliderRef);
  const rectRef = React84.useRef(undefined);
  const isSlidingFromBottom = !inverted;
  function getValueFromPointer(pointerPosition) {
    const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
    const input = [0, rect.height];
    const output = isSlidingFromBottom ? [max22, min22] : [min22, max22];
    const value = linearScale2(input, output);
    rectRef.current = rect;
    return value(pointerPosition - rect.top);
  }
  return /* @__PURE__ */ jsx144(SliderOrientationProvider, {
    scope: props.__scopeSlider,
    startEdge: isSlidingFromBottom ? "bottom" : "top",
    endEdge: isSlidingFromBottom ? "top" : "bottom",
    size: "height",
    direction: isSlidingFromBottom ? 1 : -1,
    children: /* @__PURE__ */ jsx144(SliderImpl, {
      "data-orientation": "vertical",
      ...sliderProps,
      ref,
      style: {
        ...sliderProps.style,
        ["--radix-slider-thumb-transform"]: "translateY(50%)"
      },
      onSlideStart: (event) => {
        const value = getValueFromPointer(event.clientY);
        onSlideStart?.(value);
      },
      onSlideMove: (event) => {
        const value = getValueFromPointer(event.clientY);
        onSlideMove?.(value);
      },
      onSlideEnd: () => {
        rectRef.current = undefined;
        onSlideEnd?.();
      },
      onStepKeyDown: (event) => {
        const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
        const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
        onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
      }
    })
  });
});
var SliderImpl = React84.forwardRef((props, forwardedRef) => {
  const {
    __scopeSlider,
    onSlideStart,
    onSlideMove,
    onSlideEnd,
    onHomeKeyDown,
    onEndKeyDown,
    onStepKeyDown,
    ...sliderProps
  } = props;
  const context = useSliderContext(SLIDER_NAME, __scopeSlider);
  return /* @__PURE__ */ jsx144(Primitive3.span, {
    ...sliderProps,
    ref: forwardedRef,
    onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
      if (event.key === "Home") {
        onHomeKeyDown(event);
        event.preventDefault();
      } else if (event.key === "End") {
        onEndKeyDown(event);
        event.preventDefault();
      } else if (PAGE_KEYS.concat(ARROW_KEYS3).includes(event.key)) {
        onStepKeyDown(event);
        event.preventDefault();
      }
    }),
    onPointerDown: composeEventHandlers3(props.onPointerDown, (event) => {
      const target = event.target;
      target.setPointerCapture(event.pointerId);
      event.preventDefault();
      if (context.thumbs.has(target)) {
        target.focus();
      } else {
        onSlideStart(event);
      }
    }),
    onPointerMove: composeEventHandlers3(props.onPointerMove, (event) => {
      const target = event.target;
      if (target.hasPointerCapture(event.pointerId))
        onSlideMove(event);
    }),
    onPointerUp: composeEventHandlers3(props.onPointerUp, (event) => {
      const target = event.target;
      if (target.hasPointerCapture(event.pointerId)) {
        target.releasePointerCapture(event.pointerId);
        onSlideEnd(event);
      }
    })
  });
});
var TRACK_NAME = "SliderTrack";
var SliderTrack = React84.forwardRef((props, forwardedRef) => {
  const { __scopeSlider, ...trackProps } = props;
  const context = useSliderContext(TRACK_NAME, __scopeSlider);
  return /* @__PURE__ */ jsx144(Primitive3.span, {
    "data-disabled": context.disabled ? "" : undefined,
    "data-orientation": context.orientation,
    ...trackProps,
    ref: forwardedRef
  });
});
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = React84.forwardRef((props, forwardedRef) => {
  const { __scopeSlider, ...rangeProps } = props;
  const context = useSliderContext(RANGE_NAME, __scopeSlider);
  const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
  const ref = React84.useRef(null);
  const composedRefs = useComposedRefs3(forwardedRef, ref);
  const valuesCount = context.values.length;
  const percentages = context.values.map((value) => convertValueToPercentage(value, context.min, context.max));
  const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
  const offsetEnd = 100 - Math.max(...percentages);
  return /* @__PURE__ */ jsx144(Primitive3.span, {
    "data-orientation": context.orientation,
    "data-disabled": context.disabled ? "" : undefined,
    ...rangeProps,
    ref: composedRefs,
    style: {
      ...props.style,
      [orientation.startEdge]: offsetStart + "%",
      [orientation.endEdge]: offsetEnd + "%"
    }
  });
});
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME2 = "SliderThumb";
var SliderThumb = React84.forwardRef((props, forwardedRef) => {
  const getItems = useCollection72(props.__scopeSlider);
  const [thumb, setThumb] = React84.useState(null);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setThumb(node));
  const index22 = React84.useMemo(() => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1, [getItems, thumb]);
  return /* @__PURE__ */ jsx144(SliderThumbImpl, { ...props, ref: composedRefs, index: index22 });
});
var SliderThumbImpl = React84.forwardRef((props, forwardedRef) => {
  const { __scopeSlider, index: index22, name, ...thumbProps } = props;
  const context = useSliderContext(THUMB_NAME2, __scopeSlider);
  const orientation = useSliderOrientationContext(THUMB_NAME2, __scopeSlider);
  const [thumb, setThumb] = React84.useState(null);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setThumb(node));
  const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
  const size42 = useSize2(thumb);
  const value = context.values[index22];
  const percent = value === undefined ? 0 : convertValueToPercentage(value, context.min, context.max);
  const label = getLabel(index22, context.values.length);
  const orientationSize = size42?.[orientation.size];
  const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
  React84.useEffect(() => {
    if (thumb) {
      context.thumbs.add(thumb);
      return () => {
        context.thumbs.delete(thumb);
      };
    }
  }, [thumb, context.thumbs]);
  return /* @__PURE__ */ jsxs80("span", {
    style: {
      transform: "var(--radix-slider-thumb-transform)",
      position: "absolute",
      [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
    },
    children: [
      /* @__PURE__ */ jsx144(Collection72.ItemSlot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsx144(Primitive3.span, {
        role: "slider",
        "aria-label": props["aria-label"] || label,
        "aria-valuemin": context.min,
        "aria-valuenow": value,
        "aria-valuemax": context.max,
        "aria-orientation": context.orientation,
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : undefined,
        tabIndex: context.disabled ? undefined : 0,
        ...thumbProps,
        ref: composedRefs,
        style: value === undefined ? { display: "none" } : props.style,
        onFocus: composeEventHandlers3(props.onFocus, () => {
          context.valueIndexToChangeRef.current = index22;
        })
      }) }),
      isFormControl && /* @__PURE__ */ jsx144(SliderBubbleInput, {
        name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : undefined),
        form: context.form,
        value
      }, index22)
    ]
  });
});
SliderThumb.displayName = THUMB_NAME2;
var BUBBLE_INPUT_NAME4 = "RadioBubbleInput";
var SliderBubbleInput = React84.forwardRef(({ __scopeSlider, value, ...props }, forwardedRef) => {
  const ref = React84.useRef(null);
  const composedRefs = useComposedRefs3(ref, forwardedRef);
  const prevValue = usePrevious(value);
  React84.useEffect(() => {
    const input = ref.current;
    if (!input)
      return;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
    const setValue = descriptor.set;
    if (prevValue !== value && setValue) {
      const event = new Event("input", { bubbles: true });
      setValue.call(input, value);
      input.dispatchEvent(event);
    }
  }, [prevValue, value]);
  return /* @__PURE__ */ jsx144(Primitive3.input, {
    style: { display: "none" },
    ...props,
    ref: composedRefs,
    defaultValue: value
  });
});
SliderBubbleInput.displayName = BUBBLE_INPUT_NAME4;
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function convertValueToPercentage(value, min22, max22) {
  const maxSteps = max22 - min22;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min22);
  return clamp3(percentage, [0, 100]);
}
function getLabel(index22, totalValues) {
  if (totalValues > 2) {
    return `Value ${index22 + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index22];
  } else {
    return;
  }
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1)
    return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset42 = linearScale2([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset42(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index22) => values[index22 + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale2(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var SWITCH_NAME = "Switch";
var [createSwitchContext, createSwitchScope] = createContextScope3(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch = React86.forwardRef((props, forwardedRef) => {
  const {
    __scopeSwitch,
    name,
    checked: checkedProp,
    defaultChecked,
    required,
    disabled,
    value = "on",
    onCheckedChange,
    form,
    ...switchProps
  } = props;
  const [button, setButton] = React86.useState(null);
  const composedRefs = useComposedRefs3(forwardedRef, (node) => setButton(node));
  const hasConsumerStoppedPropagationRef = React86.useRef(false);
  const isFormControl = button ? form || !!button.closest("form") : true;
  const [checked, setChecked] = useControllableState3({
    prop: checkedProp,
    defaultProp: defaultChecked ?? false,
    onChange: onCheckedChange,
    caller: SWITCH_NAME
  });
  return /* @__PURE__ */ jsxs822(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
    /* @__PURE__ */ jsx148(Primitive3.button, {
      type: "button",
      role: "switch",
      "aria-checked": checked,
      "aria-required": required,
      "data-state": getState7(checked),
      "data-disabled": disabled ? "" : undefined,
      disabled,
      value,
      ...switchProps,
      ref: composedRefs,
      onClick: composeEventHandlers3(props.onClick, (event) => {
        setChecked((prevChecked) => !prevChecked);
        if (isFormControl) {
          hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
          if (!hasConsumerStoppedPropagationRef.current)
            event.stopPropagation();
        }
      })
    }),
    isFormControl && /* @__PURE__ */ jsx148(SwitchBubbleInput, {
      control: button,
      bubbles: !hasConsumerStoppedPropagationRef.current,
      name,
      value,
      checked,
      required,
      disabled,
      form,
      style: { transform: "translateX(-100%)" }
    })
  ] });
});
Switch.displayName = SWITCH_NAME;
var THUMB_NAME3 = "SwitchThumb";
var SwitchThumb = React86.forwardRef((props, forwardedRef) => {
  const { __scopeSwitch, ...thumbProps } = props;
  const context = useSwitchContext(THUMB_NAME3, __scopeSwitch);
  return /* @__PURE__ */ jsx148(Primitive3.span, {
    "data-state": getState7(context.checked),
    "data-disabled": context.disabled ? "" : undefined,
    ...thumbProps,
    ref: forwardedRef
  });
});
SwitchThumb.displayName = THUMB_NAME3;
var BUBBLE_INPUT_NAME5 = "SwitchBubbleInput";
var SwitchBubbleInput = React86.forwardRef(({
  __scopeSwitch,
  control,
  checked,
  bubbles = true,
  ...props
}, forwardedRef) => {
  const ref = React86.useRef(null);
  const composedRefs = useComposedRefs3(ref, forwardedRef);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize2(control);
  React86.useEffect(() => {
    const input = ref.current;
    if (!input)
      return;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input, checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsx148("input", {
    type: "checkbox",
    "aria-hidden": true,
    defaultChecked: checked,
    ...props,
    tabIndex: -1,
    ref: composedRefs,
    style: {
      ...props.style,
      ...controlSize,
      position: "absolute",
      pointerEvents: "none",
      opacity: 0,
      margin: 0
    }
  });
});
SwitchBubbleInput.displayName = BUBBLE_INPUT_NAME5;
function getState7(checked) {
  return checked ? "checked" : "unchecked";
}
function Table({ className, ...props }) {
  return /* @__PURE__ */ jsx1522("div", {
    "data-slot": "table-container",
    className: "relative w-full overflow-x-auto",
    children: /* @__PURE__ */ jsx1522("table", {
      "data-slot": "table",
      className: clsx38("w-full caption-bottom text-sm", className),
      ...props
    })
  });
}
function TableHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx1522("thead", {
    "data-slot": "table-header",
    className: clsx38("[&_tr]:border-b", className),
    ...props
  });
}
function TableBody({ className, ...props }) {
  return /* @__PURE__ */ jsx1522("tbody", {
    "data-slot": "table-body",
    className: clsx38("[&_tr:last-child]:border-0", className),
    ...props
  });
}
function TableFooter({ className, ...props }) {
  return /* @__PURE__ */ jsx1522("tfoot", {
    "data-slot": "table-footer",
    className: clsx38("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className),
    ...props
  });
}
function TableRow({ className, ...props }) {
  return /* @__PURE__ */ jsx1522("tr", {
    "data-slot": "table-row",
    className: clsx38("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", className),
    ...props
  });
}
function TableHead({ className, ...props }) {
  return /* @__PURE__ */ jsx1522("th", {
    "data-slot": "table-head",
    className: clsx38("h-10 whitespace-nowrap px-2 text-left align-middle font-medium text-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", className),
    ...props
  });
}
function TableCell({ className, ...props }) {
  return /* @__PURE__ */ jsx1522("td", {
    "data-slot": "table-cell",
    className: clsx38("whitespace-nowrap p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", className),
    ...props
  });
}
function TableCaption({ className, ...props }) {
  return /* @__PURE__ */ jsx1522("caption", {
    "data-slot": "table-caption",
    className: clsx38("mt-4 text-muted-foreground text-sm", className),
    ...props
  });
}
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope3(TABS_NAME, [
  createRovingFocusGroupScope3
]);
var useRovingFocusGroupScope4 = createRovingFocusGroupScope3();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs = React89.forwardRef((props, forwardedRef) => {
  const {
    __scopeTabs,
    value: valueProp,
    onValueChange,
    defaultValue,
    orientation = "horizontal",
    dir,
    activationMode = "automatic",
    ...tabsProps
  } = props;
  const direction = useDirection3(dir);
  const [value, setValue] = useControllableState3({
    prop: valueProp,
    onChange: onValueChange,
    defaultProp: defaultValue ?? "",
    caller: TABS_NAME
  });
  return /* @__PURE__ */ jsx154(TabsProvider, {
    scope: __scopeTabs,
    baseId: useId3(),
    value,
    onValueChange: setValue,
    orientation,
    dir: direction,
    activationMode,
    children: /* @__PURE__ */ jsx154(Primitive3.div, {
      dir: direction,
      "data-orientation": orientation,
      ...tabsProps,
      ref: forwardedRef
    })
  });
});
Tabs.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList = React89.forwardRef((props, forwardedRef) => {
  const { __scopeTabs, loop = true, ...listProps } = props;
  const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
  const rovingFocusGroupScope = useRovingFocusGroupScope4(__scopeTabs);
  return /* @__PURE__ */ jsx154(Root9, {
    asChild: true,
    ...rovingFocusGroupScope,
    orientation: context.orientation,
    dir: context.dir,
    loop,
    children: /* @__PURE__ */ jsx154(Primitive3.div, {
      role: "tablist",
      "aria-orientation": context.orientation,
      ...listProps,
      ref: forwardedRef
    })
  });
});
TabsList.displayName = TAB_LIST_NAME;
var TRIGGER_NAME14 = "TabsTrigger";
var TabsTrigger = React89.forwardRef((props, forwardedRef) => {
  const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
  const context = useTabsContext(TRIGGER_NAME14, __scopeTabs);
  const rovingFocusGroupScope = useRovingFocusGroupScope4(__scopeTabs);
  const triggerId = makeTriggerId2(context.baseId, value);
  const contentId = makeContentId2(context.baseId, value);
  const isSelected = value === context.value;
  return /* @__PURE__ */ jsx154(Item32, {
    asChild: true,
    ...rovingFocusGroupScope,
    focusable: !disabled,
    active: isSelected,
    children: /* @__PURE__ */ jsx154(Primitive3.button, {
      type: "button",
      role: "tab",
      "aria-selected": isSelected,
      "aria-controls": contentId,
      "data-state": isSelected ? "active" : "inactive",
      "data-disabled": disabled ? "" : undefined,
      disabled,
      id: triggerId,
      ...triggerProps,
      ref: forwardedRef,
      onMouseDown: composeEventHandlers3(props.onMouseDown, (event) => {
        if (!disabled && event.button === 0 && event.ctrlKey === false) {
          context.onValueChange(value);
        } else {
          event.preventDefault();
        }
      }),
      onKeyDown: composeEventHandlers3(props.onKeyDown, (event) => {
        if ([" ", "Enter"].includes(event.key))
          context.onValueChange(value);
      }),
      onFocus: composeEventHandlers3(props.onFocus, () => {
        const isAutomaticActivation = context.activationMode !== "manual";
        if (!isSelected && !disabled && isAutomaticActivation) {
          context.onValueChange(value);
        }
      })
    })
  });
});
TabsTrigger.displayName = TRIGGER_NAME14;
var CONTENT_NAME15 = "TabsContent";
var TabsContent = React89.forwardRef((props, forwardedRef) => {
  const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
  const context = useTabsContext(CONTENT_NAME15, __scopeTabs);
  const triggerId = makeTriggerId2(context.baseId, value);
  const contentId = makeContentId2(context.baseId, value);
  const isSelected = value === context.value;
  const isMountAnimationPreventedRef = React89.useRef(isSelected);
  React89.useEffect(() => {
    const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF);
  }, []);
  return /* @__PURE__ */ jsx154(Presence3, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsx154(Primitive3.div, {
    "data-state": isSelected ? "active" : "inactive",
    "data-orientation": context.orientation,
    role: "tabpanel",
    "aria-labelledby": triggerId,
    hidden: !present,
    id: contentId,
    tabIndex: 0,
    ...contentProps,
    ref: forwardedRef,
    style: {
      ...props.style,
      animationDuration: isMountAnimationPreventedRef.current ? "0s" : undefined
    },
    children: present && children
  }) });
});
TabsContent.displayName = CONTENT_NAME15;
function makeTriggerId2(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId2(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root211 = Tabs;
var List2 = TabsList;
var Trigger11 = TabsTrigger;
var Content7 = TabsContent;
function Tabs2({ className, ...props }) {
  return /* @__PURE__ */ jsx155(Root211, {
    "data-slot": "tabs",
    className: clsx39("flex flex-col gap-2", className),
    ...props
  });
}
function TabsList2({ className, ...props }) {
  return /* @__PURE__ */ jsx155(List2, {
    "data-slot": "tabs-list",
    className: clsx39("inline-flex h-9 w-fit items-center justify-center rounded-lg bg-muted p-[3px] text-muted-foreground", className),
    ...props
  });
}
function TabsTrigger2({ className, ...props }) {
  return /* @__PURE__ */ jsx155(Trigger11, {
    "data-slot": "tabs-trigger",
    className: clsx39("inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 whitespace-nowrap rounded-md border border-transparent px-2 py-1 font-medium text-foreground text-sm transition-[color,box-shadow] focus-visible:border-ring focus-visible:outline-1 focus-visible:outline-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:shadow-sm dark:text-muted-foreground dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 dark:data-[state=active]:text-foreground [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className),
    ...props
  });
}
function TabsContent2({ className, ...props }) {
  return /* @__PURE__ */ jsx155(Content7, {
    "data-slot": "tabs-content",
    className: clsx39("flex-1 outline-none", className),
    ...props
  });
}
function Textarea({ className, ...props }) {
  return /* @__PURE__ */ jsx157("textarea", {
    "data-slot": "textarea",
    className: clsx40("field-sizing-content flex min-h-16 w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-xs outline-none transition-[color,box-shadow] placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:cursor-not-allowed disabled:opacity-50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 md:text-sm dark:bg-input/30 dark:aria-invalid:ring-destructive/40", className),
    ...props
  });
}
var NAME6 = "Toggle";
var Toggle = React93.forwardRef((props, forwardedRef) => {
  const { pressed: pressedProp, defaultPressed, onPressedChange, ...buttonProps } = props;
  const [pressed, setPressed] = useControllableState3({
    prop: pressedProp,
    onChange: onPressedChange,
    defaultProp: defaultPressed ?? false,
    caller: NAME6
  });
  return /* @__PURE__ */ jsx164(Primitive3.button, {
    type: "button",
    "aria-pressed": pressed,
    "data-state": pressed ? "on" : "off",
    "data-disabled": props.disabled ? "" : undefined,
    ...buttonProps,
    ref: forwardedRef,
    onClick: composeEventHandlers3(props.onClick, () => {
      if (!props.disabled) {
        setPressed(!pressed);
      }
    })
  });
});
Toggle.displayName = NAME6;
var Root16 = Toggle;
var toggleVariants = cva("inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap", {
  variants: {
    variant: {
      default: "bg-transparent",
      outline: "border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground"
    },
    size: {
      default: "h-9 px-2 min-w-9",
      sm: "h-8 px-1.5 min-w-8",
      lg: "h-10 px-2.5 min-w-10"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "default"
  }
});
function Toggle2({ className, variant, size: size42, ...props }) {
  return /* @__PURE__ */ jsx165(Root16, {
    "data-slot": "toggle",
    className: clsx41(toggleVariants({ variant, size: size42, className })),
    ...props
  });
}
var TOGGLE_GROUP_NAME = "ToggleGroup";
var [createToggleGroupContext, createToggleGroupScope] = createContextScope3(TOGGLE_GROUP_NAME, [
  createRovingFocusGroupScope3
]);
var useRovingFocusGroupScope52 = createRovingFocusGroupScope3();
var ToggleGroup = React94.forwardRef((props, forwardedRef) => {
  const { type, ...toggleGroupProps } = props;
  if (type === "single") {
    const singleProps = toggleGroupProps;
    return /* @__PURE__ */ jsx168(ToggleGroupImplSingle, { ...singleProps, ref: forwardedRef });
  }
  if (type === "multiple") {
    const multipleProps = toggleGroupProps;
    return /* @__PURE__ */ jsx168(ToggleGroupImplMultiple, { ...multipleProps, ref: forwardedRef });
  }
  throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME}\``);
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var [ToggleGroupValueProvider, useToggleGroupValueContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
var ToggleGroupImplSingle = React94.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {},
    ...toggleGroupSingleProps
  } = props;
  const [value, setValue] = useControllableState3({
    prop: valueProp,
    defaultProp: defaultValue ?? "",
    onChange: onValueChange,
    caller: TOGGLE_GROUP_NAME
  });
  return /* @__PURE__ */ jsx168(ToggleGroupValueProvider, {
    scope: props.__scopeToggleGroup,
    type: "single",
    value: React94.useMemo(() => value ? [value] : [], [value]),
    onItemActivate: setValue,
    onItemDeactivate: React94.useCallback(() => setValue(""), [setValue]),
    children: /* @__PURE__ */ jsx168(ToggleGroupImpl, { ...toggleGroupSingleProps, ref: forwardedRef })
  });
});
var ToggleGroupImplMultiple = React94.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {},
    ...toggleGroupMultipleProps
  } = props;
  const [value, setValue] = useControllableState3({
    prop: valueProp,
    defaultProp: defaultValue ?? [],
    onChange: onValueChange,
    caller: TOGGLE_GROUP_NAME
  });
  const handleButtonActivate = React94.useCallback((itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]), [setValue]);
  const handleButtonDeactivate = React94.useCallback((itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)), [setValue]);
  return /* @__PURE__ */ jsx168(ToggleGroupValueProvider, {
    scope: props.__scopeToggleGroup,
    type: "multiple",
    value,
    onItemActivate: handleButtonActivate,
    onItemDeactivate: handleButtonDeactivate,
    children: /* @__PURE__ */ jsx168(ToggleGroupImpl, { ...toggleGroupMultipleProps, ref: forwardedRef })
  });
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var [ToggleGroupContext, useToggleGroupContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
var ToggleGroupImpl = React94.forwardRef((props, forwardedRef) => {
  const {
    __scopeToggleGroup,
    disabled = false,
    rovingFocus = true,
    orientation,
    dir,
    loop = true,
    ...toggleGroupProps
  } = props;
  const rovingFocusGroupScope = useRovingFocusGroupScope52(__scopeToggleGroup);
  const direction = useDirection3(dir);
  const commonProps = { role: "group", dir: direction, ...toggleGroupProps };
  return /* @__PURE__ */ jsx168(ToggleGroupContext, { scope: __scopeToggleGroup, rovingFocus, disabled, children: rovingFocus ? /* @__PURE__ */ jsx168(Root9, {
    asChild: true,
    ...rovingFocusGroupScope,
    orientation,
    dir: direction,
    loop,
    children: /* @__PURE__ */ jsx168(Primitive3.div, { ...commonProps, ref: forwardedRef })
  }) : /* @__PURE__ */ jsx168(Primitive3.div, { ...commonProps, ref: forwardedRef }) });
});
var ITEM_NAME10 = "ToggleGroupItem";
var ToggleGroupItem = React94.forwardRef((props, forwardedRef) => {
  const valueContext = useToggleGroupValueContext(ITEM_NAME10, props.__scopeToggleGroup);
  const context = useToggleGroupContext(ITEM_NAME10, props.__scopeToggleGroup);
  const rovingFocusGroupScope = useRovingFocusGroupScope52(props.__scopeToggleGroup);
  const pressed = valueContext.value.includes(props.value);
  const disabled = context.disabled || props.disabled;
  const commonProps = { ...props, pressed, disabled };
  const ref = React94.useRef(null);
  return context.rovingFocus ? /* @__PURE__ */ jsx168(Item32, {
    asChild: true,
    ...rovingFocusGroupScope,
    focusable: !disabled,
    active: pressed,
    ref,
    children: /* @__PURE__ */ jsx168(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef })
  }) : /* @__PURE__ */ jsx168(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef });
});
ToggleGroupItem.displayName = ITEM_NAME10;
var ToggleGroupItemImpl = React94.forwardRef((props, forwardedRef) => {
  const { __scopeToggleGroup, value, ...itemProps } = props;
  const valueContext = useToggleGroupValueContext(ITEM_NAME10, __scopeToggleGroup);
  const singleProps = { role: "radio", "aria-checked": props.pressed, "aria-pressed": undefined };
  const typeProps = valueContext.type === "single" ? singleProps : undefined;
  return /* @__PURE__ */ jsx168(Toggle, {
    ...typeProps,
    ...itemProps,
    ref: forwardedRef,
    onPressedChange: (pressed) => {
      if (pressed) {
        valueContext.onItemActivate(value);
      } else {
        valueContext.onItemDeactivate(value);
      }
    }
  });
});
var Root212 = ToggleGroup;
var Item26 = ToggleGroupItem;
var ToggleGroupContext2 = React95.createContext({
  size: "default",
  variant: "default"
});
function ToggleGroup2({ className, variant, size: size42, children, ...props }) {
  return /* @__PURE__ */ jsx169(Root212, {
    "data-slot": "toggle-group",
    "data-variant": variant,
    "data-size": size42,
    className: clsx422("group/toggle-group flex w-fit items-center rounded-md data-[variant=outline]:shadow-xs", className),
    ...props,
    children: /* @__PURE__ */ jsx169(ToggleGroupContext2.Provider, {
      value: { variant, size: size42 },
      children
    })
  });
}
function ToggleGroupItem2({ className, children, variant, size: size42, ...props }) {
  const context = React95.useContext(ToggleGroupContext2);
  return /* @__PURE__ */ jsx169(Item26, {
    "data-slot": "toggle-group-item",
    "data-variant": context.variant || variant,
    "data-size": context.size || size42,
    className: clsx422(toggleVariants({
      variant: context.variant || variant,
      size: context.size || size42
    }), "min-w-0 flex-1 shrink-0 rounded-none shadow-none first:rounded-l-md last:rounded-r-md focus:z-10 focus-visible:z-10 data-[variant=outline]:border-l-0 data-[variant=outline]:first:border-l", className),
    ...props,
    children
  });
}
var buttonGroupVariants = cva("flex w-fit items-stretch [&>*]:focus-visible:z-10 [&>*]:focus-visible:relative [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md has-[>[data-slot=button-group]]:gap-2", {
  variants: {
    orientation: {
      horizontal: "[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none",
      vertical: "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none"
    }
  },
  defaultVariants: {
    orientation: "horizontal"
  }
});
function ButtonGroup({ className, orientation, ...props }) {
  return /* @__PURE__ */ jsx196("div", {
    role: "group",
    "data-slot": "button-group",
    "data-orientation": orientation,
    className: clsx432(buttonGroupVariants({ orientation }), className),
    ...props
  });
}
function ButtonGroupText({
  className,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot4 : "div";
  return /* @__PURE__ */ jsx196(Comp, {
    className: clsx432("flex items-center gap-2 rounded-md border bg-muted px-4 font-medium text-sm shadow-xs [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none", className),
    ...props
  });
}
function ButtonGroupSeparator({ className, orientation = "vertical", ...props }) {
  return /* @__PURE__ */ jsx196(Separator4, {
    "data-slot": "button-group-separator",
    orientation,
    className: clsx432("!m-0 relative self-stretch bg-input data-[orientation=vertical]:h-auto", className),
    ...props
  });
}
function Empty({ className, ...props }) {
  return /* @__PURE__ */ jsx197("div", {
    "data-slot": "empty",
    className: clsx44("flex min-w-0 flex-1 flex-col items-center justify-center gap-6 text-balance rounded-lg border-dashed p-6 text-center md:p-12", className),
    ...props
  });
}
function EmptyHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx197("div", {
    "data-slot": "empty-header",
    className: clsx44("flex max-w-sm flex-col items-center gap-2 text-center", className),
    ...props
  });
}
var emptyMediaVariants = cva("flex shrink-0 items-center justify-center mb-2 [&_svg]:pointer-events-none [&_svg]:shrink-0", {
  variants: {
    variant: {
      default: "bg-transparent",
      icon: "bg-muted text-foreground flex size-10 shrink-0 items-center justify-center rounded-lg [&_svg:not([class*='size-'])]:size-6"
    }
  },
  defaultVariants: {
    variant: "default"
  }
});
function EmptyMedia({ className, variant = "default", ...props }) {
  return /* @__PURE__ */ jsx197("div", {
    "data-slot": "empty-icon",
    "data-variant": variant,
    className: clsx44(emptyMediaVariants({ variant, className })),
    ...props
  });
}
function EmptyTitle({ className, ...props }) {
  return /* @__PURE__ */ jsx197("div", {
    "data-slot": "empty-title",
    className: clsx44("font-medium text-lg tracking-tight", className),
    ...props
  });
}
function EmptyDescription({ className, ...props }) {
  return /* @__PURE__ */ jsx197("div", {
    "data-slot": "empty-description",
    className: clsx44("text-muted-foreground text-sm/relaxed [&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4", className),
    ...props
  });
}
function EmptyContent({ className, ...props }) {
  return /* @__PURE__ */ jsx197("div", {
    "data-slot": "empty-content",
    className: clsx44("flex w-full min-w-0 max-w-sm flex-col items-center gap-4 text-balance text-sm", className),
    ...props
  });
}
function FieldSet({ className, ...props }) {
  return /* @__PURE__ */ jsx198("fieldset", {
    "data-slot": "field-set",
    className: clsx45("flex flex-col gap-6", "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3", className),
    ...props
  });
}
function FieldLegend({ className, variant = "legend", ...props }) {
  return /* @__PURE__ */ jsx198("legend", {
    "data-slot": "field-legend",
    "data-variant": variant,
    className: clsx45("mb-3 font-medium", "data-[variant=legend]:text-base", "data-[variant=label]:text-sm", className),
    ...props
  });
}
function FieldGroup({ className, ...props }) {
  return /* @__PURE__ */ jsx198("div", {
    "data-slot": "field-group",
    className: clsx45("group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4", className),
    ...props
  });
}
var fieldVariants = cva("group/field flex w-full gap-3 data-[invalid=true]:text-destructive", {
  variants: {
    orientation: {
      vertical: ["flex-col [&>*]:w-full [&>.sr-only]:w-auto"],
      horizontal: ["flex-row items-center", "[&>[data-slot=field-label]]:flex-auto", "has-[>[data-slot=field-content]]:items-start has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"],
      responsive: [
        "flex-col [&>*]:w-full [&>.sr-only]:w-auto @md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto",
        "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
        "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
      ]
    }
  },
  defaultVariants: {
    orientation: "vertical"
  }
});
function Field({ className, orientation = "vertical", ...props }) {
  return /* @__PURE__ */ jsx198("div", {
    role: "group",
    "data-slot": "field",
    "data-orientation": orientation,
    className: clsx45(fieldVariants({ orientation }), className),
    ...props
  });
}
function FieldContent({ className, ...props }) {
  return /* @__PURE__ */ jsx198("div", {
    "data-slot": "field-content",
    className: clsx45("group/field-content flex flex-1 flex-col gap-1.5 leading-snug", className),
    ...props
  });
}
function FieldLabel({ className, ...props }) {
  return /* @__PURE__ */ jsx198(Label4, {
    "data-slot": "field-label",
    className: clsx45("group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50", "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&>*]:data-[slot=field]:p-4", "has-data-[state=checked]:border-primary has-data-[state=checked]:bg-primary/5 dark:has-data-[state=checked]:bg-primary/10", className),
    ...props
  });
}
function FieldTitle({ className, ...props }) {
  return /* @__PURE__ */ jsx198("div", {
    "data-slot": "field-label",
    className: clsx45("flex w-fit items-center gap-2 font-medium text-sm leading-snug group-data-[disabled=true]/field:opacity-50", className),
    ...props
  });
}
function FieldDescription({ className, ...props }) {
  return /* @__PURE__ */ jsx198("p", {
    "data-slot": "field-description",
    className: clsx45("font-normal text-muted-foreground text-sm leading-normal group-has-[[data-orientation=horizontal]]/field:text-balance", "nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5 last:mt-0", "[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4", className),
    ...props
  });
}
function FieldSeparator({
  children,
  className,
  ...props
}) {
  return /* @__PURE__ */ jsxs103("div", {
    "data-slot": "field-separator",
    "data-content": !!children,
    className: clsx45("-my-2 group-data-[variant=outline]/field-group:-mb-2 relative h-5 text-sm", className),
    ...props,
    children: [
      /* @__PURE__ */ jsx198(Separator4, {
        className: "absolute inset-0 top-1/2"
      }),
      children && /* @__PURE__ */ jsx198("span", {
        className: "relative mx-auto block w-fit bg-background px-2 text-muted-foreground",
        "data-slot": "field-separator-content",
        children
      })
    ]
  });
}
function FieldError({
  className,
  children,
  errors,
  ...props
}) {
  const content = useMemo112(() => {
    if (children) {
      return children;
    }
    if (!errors) {
      return null;
    }
    if (errors?.length === 1 && errors[0]?.message) {
      return errors[0].message;
    }
    return /* @__PURE__ */ jsx198("ul", {
      className: "ml-4 flex list-disc flex-col gap-1",
      children: errors.map((error, index22) => error?.message && /* @__PURE__ */ jsx198("li", {
        children: error.message
      }, index22))
    });
  }, [children, errors]);
  if (!content) {
    return null;
  }
  return /* @__PURE__ */ jsx198("div", {
    role: "alert",
    "data-slot": "field-error",
    className: clsx45("font-normal text-destructive text-sm", className),
    ...props,
    children: content
  });
}
var Form = FormProvider;
var FormFieldContext = React96.createContext({});
var FormField = ({ ...props }) => {
  return /* @__PURE__ */ jsx199(FormFieldContext.Provider, {
    value: { name: props.name },
    children: /* @__PURE__ */ jsx199(Controller, {
      ...props
    })
  });
};
var useFormField = () => {
  const fieldContext = React96.useContext(FormFieldContext);
  const itemContext = React96.useContext(FormItemContext);
  const { getFieldState } = useFormContext();
  const formState = useFormState({ name: fieldContext.name });
  const fieldState = getFieldState(fieldContext.name, formState);
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }
  const { id } = itemContext;
  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState
  };
};
var FormItemContext = React96.createContext({});
function FormItem({ className, ...props }) {
  const id = React96.useId();
  return /* @__PURE__ */ jsx199(FormItemContext.Provider, {
    value: { id },
    children: /* @__PURE__ */ jsx199("div", {
      "data-slot": "form-item",
      className: clsx46("grid gap-2", className),
      ...props
    })
  });
}
function FormLabel({ className, ...props }) {
  const { error, formItemId } = useFormField();
  return /* @__PURE__ */ jsx199(Label4, {
    "data-slot": "form-label",
    "data-error": !!error,
    className: clsx46("data-[error=true]:text-destructive", className),
    htmlFor: formItemId,
    ...props
  });
}
function FormControl({ ...props }) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField();
  return /* @__PURE__ */ jsx199(Slot4, {
    "data-slot": "form-control",
    id: formItemId,
    "aria-describedby": !error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`,
    "aria-invalid": !!error,
    ...props
  });
}
function FormDescription({ className, ...props }) {
  const { formDescriptionId } = useFormField();
  return /* @__PURE__ */ jsx199("p", {
    "data-slot": "form-description",
    id: formDescriptionId,
    className: clsx46("text-muted-foreground text-sm", className),
    ...props
  });
}
function FormMessage({ className, ...props }) {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message ?? "") : props.children;
  if (!body) {
    return null;
  }
  return /* @__PURE__ */ jsx199("p", {
    "data-slot": "form-message",
    id: formMessageId,
    className: clsx46("text-destructive text-sm", className),
    ...props,
    children: body
  });
}
function InputGroup({ className, ...props }) {
  return /* @__PURE__ */ jsx200("div", {
    "data-slot": "input-group",
    role: "group",
    className: clsx47("group/input-group relative flex w-full items-center rounded-md border border-input shadow-xs outline-none transition-[color,box-shadow] dark:bg-input/30", "h-9 min-w-0 has-[>textarea]:h-auto", "has-[>[data-align=inline-start]]:[&>input]:pl-2", "has-[>[data-align=inline-end]]:[&>input]:pr-2", "has-[>[data-align=block-start]]:h-auto has-[>[data-align=block-start]]:flex-col has-[>[data-align=block-start]]:[&>input]:pb-3", "has-[>[data-align=block-end]]:h-auto has-[>[data-align=block-end]]:flex-col has-[>[data-align=block-end]]:[&>input]:pt-3", "has-[[data-slot=input-group-control]:focus-visible]:border-ring has-[[data-slot=input-group-control]:focus-visible]:ring-[3px] has-[[data-slot=input-group-control]:focus-visible]:ring-ring/50", "has-[[data-slot][aria-invalid=true]]:border-destructive has-[[data-slot][aria-invalid=true]]:ring-destructive/20 dark:has-[[data-slot][aria-invalid=true]]:ring-destructive/40", className),
    ...props
  });
}
var inputGroupAddonVariants = cva("text-muted-foreground flex h-auto cursor-text items-center justify-center gap-2 py-1.5 text-sm font-medium select-none [&>svg:not([class*='size-'])]:size-4 [&>kbd]:rounded-[calc(var(--radius)-5px)] group-data-[disabled=true]/input-group:opacity-50", {
  variants: {
    align: {
      "inline-start": "order-first pl-3 has-[>button]:ml-[-0.45rem] has-[>kbd]:ml-[-0.35rem]",
      "inline-end": "order-last pr-3 has-[>button]:mr-[-0.45rem] has-[>kbd]:mr-[-0.35rem]",
      "block-start": "order-first w-full justify-start px-3 pt-3 [.border-b]:pb-3 group-has-[>input]/input-group:pt-2.5",
      "block-end": "order-last w-full justify-start px-3 pb-3 [.border-t]:pt-3 group-has-[>input]/input-group:pb-2.5"
    }
  },
  defaultVariants: {
    align: "inline-start"
  }
});
function InputGroupAddon({ className, align = "inline-start", ...props }) {
  return /* @__PURE__ */ jsx200("div", {
    role: "group",
    "data-slot": "input-group-addon",
    "data-align": align,
    className: clsx47(inputGroupAddonVariants({ align }), className),
    onClick: (e) => {
      if (e.target.closest("button")) {
        return;
      }
      e.currentTarget.parentElement?.querySelector("input")?.focus();
    },
    ...props
  });
}
var inputGroupButtonVariants = cva("text-sm shadow-none flex gap-2 items-center", {
  variants: {
    size: {
      xs: "h-6 gap-1 px-2 rounded-[calc(var(--radius)-5px)] [&>svg:not([class*='size-'])]:size-3.5 has-[>svg]:px-2",
      sm: "h-8 px-2.5 gap-1.5 rounded-md has-[>svg]:px-2.5",
      "icon-xs": "size-6 rounded-[calc(var(--radius)-5px)] p-0 has-[>svg]:p-0",
      "icon-sm": "size-8 p-0 has-[>svg]:p-0"
    }
  },
  defaultVariants: {
    size: "xs"
  }
});
function InputGroupButton({ className, type = "button", variant = "ghost", size: size42 = "xs", ...props }) {
  return /* @__PURE__ */ jsx200(Button, {
    type,
    "data-size": size42,
    variant,
    className: clsx47(inputGroupButtonVariants({ size: size42 }), className),
    ...props
  });
}
function InputGroupText({ className, ...props }) {
  return /* @__PURE__ */ jsx200("span", {
    className: clsx47("flex items-center gap-2 text-muted-foreground text-sm [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none", className),
    ...props
  });
}
function InputGroupInput({ className, ...props }) {
  return /* @__PURE__ */ jsx200(Input, {
    "data-slot": "input-group-control",
    className: clsx47("flex-1 rounded-none border-0 bg-transparent shadow-none focus-visible:ring-0 dark:bg-transparent", className),
    ...props
  });
}
function InputGroupTextarea({ className, ...props }) {
  return /* @__PURE__ */ jsx200(Textarea, {
    "data-slot": "input-group-control",
    className: clsx47("flex-1 resize-none rounded-none border-0 bg-transparent py-3 shadow-none focus-visible:ring-0 dark:bg-transparent", className),
    ...props
  });
}
function ItemGroup({ className, ...props }) {
  return /* @__PURE__ */ jsx201("div", {
    role: "list",
    "data-slot": "item-group",
    className: clsx48("group/item-group flex flex-col", className),
    ...props
  });
}
function ItemSeparator({ className, ...props }) {
  return /* @__PURE__ */ jsx201(Separator4, {
    "data-slot": "item-separator",
    orientation: "horizontal",
    className: clsx48("my-0", className),
    ...props
  });
}
var itemVariants = cva("group/item flex items-center border border-transparent text-sm rounded-md transition-colors [a]:hover:bg-accent/50 [a]:transition-colors duration-100 flex-wrap outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", {
  variants: {
    variant: {
      default: "bg-transparent",
      outline: "border-border",
      muted: "bg-muted/50"
    },
    size: {
      default: "p-4 gap-4 ",
      sm: "py-3 px-4 gap-2.5"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "default"
  }
});
function Item52({ className, variant = "default", size: size42 = "default", asChild = false, ...props }) {
  const Comp = asChild ? Slot4 : "div";
  return /* @__PURE__ */ jsx201(Comp, {
    "data-slot": "item",
    "data-variant": variant,
    "data-size": size42,
    className: clsx48(itemVariants({ variant, size: size42, className })),
    ...props
  });
}
var itemMediaVariants = cva("flex shrink-0 items-center justify-center gap-2 group-has-[[data-slot=item-description]]/item:self-start [&_svg]:pointer-events-none group-has-[[data-slot=item-description]]/item:translate-y-0.5", {
  variants: {
    variant: {
      default: "bg-transparent",
      icon: "size-8 border rounded-sm bg-muted [&_svg:not([class*='size-'])]:size-4",
      image: "size-10 rounded-sm overflow-hidden [&_img]:size-full [&_img]:object-cover"
    }
  },
  defaultVariants: {
    variant: "default"
  }
});
function ItemMedia({ className, variant = "default", ...props }) {
  return /* @__PURE__ */ jsx201("div", {
    "data-slot": "item-media",
    "data-variant": variant,
    className: clsx48(itemMediaVariants({ variant, className })),
    ...props
  });
}
function ItemContent({ className, ...props }) {
  return /* @__PURE__ */ jsx201("div", {
    "data-slot": "item-content",
    className: clsx48("flex flex-1 flex-col gap-1 [&+[data-slot=item-content]]:flex-none", className),
    ...props
  });
}
function ItemTitle({ className, ...props }) {
  return /* @__PURE__ */ jsx201("div", {
    "data-slot": "item-title",
    className: clsx48("flex w-fit items-center gap-2 font-medium text-sm leading-snug", className),
    ...props
  });
}
function ItemDescription({ className, ...props }) {
  return /* @__PURE__ */ jsx201("p", {
    "data-slot": "item-description",
    className: clsx48("line-clamp-2 text-balance font-normal text-muted-foreground text-sm leading-normal", "[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4", className),
    ...props
  });
}
function ItemActions({ className, ...props }) {
  return /* @__PURE__ */ jsx201("div", {
    "data-slot": "item-actions",
    className: clsx48("flex items-center gap-2", className),
    ...props
  });
}
function ItemHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx201("div", {
    "data-slot": "item-header",
    className: clsx48("flex basis-full items-center justify-between gap-2", className),
    ...props
  });
}
function ItemFooter({ className, ...props }) {
  return /* @__PURE__ */ jsx201("div", {
    "data-slot": "item-footer",
    className: clsx48("flex basis-full items-center justify-between gap-2", className),
    ...props
  });
}
function Kbd({ className, ...props }) {
  return /* @__PURE__ */ jsx2022("kbd", {
    "data-slot": "kbd",
    className: clsx49("pointer-events-none inline-flex h-5 w-fit min-w-5 select-none items-center justify-center gap-1 rounded-sm bg-muted px-1 font-medium font-sans text-muted-foreground text-xs", "[&_svg:not([class*='size-'])]:size-3", "[[data-slot=tooltip-content]_&]:bg-background/20 [[data-slot=tooltip-content]_&]:text-background dark:[[data-slot=tooltip-content]_&]:bg-background/10", className),
    ...props
  });
}
function KbdGroup({ className, ...props }) {
  return /* @__PURE__ */ jsx2022("kbd", {
    "data-slot": "kbd-group",
    className: clsx49("inline-flex items-center gap-1", className),
    ...props
  });
}
var MOBILE_BREAKPOINT = 768;
function useIsMobile() {
  const [isMobile, setIsMobile] = React97.useState(undefined);
  React97.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);
  return !!isMobile;
}
var SIDEBAR_COOKIE_NAME = "sidebar_state";
var SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
var SIDEBAR_WIDTH = "16rem";
var SIDEBAR_WIDTH_MOBILE = "18rem";
var SIDEBAR_WIDTH_ICON = "3rem";
var SIDEBAR_KEYBOARD_SHORTCUT = "b";
var SidebarContext = React98.createContext(null);
function useSidebar() {
  const context = React98.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }
  return context;
}
function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}) {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React98.useState(false);
  const [_open, _setOpen] = React98.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React98.useCallback((value) => {
    const openState = typeof value === "function" ? value(open) : value;
    if (setOpenProp) {
      setOpenProp(openState);
    } else {
      _setOpen(openState);
    }
    document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
  }, [setOpenProp, open]);
  const toggleSidebar = React98.useCallback(() => {
    return isMobile ? setOpenMobile((open2) => !open2) : setOpen((open2) => !open2);
  }, [isMobile, setOpen, setOpenMobile]);
  React98.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {
        event.preventDefault();
        toggleSidebar();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar]);
  const state = open ? "expanded" : "collapsed";
  const contextValue = React98.useMemo(() => ({
    state,
    open,
    setOpen,
    isMobile,
    openMobile,
    setOpenMobile,
    toggleSidebar
  }), [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]);
  return /* @__PURE__ */ jsx203(SidebarContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsx203(TooltipProvider2, {
      delayDuration: 0,
      children: /* @__PURE__ */ jsx203("div", {
        "data-slot": "sidebar-wrapper",
        style: {
          "--sidebar-width": SIDEBAR_WIDTH,
          "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
          ...style
        },
        className: clsx50("group/sidebar-wrapper flex min-h-svh w-full has-data-[variant=inset]:bg-sidebar", className),
        ...props,
        children
      })
    })
  });
}
function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();
  if (collapsible === "none") {
    return /* @__PURE__ */ jsx203("div", {
      "data-slot": "sidebar",
      className: clsx50("flex h-full w-(--sidebar-width) flex-col bg-sidebar text-sidebar-foreground", className),
      ...props,
      children
    });
  }
  if (isMobile) {
    return /* @__PURE__ */ jsx203(Sheet, {
      open: openMobile,
      onOpenChange: setOpenMobile,
      ...props,
      children: /* @__PURE__ */ jsxs104(SheetContent, {
        "data-sidebar": "sidebar",
        "data-slot": "sidebar",
        "data-mobile": "true",
        className: "w-(--sidebar-width) bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden",
        style: {
          "--sidebar-width": SIDEBAR_WIDTH_MOBILE
        },
        side,
        children: [
          /* @__PURE__ */ jsxs104(SheetHeader, {
            className: "sr-only",
            children: [
              /* @__PURE__ */ jsx203(SheetTitle, {
                children: "Sidebar"
              }),
              /* @__PURE__ */ jsx203(SheetDescription, {
                children: "Displays the mobile sidebar."
              })
            ]
          }),
          /* @__PURE__ */ jsx203("div", {
            className: "flex h-full w-full flex-col",
            children
          })
        ]
      })
    });
  }
  return /* @__PURE__ */ jsxs104("div", {
    className: "group peer hidden text-sidebar-foreground md:block",
    "data-state": state,
    "data-collapsible": state === "collapsed" ? collapsible : "",
    "data-variant": variant,
    "data-side": side,
    "data-slot": "sidebar",
    children: [
      /* @__PURE__ */ jsx203("div", {
        "data-slot": "sidebar-gap",
        className: clsx50("relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear", "group-data-[collapsible=offcanvas]:w-0", "group-data-[side=right]:rotate-180", variant === "floating" || variant === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)")
      }),
      /* @__PURE__ */ jsx203("div", {
        "data-slot": "sidebar-container",
        className: clsx50("fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex", side === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]", variant === "floating" || variant === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l", className),
        ...props,
        children: /* @__PURE__ */ jsx203("div", {
          "data-sidebar": "sidebar",
          "data-slot": "sidebar-inner",
          className: "flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow-sm",
          children
        })
      })
    ]
  });
}
function SidebarTrigger({ className, onClick, ...props }) {
  const { toggleSidebar } = useSidebar();
  return /* @__PURE__ */ jsxs104(Button, {
    "data-sidebar": "trigger",
    "data-slot": "sidebar-trigger",
    variant: "ghost",
    size: "icon",
    className: clsx50("size-7", className),
    onClick: (event) => {
      onClick?.(event);
      toggleSidebar();
    },
    ...props,
    children: [
      /* @__PURE__ */ jsx203(SvgIcon4, {
        iconId: "PanelLeft"
      }),
      /* @__PURE__ */ jsx203("span", {
        className: "sr-only",
        children: "Toggle Sidebar"
      })
    ]
  });
}
function SidebarRail({ className, ...props }) {
  const { toggleSidebar } = useSidebar();
  return /* @__PURE__ */ jsx203("button", {
    "data-sidebar": "rail",
    "data-slot": "sidebar-rail",
    "aria-label": "Toggle Sidebar",
    tabIndex: -1,
    onClick: toggleSidebar,
    title: "Toggle Sidebar",
    className: clsx50("-translate-x-1/2 group-data-[side=left]:-right-4 absolute inset-y-0 z-20 hidden w-4 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=right]:left-0 sm:flex", "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize", "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize", "group-data-[collapsible=offcanvas]:translate-x-0 hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:after:left-full", "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2", "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2", className),
    ...props
  });
}
function SidebarInset({ className, ...props }) {
  return /* @__PURE__ */ jsx203("main", {
    "data-slot": "sidebar-inset",
    className: clsx50("relative flex w-full flex-1 flex-col bg-background", "md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2 md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm", className),
    ...props
  });
}
function SidebarInput({ className, ...props }) {
  return /* @__PURE__ */ jsx203(Input, {
    "data-slot": "sidebar-input",
    "data-sidebar": "input",
    className: clsx50("h-8 w-full bg-background shadow-none", className),
    ...props
  });
}
function SidebarHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx203("div", {
    "data-slot": "sidebar-header",
    "data-sidebar": "header",
    className: clsx50("flex flex-col gap-2 p-2", className),
    ...props
  });
}
function SidebarFooter({ className, ...props }) {
  return /* @__PURE__ */ jsx203("div", {
    "data-slot": "sidebar-footer",
    "data-sidebar": "footer",
    className: clsx50("flex flex-col gap-2 p-2", className),
    ...props
  });
}
function SidebarSeparator({ className, ...props }) {
  return /* @__PURE__ */ jsx203(Separator4, {
    "data-slot": "sidebar-separator",
    "data-sidebar": "separator",
    className: clsx50("mx-2 w-auto bg-sidebar-border", className),
    ...props
  });
}
function SidebarContent({ className, ...props }) {
  return /* @__PURE__ */ jsx203("div", {
    "data-slot": "sidebar-content",
    "data-sidebar": "content",
    className: clsx50("flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden", className),
    ...props
  });
}
function SidebarGroup({ className, ...props }) {
  return /* @__PURE__ */ jsx203("div", {
    "data-slot": "sidebar-group",
    "data-sidebar": "group",
    className: clsx50("relative flex w-full min-w-0 flex-col p-2", className),
    ...props
  });
}
function SidebarGroupLabel({ className, asChild = false, ...props }) {
  const Comp = asChild ? Slot4 : "div";
  return /* @__PURE__ */ jsx203(Comp, {
    "data-slot": "sidebar-group-label",
    "data-sidebar": "group-label",
    className: clsx50("flex h-8 shrink-0 items-center rounded-md px-2 font-medium text-sidebar-foreground/70 text-xs outline-hidden ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0", "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0", className),
    ...props
  });
}
function SidebarGroupAction({ className, asChild = false, ...props }) {
  const Comp = asChild ? Slot4 : "button";
  return /* @__PURE__ */ jsx203(Comp, {
    "data-slot": "sidebar-group-action",
    "data-sidebar": "group-action",
    className: clsx50("absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-hidden ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0", "after:-inset-2 after:absolute md:after:hidden", "group-data-[collapsible=icon]:hidden", className),
    ...props
  });
}
function SidebarGroupContent({ className, ...props }) {
  return /* @__PURE__ */ jsx203("div", {
    "data-slot": "sidebar-group-content",
    "data-sidebar": "group-content",
    className: clsx50("w-full text-sm", className),
    ...props
  });
}
function SidebarMenu({ className, ...props }) {
  return /* @__PURE__ */ jsx203("ul", {
    "data-slot": "sidebar-menu",
    "data-sidebar": "menu",
    className: clsx50("flex w-full min-w-0 flex-col gap-1", className),
    ...props
  });
}
function SidebarMenuItem({ className, ...props }) {
  return /* @__PURE__ */ jsx203("li", {
    "data-slot": "sidebar-menu-item",
    "data-sidebar": "menu-item",
    className: clsx50("group/menu-item relative", className),
    ...props
  });
}
var sidebarMenuButtonVariants = cva("peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0", {
  variants: {
    variant: {
      default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
      outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
    },
    size: {
      default: "h-8 text-sm",
      sm: "h-7 text-xs",
      lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "default"
  }
});
function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size: size42 = "default",
  tooltip,
  className,
  ...props
}) {
  const Comp = asChild ? Slot4 : "button";
  const { isMobile, state } = useSidebar();
  const button = /* @__PURE__ */ jsx203(Comp, {
    "data-slot": "sidebar-menu-button",
    "data-sidebar": "menu-button",
    "data-size": size42,
    "data-active": isActive,
    className: clsx50(sidebarMenuButtonVariants({ variant, size: size42 }), className),
    ...props
  });
  if (!tooltip) {
    return button;
  }
  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip
    };
  }
  return /* @__PURE__ */ jsxs104(Tooltip2, {
    children: [
      /* @__PURE__ */ jsx203(TooltipTrigger2, {
        asChild: true,
        children: button
      }),
      /* @__PURE__ */ jsx203(TooltipContent2, {
        side: "right",
        align: "center",
        hidden: state !== "collapsed" || isMobile,
        ...tooltip
      })
    ]
  });
}
function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}) {
  const Comp = asChild ? Slot4 : "button";
  return /* @__PURE__ */ jsx203(Comp, {
    "data-slot": "sidebar-menu-action",
    "data-sidebar": "menu-action",
    className: clsx50("absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-hidden ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0", "after:-inset-2 after:absolute md:after:hidden", "peer-data-[size=sm]/menu-button:top-1", "peer-data-[size=default]/menu-button:top-1.5", "peer-data-[size=lg]/menu-button:top-2.5", "group-data-[collapsible=icon]:hidden", showOnHover && "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0", className),
    ...props
  });
}
function SidebarMenuBadge({ className, ...props }) {
  return /* @__PURE__ */ jsx203("div", {
    "data-slot": "sidebar-menu-badge",
    "data-sidebar": "menu-badge",
    className: clsx50("pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 font-medium text-sidebar-foreground text-xs tabular-nums", "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground", "peer-data-[size=sm]/menu-button:top-1", "peer-data-[size=default]/menu-button:top-1.5", "peer-data-[size=lg]/menu-button:top-2.5", "group-data-[collapsible=icon]:hidden", className),
    ...props
  });
}
function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}) {
  const width = React98.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);
  return /* @__PURE__ */ jsxs104("div", {
    "data-slot": "sidebar-menu-skeleton",
    "data-sidebar": "menu-skeleton",
    className: clsx50("flex h-8 items-center gap-2 rounded-md px-2", className),
    ...props,
    children: [
      showIcon && /* @__PURE__ */ jsx203(Skeleton, {
        className: "size-4 rounded-md",
        "data-sidebar": "menu-skeleton-icon"
      }),
      /* @__PURE__ */ jsx203(Skeleton, {
        className: "h-4 max-w-(--skeleton-width) flex-1",
        "data-sidebar": "menu-skeleton-text",
        style: {
          "--skeleton-width": width
        }
      })
    ]
  });
}
function SidebarMenuSub({ className, ...props }) {
  return /* @__PURE__ */ jsx203("ul", {
    "data-slot": "sidebar-menu-sub",
    "data-sidebar": "menu-sub",
    className: clsx50("mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-sidebar-border border-l px-2.5 py-0.5", "group-data-[collapsible=icon]:hidden", className),
    ...props
  });
}
function SidebarMenuSubItem({ className, ...props }) {
  return /* @__PURE__ */ jsx203("li", {
    "data-slot": "sidebar-menu-sub-item",
    "data-sidebar": "menu-sub-item",
    className: clsx50("group/menu-sub-item relative", className),
    ...props
  });
}
function SidebarMenuSubButton({
  asChild = false,
  size: size42 = "md",
  isActive = false,
  className,
  ...props
}) {
  const Comp = asChild ? Slot4 : "a";
  return /* @__PURE__ */ jsx203(Comp, {
    "data-slot": "sidebar-menu-sub-button",
    "data-sidebar": "menu-sub-button",
    "data-size": size42,
    "data-active": isActive,
    className: clsx50("-translate-x-px flex h-7 min-w-0 items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-hidden ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground", "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground", size42 === "sm" && "text-xs", size42 === "md" && "text-sm", "group-data-[collapsible=icon]:hidden", className),
    ...props
  });
}
var DataPagination2 = Object.assign(DataPagination, {
  RecordCountDisplay,
  PaginationControls,
  RowsPerPageSelector
});
var InputOtp2 = Object.assign(InputOtp, {
  Group: InputOtpGroup,
  Slot: InputOtpSlot,
  HiddenInput: InputOtpHiddenInput
});
var Accordion3 = Object.assign(Accordion2, {
  Item: AccordionItem2,
  Trigger: AccordionTrigger2,
  Content: AccordionContent2
});
var AlertDialog3 = Object.assign(AlertDialog2, {
  Portal: AlertDialogPortal2,
  Overlay: AlertDialogOverlay2,
  Trigger: AlertDialogTrigger2,
  Content: AlertDialogContent2,
  Header: AlertDialogHeader,
  Footer: AlertDialogFooter,
  Title: AlertDialogTitle2,
  Description: AlertDialogDescription2,
  Action: AlertDialogAction2,
  Cancel: AlertDialogCancel2
});
var Alert2 = Object.assign(Alert, {
  Title: AlertTitle,
  Description: AlertDescription
});
var Avatar3 = Object.assign(Avatar2, {
  Image: AvatarImage2,
  Fallback: AvatarFallback2
});
var Badge2 = Object.assign(Badge, {
  Variants: badgeVariants
});
var Breadcrumb2 = Object.assign(Breadcrumb, {
  List: BreadcrumbList,
  Item: BreadcrumbItem,
  Link: BreadcrumbLink,
  Page: BreadcrumbPage,
  Separator: BreadcrumbSeparator,
  Ellipsis: BreadcrumbEllipsis
});
var ButtonGroup2 = Object.assign(ButtonGroup, {
  Separator: ButtonGroupSeparator,
  Text: ButtonGroupText,
  ButtonGroupVariants: buttonGroupVariants
});
var Button2 = Object.assign(Button, {
  Variants: buttonVariants2
});
var Card2 = Object.assign(Card, {
  Header: CardHeader,
  Footer: CardFooter,
  Title: CardTitle,
  Action: CardAction,
  Description: CardDescription,
  Content: CardContent
});
var Collapsible3 = Object.assign(Collapsible2, {
  Trigger: CollapsibleTrigger2,
  Content: CollapsibleContent2
});
var Command2 = Object.assign(Command, {
  Dialog: CommandDialog,
  Input: CommandInput,
  List: CommandList,
  Empty: CommandEmpty,
  Group: CommandGroup,
  Item: CommandItem,
  Shortcut: CommandShortcut,
  Separator: CommandSeparator
});
var ContextMenu3 = Object.assign(ContextMenu2, {
  Trigger: ContextMenuTrigger2,
  Content: ContextMenuContent2,
  Item: ContextMenuItem2,
  CheckboxItem: ContextMenuCheckboxItem2,
  RadioItem: ContextMenuRadioItem2,
  Label: ContextMenuLabel2,
  Separator: ContextMenuSeparator2,
  Shortcut: ContextMenuShortcut,
  Group: ContextMenuGroup2,
  Portal: ContextMenuPortal2,
  Sub: ContextMenuSub2,
  SubContent: ContextMenuSubContent2,
  SubTrigger: ContextMenuSubTrigger2,
  RadioGroup: ContextMenuRadioGroup2
});
var Dialog32 = Object.assign(Dialog22, {
  Close: DialogClose22,
  Content: DialogContent22,
  Description: DialogDescription22,
  Footer: DialogFooter,
  Header: DialogHeader,
  Overlay: DialogOverlay22,
  Portal: DialogPortal22,
  Title: DialogTitle22,
  Trigger: DialogTrigger22
});
var DropdownMenu3 = Object.assign(DropdownMenu2, {
  Portal: DropdownMenuPortal2,
  Trigger: DropdownMenuTrigger2,
  Content: DropdownMenuContent2,
  Group: DropdownMenuGroup2,
  Label: DropdownMenuLabel2,
  Item: DropdownMenuItem2,
  CheckboxItem: DropdownMenuCheckboxItem2,
  RadioGroup: DropdownMenuRadioGroup2,
  RadioItem: DropdownMenuRadioItem2,
  Separator: DropdownMenuSeparator2,
  Shortcut: DropdownMenuShortcut,
  Sub: DropdownMenuSub2,
  SubTrigger: DropdownMenuSubTrigger2,
  SubContent: DropdownMenuSubContent2
});
var Empty2 = Object.assign(Empty, {
  Header: EmptyHeader,
  Title: EmptyTitle,
  Description: EmptyDescription,
  Content: EmptyContent,
  Media: EmptyMedia
});
var Field2 = Object.assign(Field, {
  Label: FieldLabel,
  Description: FieldDescription,
  Error: FieldError,
  Group: FieldGroup,
  Legend: FieldLegend,
  Separator: FieldSeparator,
  Set: FieldSet,
  Content: FieldContent,
  Title: FieldTitle
});
var Form2 = Object.assign(Form, {
  Item: FormItem,
  Label: FormLabel,
  Control: FormControl,
  Description: FormDescription,
  Message: FormMessage,
  Field: FormField
});
var HoverCard3 = Object.assign(HoverCard2, {
  Trigger: HoverCardTrigger2,
  Content: HoverCardContent2
});
var InputGroup2 = Object.assign(InputGroup, {
  Addon: InputGroupAddon,
  Button: InputGroupButton,
  Text: InputGroupText,
  Input: InputGroupInput,
  Textarea: InputGroupTextarea
});
var Item6 = Object.assign(Item52, {
  Media: ItemMedia,
  Content: ItemContent,
  Actions: ItemActions,
  Group: ItemGroup,
  Separator: ItemSeparator,
  Title: ItemTitle,
  Description: ItemDescription,
  Header: ItemHeader,
  Footer: ItemFooter
});
var Kbd2 = Object.assign(Kbd, {
  Group: KbdGroup
});
var Menubar3 = Object.assign(Menubar22, {
  Portal: MenubarPortal22,
  Menu: MenubarMenu22,
  Trigger: MenubarTrigger22,
  Content: MenubarContent22,
  Group: MenubarGroup22,
  Separator: MenubarSeparator22,
  Label: MenubarLabel22,
  Item: MenubarItem22,
  Shortcut: MenubarShortcut,
  CheckboxItem: MenubarCheckboxItem22,
  RadioGroup: MenubarRadioGroup22,
  RadioItem: MenubarRadioItem22,
  Sub: MenubarSub22,
  SubTrigger: MenubarSubTrigger22,
  SubContent: MenubarSubContent22
});
var NavigationMenu3 = Object.assign(NavigationMenu2, {
  List: NavigationMenuList2,
  Item: NavigationMenuItem2,
  Content: NavigationMenuContent2,
  Trigger: NavigationMenuTrigger2,
  Link: NavigationMenuLink2,
  Indicator: NavigationMenuIndicator2,
  Viewport: NavigationMenuViewport2,
  NavigationMenuTriggerStyle: navigationMenuTriggerStyle
});
var Pagination2 = Object.assign(Pagination, {
  Content: PaginationContent,
  Link: PaginationLink,
  Item: PaginationItem,
  Previous: PaginationPrevious,
  Next: PaginationNext,
  Ellipsis: PaginationEllipsis
});
var Popover3 = Object.assign(Popover2, {
  Trigger: PopoverTrigger2,
  Content: PopoverContent2,
  Anchor: PopoverAnchor2
});
var RadioGroup6 = Object.assign(RadioGroup5, {
  Item: RadioGroupItem2
});
var ScrollArea3 = Object.assign(ScrollArea2, {
  ScrollBar
});
var Select3 = Object.assign(Select2, {
  Content: SelectContent2,
  Group: SelectGroup2,
  Item: SelectItem2,
  Label: SelectLabel2,
  ScrollDownButton: SelectScrollDownButton2,
  ScrollUpButton: SelectScrollUpButton2,
  Separator: SelectSeparator2,
  Trigger: SelectTrigger2,
  Value: SelectValue2
});
var Sheet2 = Object.assign(Sheet, {
  Trigger: SheetTrigger,
  Close: SheetClose,
  Content: SheetContent,
  Header: SheetHeader,
  Footer: SheetFooter,
  Title: SheetTitle,
  Description: SheetDescription
});
var Sidebar2 = Object.assign(Sidebar, {
  Content: SidebarContent,
  Footer: SidebarFooter,
  Group: SidebarGroup,
  GroupAction: SidebarGroupAction,
  GroupContent: SidebarGroupContent,
  GroupLabel: SidebarGroupLabel,
  Header: SidebarHeader,
  Input: SidebarInput,
  Inset: SidebarInset,
  Menu: SidebarMenu,
  MenuAction: SidebarMenuAction,
  MenuBadge: SidebarMenuBadge,
  MenuButton: SidebarMenuButton,
  MenuItem: SidebarMenuItem,
  MenuSkeleton: SidebarMenuSkeleton,
  MenuSub: SidebarMenuSub,
  MenuSubButton: SidebarMenuSubButton,
  MenuSubItem: SidebarMenuSubItem,
  Provider: SidebarProvider,
  Rail: SidebarRail,
  Separator: SidebarSeparator,
  Trigger: SidebarTrigger
});
var Table2 = Object.assign(Table, {
  Header: TableHeader,
  Body: TableBody,
  Footer: TableFooter,
  Head: TableHead,
  Row: TableRow,
  Cell: TableCell,
  Caption: TableCaption
});
var Tabs3 = Object.assign(Tabs2, {
  List: TabsList2,
  Trigger: TabsTrigger2,
  Content: TabsContent2
});
var ToggleGroup3 = Object.assign(ToggleGroup2, {
  Item: ToggleGroupItem2
});
var Toggle3 = Object.assign(Toggle2, {
  Variants: toggleVariants
});
var Tooltip3 = Object.assign(Tooltip2, {
  Trigger: TooltipTrigger2,
  Content: TooltipContent2,
  Provider: TooltipProvider2
});

// src/markdown/components.tsx
import clsx51 from "clsx";
import { memo as memo3, useCallback as useCallback39, useEffect as useEffect68, useState as useState59 } from "react";
import { useFetcher, useLocation as useLocation2, useNavigate } from "react-router";

// src/markdown/markdown-config.ts
var MARKDOWN_CONFIG = {
  EXTENSION: ".md",
  CHUNK_BY_FOLDER: true,
  INCREMENTAL_BY_FOLDER: false,
  PREFIX: "markdown",
  PURIFY_HTML: true,
  UPDATE_DATE: true,
  COMPRESS: true,
  CONCURRENCY: {
    FOLDERS: 5,
    FILES: 10
  },
  CACHE: {
    MAX_AGE: 3600
  }
};
var ASSET_PREFIX = {
  build: "/assets/docs",
  fetch: "/assets/docs"
};
var ASSET_ROUTES = {
  docs: (slug) => `/forge/docs/${slug}`,
  docsApi: (slug) => `/forge/docs/${slug}?api`
};
var DOMPURIFY_CONFIG = {
  ALLOWED_TAGS: [
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "p",
    "br",
    "strong",
    "em",
    "u",
    "s",
    "del",
    "a",
    "img",
    "ul",
    "ol",
    "li",
    "blockquote",
    "pre",
    "code",
    "table",
    "thead",
    "tbody",
    "tr",
    "th",
    "td",
    "hr",
    "div",
    "span"
  ],
  ALLOWED_ATTR: ["href", "title", "alt", "src", "class", "id", "start", "type", "colspan", "rowspan", "datetime", "scope", "data-*"],
  FORBID_TAGS: ["script", "object", "embed", "form", "input", "button", "iframe", "frame", "frameset", "noframes"],
  FORBID_ATTR: ["style", "on*"],
  KEEP_CONTENT: true,
  ALLOW_DATA_ATTR: false
};
var HIGHLIGHTER_CONFIG = {
  LANGS: ["bash", "css", "html", "javascript", "json", "markdown", "sql", "text", "ts", "tsx", "typescript", "xml", "yaml"],
  THEMES: ["night-owl"]
};

// src/markdown/components.tsx
import { jsx as jsx205, jsxs as jsxs105 } from "react/jsx-runtime";
function MarkdownRenderer({ children, className = "" }) {
  if (!children || typeof children !== "string") {
    return /* @__PURE__ */ jsx205("div", {
      className
    });
  }
  return /* @__PURE__ */ jsx205("div", {
    className,
    dangerouslySetInnerHTML: { __html: children }
  });
}
var isDocContent = (data) => {
  return typeof data === "object" && data !== null && "content" in data && "frontmatter" in data && "slug" in data;
};
var isMarkdownPageData = (data) => {
  return typeof data === "object" && data !== null && "manifest" in data;
};
function MarkdownPage({ loaderData, spriteUrl, themeContext }) {
  const pageData = isMarkdownPageData(loaderData) ? loaderData : { manifest: loaderData, selectedDoc: undefined, document: undefined };
  const { manifest: docs, selectedDoc: preloadedDoc, document: preloadedDocument, loading: serverLoading } = pageData;
  const location = useLocation2();
  const navigate = useNavigate();
  const [selectedDoc, setSelectedDoc] = useState59(preloadedDoc || null);
  const [error, setError] = useState59(null);
  const [sidebarCollapsed, setSidebarCollapsed] = useState59(false);
  const [mounted, setMounted] = useState59(false);
  const fetcher = useFetcher();
  useEffect68(() => setMounted(true), []);
  const handleDocSelect = useCallback39((slug) => {
    if (selectedDoc === slug)
      return;
    navigate(ASSET_ROUTES.docs(slug));
  }, [selectedDoc, navigate]);
  useEffect68(() => {
    if (preloadedDoc && preloadedDoc !== selectedDoc) {
      setSelectedDoc(preloadedDoc);
      setError(null);
    } else {
      const pathParts = location.pathname.split("/");
      const docsIndex = pathParts.indexOf("docs");
      if (docsIndex !== -1 && docsIndex < pathParts.length - 1) {
        const slug = pathParts.slice(docsIndex + 1).join("/");
        if (slug && docs.find((doc) => doc.slug === slug) && selectedDoc !== slug) {
          setSelectedDoc(slug);
          if (!preloadedDocument || preloadedDoc !== slug) {
            fetcher.load(ASSET_ROUTES.docsApi(slug));
          }
        }
      } else if (selectedDoc && !preloadedDoc) {
        setSelectedDoc(null);
        setError(null);
      }
    }
  }, [docs, fetcher.load, selectedDoc, location.pathname, preloadedDoc, preloadedDocument]);
  useEffect68(() => {
    if (fetcher.state === "idle" && fetcher.data && !isDocContent(fetcher.data)) {
      setError("Failed to load document");
    }
  }, [fetcher.state, fetcher.data]);
  const currentDoc = preloadedDocument && preloadedDoc === selectedDoc ? { content: preloadedDocument.content, frontmatter: preloadedDocument.frontmatter, slug: selectedDoc } : isDocContent(fetcher.data) ? fetcher.data : undefined;
  return /* @__PURE__ */ jsx205("div", {
    className: "min-h-screen bg-white transition-colors dark:bg-gray-900",
    children: /* @__PURE__ */ jsxs105("div", {
      className: "flex",
      children: [
        /* @__PURE__ */ jsx205("aside", {
          className: `fixed inset-y-0 top-0 left-0 z-20 overflow-y-auto border-gray-200 border-r bg-white transition-transform duration-300 dark:border-gray-800 dark:bg-gray-900 ${sidebarCollapsed ? "-translate-x-full" : "translate-x-0"} w-80`,
          children: /* @__PURE__ */ jsxs105("div", {
            className: "p-6",
            children: [
              /* @__PURE__ */ jsxs105("div", {
                className: "mb-6 flex items-center justify-between",
                children: [
                  /* @__PURE__ */ jsx205("h2", {
                    className: "font-semibold text-gray-900 text-lg dark:text-white",
                    children: "Documentation"
                  }),
                  /* @__PURE__ */ jsx205("div", {
                    children: /* @__PURE__ */ jsx205("button", {
                      type: "button",
                      onClick: () => setSidebarCollapsed(!sidebarCollapsed),
                      className: "rounded-md p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200",
                      children: /* @__PURE__ */ jsx205(SpriteIcon2, {
                        spriteUrl,
                        iconId: "ChevronLeft",
                        className: "h-5 w-5"
                      })
                    })
                  })
                ]
              }),
              /* @__PURE__ */ jsx205("nav", {
                className: "space-y-1",
                "aria-label": "Documentation navigation",
                children: docs.length === 0 ? /* @__PURE__ */ jsx205(DocListEmpty, {}) : /* @__PURE__ */ jsx205(DocList, {
                  docs,
                  selectedDoc,
                  onDocSelect: handleDocSelect,
                  spriteUrl
                })
              }),
              /* @__PURE__ */ jsxs105("div", {
                className: "fixed right-4 bottom-4 z-10 flex items-center justify-between gap-x-4",
                children: [
                  /* @__PURE__ */ jsx205(Link4, {
                    href: "/",
                    children: /* @__PURE__ */ jsx205(SpriteIcon2, {
                      spriteUrl,
                      iconId: "House",
                      className: "size-5 text-accent-foreground",
                      viewBox: "0 0 24 24"
                    })
                  }),
                  !mounted ? /* @__PURE__ */ jsx205("div", {
                    className: "size-5"
                  }) : /* @__PURE__ */ jsx205(ThemeSwitch, {
                    spriteUrl,
                    children: themeContext ? ({ theme }) => /* @__PURE__ */ jsx205("button", {
                      type: "button",
                      className: "size-5 hover:animate-rotate",
                      "aria-label": "theme switch",
                      onClick: () => {
                        themeContext.setTheme(themeContext.resolvedTheme === theme.theme.dark ? theme.theme.light : theme.theme.dark);
                      },
                      children: themeContext.resolvedTheme === theme.theme.dark ? /* @__PURE__ */ jsx205(SpriteIcon2, {
                        spriteUrl,
                        iconId: "Moon",
                        className: "size-5"
                      }) : /* @__PURE__ */ jsx205(SpriteIcon2, {
                        spriteUrl,
                        iconId: "Sun",
                        className: "size-5"
                      })
                    }) : undefined
                  })
                ]
              })
            ]
          })
        }),
        /* @__PURE__ */ jsx205("button", {
          type: "button",
          onClick: () => setSidebarCollapsed(false),
          className: `fixed top-4 left-4 z-30 rounded-md border border-gray-200 bg-white p-2 text-gray-500 shadow-sm transition-opacity duration-300 hover:text-gray-700 dark:border-gray-800 dark:bg-gray-900 dark:text-gray-400 dark:hover:text-gray-200 ${sidebarCollapsed ? "opacity-100" : "pointer-events-none opacity-0"}`,
          children: /* @__PURE__ */ jsx205(SpriteIcon2, {
            spriteUrl,
            iconId: "EllipsisVertical",
            className: "h-5 w-5"
          })
        }),
        /* @__PURE__ */ jsx205("main", {
          className: `flex-1 transition-all duration-300 ${sidebarCollapsed ? "pl-0" : "pl-64"} min-w-0`,
          children: /* @__PURE__ */ jsx205("div", {
            className: "mx-auto min-w-0 max-w-4xl px-4 md:px-8",
            children: !selectedDoc ? /* @__PURE__ */ jsx205("div", {
              className: "flex h-96 items-center justify-center",
              children: /* @__PURE__ */ jsxs105("div", {
                className: "text-center",
                children: [
                  /* @__PURE__ */ jsx205("div", {
                    className: "mb-4 text-gray-400 dark:text-gray-500",
                    children: /* @__PURE__ */ jsx205(SpriteIcon2, {
                      spriteUrl,
                      iconId: "CircleAlert",
                      className: "h-8 w-8"
                    })
                  }),
                  /* @__PURE__ */ jsx205("h3", {
                    className: "mb-2 font-medium text-gray-900 text-lg dark:text-white",
                    children: "Select a document"
                  }),
                  /* @__PURE__ */ jsx205("p", {
                    className: "text-gray-500 dark:text-gray-400",
                    children: "Choose a document from the sidebar to view its content."
                  })
                ]
              })
            }) : fetcher.state === "loading" || serverLoading || selectedDoc && !currentDoc && !error ? /* @__PURE__ */ jsx205(LoadingBar, {}) : error ? /* @__PURE__ */ jsx205(DocumentNotFound, {
              spriteUrl
            }) : currentDoc ? /* @__PURE__ */ jsxs105("article", {
              className: "markdown-content min-w-0 py-8 md:py-12",
              children: [
                /* @__PURE__ */ jsx205(DocumentHeader, {
                  frontmatter: currentDoc.frontmatter
                }),
                /* @__PURE__ */ jsx205(MarkdownRenderer, {
                  className: "min-w-0 max-w-none",
                  children: currentDoc.content
                })
              ]
            }) : /* @__PURE__ */ jsx205(DocumentNotFound, {
              spriteUrl
            })
          })
        })
      ]
    })
  });
}
var DocListEmpty = () => {
  return /* @__PURE__ */ jsx205("p", {
    className: "text-gray-500 text-sm dark:text-gray-400",
    children: "No documentation found."
  });
};
var DocumentNotFound = memo3(({ spriteUrl }) => /* @__PURE__ */ jsx205("div", {
  className: "flex h-96 items-center justify-center",
  children: /* @__PURE__ */ jsxs105("div", {
    className: "text-center",
    children: [
      /* @__PURE__ */ jsx205("div", {
        className: "mb-4 text-red-400 dark:text-red-500",
        children: /* @__PURE__ */ jsx205(SpriteIcon2, {
          spriteUrl,
          iconId: "CircleAlert",
          className: "mx-auto h-8 w-8"
        })
      }),
      /* @__PURE__ */ jsx205("h3", {
        className: "mb-2 font-medium text-gray-900 text-lg dark:text-white",
        children: "Document not found"
      }),
      /* @__PURE__ */ jsx205("p", {
        className: "text-gray-500 dark:text-gray-400",
        children: "The selected document could not be loaded."
      })
    ]
  })
}));
var DocumentHeader = memo3(({ frontmatter }) => /* @__PURE__ */ jsxs105("header", {
  className: "mb-8",
  children: [
    frontmatter.title && /* @__PURE__ */ jsx205("h1", {
      className: "mb-4 font-bold font-serif text-3xl text-gray-900 dark:text-white",
      children: frontmatter.title
    }),
    frontmatter.description && /* @__PURE__ */ jsx205("p", {
      className: "mb-4 font-serif text-gray-600 text-lg dark:text-gray-300",
      children: frontmatter.description
    }),
    (frontmatter.formattedDate || frontmatter.version) && /* @__PURE__ */ jsxs105("div", {
      className: "flex items-center justify-between text-gray-500 text-sm dark:text-gray-400",
      children: [
        frontmatter.formattedDate && /* @__PURE__ */ jsx205("time", {
          className: "font-sans",
          dateTime: frontmatter.date,
          children: frontmatter.formattedDate
        }),
        frontmatter.version && /* @__PURE__ */ jsx205("span", {
          className: "px-2 py-1 font-mono text-gray-300 text-xs italic dark:text-gray-600",
          children: frontmatter.version
        })
      ]
    })
  ]
}));
var DocList = memo3(({ docs, selectedDoc, onDocSelect, spriteUrl }) => {
  const groupedDocs = useCallback39(() => {
    const groups2 = {};
    for (const doc of docs) {
      const folder = doc.folder || "";
      if (!groups2[folder]) {
        groups2[folder] = [];
      }
      groups2[folder].push(doc);
    }
    return groups2;
  }, [docs]);
  const groups = groupedDocs();
  return /* @__PURE__ */ jsx205("div", {
    className: "space-y-1",
    children: Object.entries(groups).map(([folder, folderDocs]) => {
      const isRootLevel = folder === "";
      const folderId = `folder-${folder.replace(/[^a-zA-Z0-9]/g, "-")}`;
      return /* @__PURE__ */ jsxs105("div", {
        children: [
          !isRootLevel && /* @__PURE__ */ jsxs105("div", {
            className: "relative",
            children: [
              /* @__PURE__ */ jsx205("input", {
                type: "checkbox",
                id: folderId,
                className: "peer hidden",
                defaultChecked: true
              }),
              /* @__PURE__ */ jsxs105("label", {
                htmlFor: folderId,
                className: "flex w-full cursor-pointer items-center px-3 py-2 text-left text-gray-600 text-sm transition-colors hover:bg-gray-50 dark:text-gray-400 dark:hover:bg-gray-800/50",
                children: [
                  /* @__PURE__ */ jsx205(SpriteIcon2, {
                    spriteUrl,
                    iconId: "ChevronRight",
                    className: "mr-2 h-3 w-3 transition-transform duration-200 peer-checked:rotate-90"
                  }),
                  /* @__PURE__ */ jsx205("span", {
                    className: "font-medium capitalize",
                    children: folder
                  })
                ]
              }),
              /* @__PURE__ */ jsx205("div", {
                className: "ml-6 max-h-0 space-y-0.5 overflow-hidden transition-all duration-300 peer-checked:max-h-96",
                children: folderDocs.map((doc) => /* @__PURE__ */ jsx205("button", {
                  type: "button",
                  onClick: () => onDocSelect(doc.slug),
                  className: clsx51("w-full px-3 py-2 text-left text-sm transition-colors focus:outline-none", selectedDoc === doc.slug ? "border-blue-500 border-r-2 bg-blue-50 text-blue-900 dark:border-blue-400 dark:bg-blue-900/20 dark:text-blue-100" : "text-gray-700 hover:bg-gray-50 dark:text-gray-300 dark:hover:bg-gray-800/50"),
                  children: /* @__PURE__ */ jsx205("div", {
                    className: "flex items-center",
                    children: /* @__PURE__ */ jsx205("div", {
                      className: "flex-1",
                      children: /* @__PURE__ */ jsx205("div", {
                        className: "font-medium",
                        children: doc.title || doc.slug
                      })
                    })
                  })
                }, doc.slug))
              })
            ]
          }),
          isRootLevel && /* @__PURE__ */ jsx205("div", {
            className: "space-y-0.5",
            children: folderDocs.map((doc) => /* @__PURE__ */ jsx205("button", {
              type: "button",
              onClick: () => onDocSelect(doc.slug),
              className: clsx51("w-full px-3 py-2 text-left text-sm transition-colors focus:outline-none", selectedDoc === doc.slug ? "border-blue-500 border-r-2 bg-blue-50 text-blue-900 dark:border-blue-400 dark:bg-blue-900/20 dark:text-blue-100" : "text-gray-700 hover:bg-gray-50 dark:text-gray-300 dark:hover:bg-gray-800/50"),
              children: /* @__PURE__ */ jsx205("div", {
                className: "font-medium",
                children: doc.title || doc.slug
              })
            }, doc.slug))
          })
        ]
      }, folder || "root");
    })
  });
});
// ../../node_modules/valibot/dist/index.js
var store;
function getGlobalConfig(config2) {
  return {
    lang: config2?.lang ?? store?.lang,
    message: config2?.message,
    abortEarly: config2?.abortEarly ?? store?.abortEarly,
    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2?.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3?.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  return store4?.get(reference)?.get(lang);
}
function _stringify(input) {
  const type = typeof input;
  if (type === "string") {
    return `"${input}"`;
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return `${input}`;
  }
  if (type === "object" || type === "function") {
    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  }
  return type;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = other?.expected ?? context.expects ?? null;
  const received = other?.received ?? _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message2 = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
  if (message2 !== undefined) {
    issue.message = typeof message2 === "function" ? message2(issue) : message2;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
function _getStandardProps(context) {
  return {
    version: 1,
    vendor: "valibot",
    validate(value2) {
      return context["~run"]({ value: value2 }, getGlobalConfig());
    }
  };
}
var ValiError = class extends Error {
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
};
function check(requirement, message2) {
  return {
    kind: "validation",
    type: "check",
    reference: check,
    async: false,
    expects: null,
    requirement,
    message: message2,
    "~run"(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "input", dataset, config2);
      }
      return dataset;
    }
  };
}
function minLength(requirement, message2) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: false,
    expects: `>=${requirement}`,
    requirement,
    message: message2,
    "~run"(dataset, config2) {
      if (dataset.typed && dataset.value.length < this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: `${dataset.value.length}`
        });
      }
      return dataset;
    }
  };
}
function regex(requirement, message2) {
  return {
    kind: "validation",
    type: "regex",
    reference: regex,
    async: false,
    expects: `${requirement}`,
    requirement,
    message: message2,
    "~run"(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "format", dataset, config2);
      }
      return dataset;
    }
  };
}
function trim() {
  return {
    kind: "transformation",
    type: "trim",
    reference: trim,
    async: false,
    "~run"(dataset) {
      dataset.value = dataset.value.trim();
      return dataset;
    }
  };
}
function string(message2) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function parse4(schema, input, config2) {
  const dataset = schema["~run"]({ value: input }, getGlobalConfig(config2));
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}
function pipe(...pipe2) {
  return {
    ...pipe2[0],
    pipe: pipe2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      for (const item of pipe2) {
        if (item.kind !== "metadata") {
          if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
            dataset.typed = false;
            break;
          }
          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
            dataset = item["~run"](dataset, config2);
          }
        }
      }
      return dataset;
    }
  };
}

// src/markdown/markdown-utils.ts
var documentSlugSchema = pipe(string(), trim(), minLength(1, "Slug cannot be empty"), regex(/^[a-zA-Z0-9-_/]+$/, "Slug can only contain letters, numbers, hyphens, underscores, and forward slashes"), check((slug) => !slug.includes(".."), "Directory traversal not allowed"), check((slug) => !slug.startsWith("/"), "Slug cannot start with forward slash"), check((slug) => !slug.endsWith("/"), "Slug cannot end with forward slash"));
function validateDocumentSlug(slug) {
  try {
    return parse4(documentSlugSchema, slug);
  } catch (error) {
    if (error instanceof ValiError) {
      const message = error.issues[0]?.message || "Invalid document url";
      throw new Response(message, { status: 400 });
    }
    throw new Response("Invalid document slug", { status: 400 });
  }
}
function formatAssetUrl(filename, request, prefix) {
  const fetchPrefix = prefix || ASSET_PREFIX.fetch;
  const normalizedPrefix = fetchPrefix.endsWith("/") ? fetchPrefix.slice(0, -1) : fetchPrefix;
  const url = `${normalizedPrefix}/${filename}`;
  return request ? new URL(url, request.url).href : url;
}

// src/markdown/markdown-data.ts
var manifestCache = null;
var globalManifestCache = null;
var contentCache = null;
var folderContentCache = new Map;
async function fetchContent(url, assets) {
  const fetchFn = (input, init) => assets.fetch(input, init);
  const baseUrl = url.endsWith(".gz") ? url.replace(".gz", "") : url;
  const gzUrl = `${baseUrl}.gz`;
  try {
    const gzResponse = await fetchFn(gzUrl);
    if (gzResponse.ok) {
      const compressedData = await gzResponse.arrayBuffer();
      const decompressedStream = new DecompressionStream("gzip");
      const decompressedResponse = new Response(new ReadableStream({
        start(controller) {
          controller.enqueue(new Uint8Array(compressedData));
          controller.close();
        }
      }).pipeThrough(decompressedStream));
      const decompressedText = await decompressedResponse.text();
      const parsed = JSON.parse(decompressedText);
      return parsed;
    }
  } catch (_compressionError) {}
  try {
    const response = await fetchFn(baseUrl);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const parsed = await response.json();
    return parsed;
  } catch (uncompressedError) {
    const errorMsg = `Failed to fetch both compressed (${gzUrl}) and uncompressed (${baseUrl}) versions: ${uncompressedError instanceof Error ? uncompressedError.message : "Unknown error"}`;
    throw new Error(errorMsg);
  }
}
async function getGlobalManifest(assets, request, prefix) {
  if (globalManifestCache) {
    return globalManifestCache;
  }
  try {
    const manifestUrl = formatAssetUrl(`${prefix || MARKDOWN_CONFIG.PREFIX}-manifest.json`, request);
    const globalManifest = await fetchContent(manifestUrl, assets);
    globalManifestCache = globalManifest;
    return globalManifest;
  } catch (_error) {
    return { documents: [], _buildMode: "single" };
  }
}
async function getMarkdownManifest(assets, request, prefix) {
  if (manifestCache) {
    return manifestCache;
  }
  const globalManifest = await getGlobalManifest(assets, request, prefix);
  const cleanManifest = globalManifest.documents.map(({ _mtime, _size, ...item }) => item);
  manifestCache = cleanManifest;
  return cleanManifest;
}
async function getMarkdownContent(assets, request, prefix) {
  const globalManifest = await getGlobalManifest(assets, request, prefix);
  if (globalManifest._buildMode === "chunked") {
    return {};
  }
  if (contentCache) {
    return contentCache;
  }
  try {
    const contentUrl = formatAssetUrl(`${prefix || MARKDOWN_CONFIG.PREFIX}-content.json`, request);
    const content = await fetchContent(contentUrl, assets);
    contentCache = content;
    return content;
  } catch (_error) {
    return {};
  }
}
async function loadFolderContent(folder, assets, request, prefix) {
  if (folderContentCache.has(folder)) {
    const cachedContent = folderContentCache.get(folder);
    if (cachedContent) {
      return cachedContent;
    }
  }
  try {
    const folderKey = folder.replace(/[/\\]/g, "-");
    const contentUrl = formatAssetUrl(`${prefix || MARKDOWN_CONFIG.PREFIX}-content-${folderKey}.json`, request);
    const content = await fetchContent(contentUrl, assets);
    folderContentCache.set(folder, content);
    return content;
  } catch (_error) {
    return {};
  }
}
async function getMarkdownDocument(slug, assets, request, prefix) {
  const globalManifest = await getGlobalManifest(assets, request, prefix);
  if (globalManifest._buildMode === "chunked") {
    const manifest = await getMarkdownManifest(assets, request, prefix);
    const docMeta = manifest.find((doc) => doc.slug === slug);
    if (!docMeta) {
      return null;
    }
    const folder = docMeta.folder || "root";
    const folderContent = await loadFolderContent(folder, assets, request, prefix);
    return folderContent[slug] || null;
  }
  const content = await getMarkdownContent(assets, request, prefix);
  return content[slug] || null;
}
function clearMarkdownCache() {
  manifestCache = null;
  globalManifestCache = null;
  contentCache = null;
  folderContentCache.clear();
}
async function hasMarkdownDocument(slug, assets, request, prefix) {
  const globalManifest = await getGlobalManifest(assets, request, prefix);
  if (globalManifest._buildMode === "chunked") {
    const manifest = await getMarkdownManifest(assets, request, prefix);
    return manifest.some((doc) => doc.slug === slug);
  }
  const content = await getMarkdownContent(assets, request, prefix);
  return slug in content;
}
export {
  validateDocumentSlug,
  hasMarkdownDocument,
  getMarkdownManifest,
  getMarkdownDocument,
  getMarkdownContent,
  formatAssetUrl,
  clearMarkdownCache,
  MarkdownRenderer,
  MarkdownPage,
  MARKDOWN_CONFIG,
  HIGHLIGHTER_CONFIG,
  DOMPURIFY_CONFIG,
  ASSET_ROUTES,
  ASSET_PREFIX
};

//# debugId=0FDCD492893A2CB364756E2164756E21
