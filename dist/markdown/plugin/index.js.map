{
  "version": 3,
  "sources": ["../../../src/markdown/plugin/markdown-plugin.ts", "../../../src/markdown/markdown-config.ts", "../../../src/markdown/plugin/plugin-utils.ts"],
  "sourcesContent": [
    "/** biome-ignore-all lint/suspicious/noExplicitAny: acceptable */\nimport { existsSync } from 'node:fs';\nimport { mkdir, readdir, readFile, stat, utimes, writeFile } from 'node:fs/promises';\nimport path from 'node:path';\nimport { promisify } from 'node:util';\nimport { gzip } from 'node:zlib';\nimport DOMPurify from 'isomorphic-dompurify';\nimport { marked } from 'marked';\nimport { createHighlighter } from 'shiki';\nimport type { Plugin } from 'vite';\nimport type { FileMetadata, FolderContentChunk, Frontmatter, GlobalManifest, MarkdownBuilderOptions, MarkdownMeta, ProcessingResult, ShikiConfig, SyntaxHighlighter } from '../@types/markdown.types';\nimport { DOMPURIFY_CONFIG, HIGHLIGHTER_CONFIG, MARKDOWN_CONFIG } from '../markdown-config';\nimport { getAssetPath } from './plugin-utils';\n\nconst gzipAsync = promisify(gzip);\n\nexport function markdownBuilder(options: MarkdownBuilderOptions): Plugin {\n  const {\n    source,\n    extension = MARKDOWN_CONFIG.EXTENSION,\n    chunkByFolder = MARKDOWN_CONFIG.CHUNK_BY_FOLDER,\n    incrementalByFolder = MARKDOWN_CONFIG.INCREMENTAL_BY_FOLDER,\n    prefix = MARKDOWN_CONFIG.PREFIX,\n    purifyHtml = MARKDOWN_CONFIG.PURIFY_HTML,\n    shikiConfig,\n    syntaxHighlighter,\n    updateDate = MARKDOWN_CONFIG.UPDATE_DATE,\n    compress = MARKDOWN_CONFIG.COMPRESS,\n  } = options;\n\n  let highlighter: SyntaxHighlighter | null = null;\n  let isInitialized = false;\n\n  async function updateFrontmatterDate(filePath: string, content: string, fileMtime: number): Promise<string> {\n    if (!updateDate) return content;\n\n    const { data: frontmatter, content: markdown } = parseFrontmatter(content);\n    const fileDate = new Date(fileMtime).toISOString().split('T')[0];\n\n    if (!frontmatter || typeof frontmatter !== 'object' || Array.isArray(frontmatter)) return content;\n    if (frontmatter.date === fileDate) return content;\n\n    const updatedFrontmatter = { ...frontmatter, date: fileDate };\n    const frontmatterStr = Object.entries(updatedFrontmatter)\n      .map(([key, value]) => `${key}: ${typeof value === 'string' ? `\"${value}\"` : value}`)\n      .join('\\n');\n\n    const updatedContent = `---\\n${frontmatterStr}\\n---\\n${markdown}`;\n\n    try {\n      await writeFile(filePath, updatedContent);\n\n      // Restore original timestamp to preserve manual edit time\n      const originalDate = new Date(fileMtime);\n      await utimes(filePath, originalDate, originalDate);\n\n      console.info(`üìÖ Updated frontmatter date in ${filePath} to match file`);\n      return updatedContent;\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Failed to update date in ${filePath}:`, error);\n      return content;\n    }\n  }\n\n  // Initialize highlighter and marked configuration\n  async function initializeHighlighter(): Promise<void> {\n    if (isInitialized) return;\n\n    if (syntaxHighlighter === null) {\n      highlighter = null;\n    } else if (syntaxHighlighter) {\n      highlighter = syntaxHighlighter;\n    } else {\n      try {\n        highlighter = await createShikiHighlighter(shikiConfig);\n      } catch (error) {\n        console.warn('‚ö†Ô∏è Failed to initialize Shiki highlighter:', error);\n        highlighter = null;\n      }\n    }\n\n    isInitialized = true;\n  }\n\n  async function collectMarkdownFilesWithMetadata(dir: string): Promise<Map<string, { path: string; metadata: FileMetadata }>> {\n    const result = new Map();\n\n    async function walk(current: string) {\n      const entries = await readdir(current, { withFileTypes: true });\n      await Promise.all(\n        entries.map(async entry => {\n          const full = path.join(current, entry.name);\n          if (entry.isDirectory()) return walk(full);\n          if (!entry.name.endsWith(extension)) return;\n          const stats = await stat(full);\n          const rel = path.relative(dir, full);\n          result.set(rel, { path: full, metadata: { mtime: stats.mtime.getTime(), size: stats.size } });\n        })\n      );\n    }\n\n    await walk(dir);\n    return result;\n  }\n\n  async function collectFilesByFolder(dir: string): Promise<Map<string, Map<string, { path: string; metadata: FileMetadata }>>> {\n    const folderMap = new Map();\n    const files = await collectMarkdownFilesWithMetadata(dir);\n\n    for (const [relPath, fileInfo] of files) {\n      const folder = path.dirname(relPath) === '.' ? 'root' : path.dirname(relPath);\n      if (!folderMap.has(folder)) {\n        folderMap.set(folder, new Map());\n      }\n      folderMap.get(folder)?.set(relPath, fileInfo);\n    }\n\n    return folderMap;\n  }\n\n  function isFileChanged(prev: MarkdownMeta | undefined, current: FileMetadata): boolean {\n    return !prev || prev._mtime !== current.mtime || prev._size !== current.size;\n  }\n\n  async function checkForChanges(dir: string, previous: MarkdownMeta[]) {\n    const previousMap = new Map(previous.map(entry => [entry.path, entry]));\n    const currentFiles = await collectMarkdownFilesWithMetadata(dir);\n\n    for (const [relPath, { metadata }] of currentFiles) {\n      if (isFileChanged(previousMap.get(relPath), metadata)) {\n        return { changed: true, updatedFiles: currentFiles };\n      }\n    }\n\n    if (previous.length !== currentFiles.size) {\n      return { changed: true, updatedFiles: currentFiles };\n    }\n\n    return { changed: false, updatedFiles: currentFiles };\n  }\n\n  async function checkForFolderChanges(dir: string): Promise<{ changedFolders: Set<string>; allFolders: Map<string, Map<string, { path: string; metadata: FileMetadata }>> }> {\n    const allFolders = await collectFilesByFolder(dir);\n    const changedFolders = new Set<string>();\n\n    if (!incrementalByFolder) {\n      // If not incremental, mark all folders as changed\n      for (const folder of allFolders.keys()) {\n        changedFolders.add(folder);\n      }\n      return { changedFolders, allFolders };\n    }\n\n    // Load previous global manifest and check for folder changes\n    const prevGlobalManifest = await loadPreviousManifest();\n    const prevFilesByFolder = new Map<string, Map<string, MarkdownMeta>>();\n\n    // Group previous files by folder\n    for (const meta of prevGlobalManifest) {\n      const folder = meta.folder || 'root';\n      if (!prevFilesByFolder.has(folder)) {\n        prevFilesByFolder.set(folder, new Map());\n      }\n      prevFilesByFolder.get(folder)?.set(meta.path, meta);\n    }\n\n    // Check each current folder against previous state\n    for (const [folder, files] of allFolders) {\n      const prevFiles = prevFilesByFolder.get(folder);\n\n      if (!prevFiles) {\n        // New folder\n        changedFolders.add(folder);\n        continue;\n      }\n\n      // Check if any files in this folder have changed\n      let folderChanged = false;\n      for (const [relPath, { metadata }] of files) {\n        const prevFile = prevFiles.get(relPath);\n        if (isFileChanged(prevFile, metadata)) {\n          folderChanged = true;\n          break;\n        }\n      }\n\n      // Check if file count changed\n      if (!folderChanged && prevFiles.size !== files.size) {\n        folderChanged = true;\n      }\n\n      if (folderChanged) {\n        changedFolders.add(folder);\n      }\n    }\n\n    return { changedFolders, allFolders };\n  }\n\n  async function processChangedFiles(files: Map<string, { path: string; metadata: FileMetadata }>): Promise<ProcessingResult> {\n    await initializeHighlighter();\n\n    const manifest: MarkdownMeta[] = [];\n    const content: Record<string, any> = {};\n    let errorCount = 0;\n\n    const entries = [...files.entries()];\n\n    await execConcurrently(entries, MARKDOWN_CONFIG.CONCURRENCY.FILES, async ([relPath, { path: filePath, metadata }]) => {\n      try {\n        const raw = await readFile(filePath, 'utf8');\n        const updated = await updateFrontmatterDate(filePath, raw, metadata.mtime);\n        const { data: frontmatter } = parseFrontmatter(updated);\n        const { content: html, error, errorContext } = await processMarkdownFile(filePath, purifyHtml, highlighter);\n\n        if (error) {\n          const errorMessage = errorContext ? `${error}\\n  File: ${filePath}\\n  ${errorContext}` : `${error}\\n  File: ${filePath}`;\n          throw new Error(errorMessage);\n        }\n\n        const slug = relPath.replace(new RegExp(`${extension}$`), '');\n        const folder = path.dirname(relPath) === '.' ? undefined : path.dirname(relPath);\n\n        const validFrontmatter = (frontmatter as Frontmatter) || {};\n        manifest.push({ slug, path: relPath, folder, _mtime: metadata.mtime, _size: metadata.size, ...validFrontmatter });\n        content[slug] = { frontmatter: validFrontmatter, content: html };\n      } catch (e) {\n        errorCount++;\n        console.error(`‚ùå Error processing ${filePath}:`, e);\n      }\n    });\n\n    return { manifest: sortManifest(manifest), content, processedCount: manifest.length, errorCount };\n  }\n\n  async function processFolderFiles(folderFiles: Map<string, { path: string; metadata: FileMetadata }>): Promise<{ manifest: MarkdownMeta[]; content: FolderContentChunk; errorCount: number }> {\n    await initializeHighlighter();\n\n    const manifest: MarkdownMeta[] = [];\n    const content: FolderContentChunk = {};\n    let errorCount = 0;\n\n    const entries = [...folderFiles.entries()];\n\n    await execConcurrently(entries, MARKDOWN_CONFIG.CONCURRENCY.FILES, async ([relPath, { path: filePath, metadata }]) => {\n      try {\n        const raw = await readFile(filePath, 'utf8');\n        const updated = await updateFrontmatterDate(filePath, raw, metadata.mtime);\n        const { data: frontmatter } = parseFrontmatter(updated);\n        const { content: html, error, errorContext } = await processMarkdownFile(filePath, purifyHtml, highlighter);\n\n        if (error) {\n          const errorMessage = errorContext ? `${error}\\n  File: ${filePath}\\n  ${errorContext}` : `${error}\\n  File: ${filePath}`;\n          throw new Error(errorMessage);\n        }\n\n        const slug = relPath.replace(new RegExp(`${extension}$`), '');\n        const folder = path.dirname(relPath) === '.' ? undefined : path.dirname(relPath);\n\n        const validFrontmatter = (frontmatter as Frontmatter) || {};\n        manifest.push({ slug, path: relPath, folder, _mtime: metadata.mtime, _size: metadata.size, ...validFrontmatter });\n        content[slug] = { frontmatter: validFrontmatter, content: html };\n      } catch (e) {\n        errorCount++;\n        console.error(`‚ùå Error processing ${filePath}:`, e);\n      }\n    });\n\n    return { manifest: sortManifest(manifest), content, errorCount };\n  }\n\n  async function processChangedFolders(changedFolders: Set<string>, allFolders: Map<string, Map<string, { path: string; metadata: FileMetadata }>>) {\n    await initializeHighlighter();\n\n    const globalManifest: MarkdownMeta[] = [];\n    let totalProcessed = 0;\n    let totalErrors = 0;\n\n    // Process folders in parallel with limited concurrency\n    // biome-ignore lint/style/noNonNullAssertion: satisfactory\n    const folderEntries = Array.from(changedFolders).map(folder => ({ folder, files: allFolders.get(folder)! }));\n\n    await execConcurrently(folderEntries, MARKDOWN_CONFIG.CONCURRENCY.FOLDERS, async ({ folder, files }) => {\n      try {\n        console.info(`üìÇ Processing folder: ${folder} (${files.size} files)`);\n        const result = await processFolderFiles(files);\n\n        // Write folder-specific files\n        await writeFolderFiles(folder, result.manifest, result.content);\n\n        // Add to global manifest\n        globalManifest.push(...result.manifest);\n        totalProcessed += result.manifest.length;\n        totalErrors += result.errorCount;\n\n        console.info(`‚úÖ Completed folder: ${folder} (${result.manifest.length} files)`);\n      } catch (error) {\n        console.error(`‚ùå Error processing folder ${folder}:`, error);\n        totalErrors++;\n      }\n    });\n\n    return { manifest: sortManifest(globalManifest), processedCount: totalProcessed, errorCount: totalErrors };\n  }\n\n  async function loadPreviousManifest(): Promise<MarkdownMeta[]> {\n    try {\n      const file = getAssetPath(`${prefix}-manifest.json`);\n      if (!existsSync(file)) return [];\n\n      const globalManifest = JSON.parse(await readFile(file, 'utf8')) as GlobalManifest;\n      return globalManifest.documents || [];\n    } catch {\n      return [];\n    }\n  }\n\n  // Helper to write compressed versions of JSON files\n  async function writeCompressedVersions(filename: string, content: string) {\n    if (!compress) {\n      return;\n    }\n\n    try {\n      const buffer = Buffer.from(content, 'utf8');\n      const compressedBuffer = await gzipAsync(buffer);\n      const compressedPath = getAssetPath(`${filename}.gz`);\n      await writeFile(compressedPath, compressedBuffer);\n\n      const ratio = ((1 - compressedBuffer.length / content.length) * 100).toFixed(1);\n      console.info(`  üì¶ ${filename}.gz: ${compressedBuffer.length} bytes compressed ${ratio}%`);\n    } catch (error) {\n      console.warn(`Failed to write compressed version of ${filename}:`, error);\n    }\n  }\n\n  // Function to write JSON files with optional compression\n  async function writeMarkdownFiles(manifest: MarkdownMeta[], content: Record<string, any>, chunkedFolders?: string[]) {\n    try {\n      const dir = path.dirname(getAssetPath('dummy'));\n      await mkdir(dir, { recursive: true });\n\n      // Create global manifest with chunking metadata\n      const globalManifest: GlobalManifest = {\n        documents: manifest,\n        _buildMode: chunkByFolder ? 'chunked' : 'single',\n        ...(chunkByFolder && chunkedFolders && { chunkedFolders }),\n      };\n\n      // Write manifest (always uncompressed - small file, frequently accessed)\n      const manifestContent = JSON.stringify(globalManifest, null, 2);\n      await writeFile(getAssetPath(`${prefix}-manifest.json`), manifestContent);\n\n      // Write content if not chunked\n      if (!chunkByFolder && Object.keys(content).length > 0) {\n        const contentJson = JSON.stringify(content, null, 2);\n\n        if (compress) {\n          // Only write compressed version for content files\n          await writeCompressedVersions(`${prefix}-content.json`, contentJson);\n        } else {\n          // Write uncompressed version if compression is disabled\n          await writeFile(getAssetPath(`${prefix}-content.json`), contentJson);\n        }\n      }\n    } catch (e) {\n      console.error('‚ùå Failed to write markdown JSON files:', e);\n    }\n  }\n\n  async function writeFolderFiles(folder: string, _manifest: MarkdownMeta[], content: FolderContentChunk) {\n    try {\n      const dir = path.dirname(getAssetPath('dummy'));\n      await mkdir(dir, { recursive: true });\n\n      const folderKey = folder.replace(/[/\\\\]/g, '-');\n      const filename = `${prefix}-content-${folderKey}.json`;\n\n      // Write folder content chunk only - manifest contains all metadata\n      const contentJson = JSON.stringify(content, null, 2);\n\n      if (compress) {\n        // Only write compressed version for content files\n        await writeCompressedVersions(filename, contentJson);\n      } else {\n        // Write uncompressed version if compression is disabled\n        await writeFile(getAssetPath(filename), contentJson);\n      }\n    } catch (e) {\n      console.error(`‚ùå Failed to write folder files for ${folder}:`, e);\n    }\n  }\n\n  return {\n    name: 'markdown-builder',\n    async buildStart() {\n      const docsDir = path.join(process.cwd(), source);\n\n      // Check if source directory exists, skip if not\n      try {\n        await stat(docsDir);\n      } catch {\n        console.info(`üìÑ Source directory '${source}' does not exist, skipping markdown build`);\n        return;\n      }\n\n      if (chunkByFolder) {\n        const { changedFolders, allFolders } = await checkForFolderChanges(docsDir);\n\n        if (changedFolders.size === 0) {\n          console.info('üìÑ No folder changes detected, skipping build');\n          return;\n        }\n\n        console.info(`üìÇ Processing ${changedFolders.size} changed folders out of ${allFolders.size} total`);\n        const result = await processChangedFolders(changedFolders, allFolders);\n        const folderList = Array.from(allFolders.keys());\n        await writeMarkdownFiles(result.manifest, {}, folderList);\n        console.info(`  üìÑ Processed ${result.processedCount} files with ${result.errorCount} errors`);\n      } else {\n        const prev = await loadPreviousManifest();\n        const { changed, updatedFiles } = await checkForChanges(docsDir, prev);\n        if (!changed) return;\n        const result = await processChangedFiles(updatedFiles);\n        await writeMarkdownFiles(result.manifest, result.content);\n        console.info(`  üìÑ Processing ${updatedFiles.size} updated markdown files from: ${source}`);\n      }\n    },\n    async handleHotUpdate({ file, server }) {\n      if (file.includes(source) && file.endsWith(extension)) {\n        const docsDir = path.join(process.cwd(), source);\n\n        if (chunkByFolder) {\n          // Determine which folder changed and only rebuild that folder\n          const relativePath = path.relative(path.join(process.cwd(), source), file);\n          const folder = path.dirname(relativePath) === '.' ? 'root' : path.dirname(relativePath);\n\n          const allFolders = await collectFilesByFolder(docsDir);\n          const changedFolders = new Set([folder]);\n\n          const result = await processChangedFolders(changedFolders, allFolders);\n\n          // Update global manifest\n          const globalManifest = await loadPreviousManifest();\n          const updatedManifest = globalManifest.filter(item => item.folder !== folder);\n          updatedManifest.push(...result.manifest);\n\n          const allFoldersForHotReload = await collectFilesByFolder(docsDir);\n          const folderList = Array.from(allFoldersForHotReload.keys());\n          await writeMarkdownFiles(sortManifest(updatedManifest), {}, folderList);\n          console.info(`üîÑ Hot updated folder: ${folder}`);\n        } else {\n          const files = await collectMarkdownFilesWithMetadata(docsDir);\n          const result = await processChangedFiles(files);\n          await writeMarkdownFiles(result.manifest, result.content);\n        }\n\n        server.ws.send({ type: 'full-reload' });\n      }\n    },\n  };\n}\n\n// Simple frontmatter parser (no dependencies)\nfunction parseFrontmatter(content: string) {\n  const match = content.match(/^---\\s*\\n(.*?)\\n---\\s*\\n(.*)$/s);\n  if (!match) {\n    return { data: {}, content };\n  }\n\n  const [, frontmatterText, markdown] = match;\n  const frontmatter: Frontmatter = {};\n\n  if (!frontmatterText) return frontmatter;\n\n  // Simple YAML parser for basic key-value pairs\n  const lines = frontmatterText.split('\\n').filter(line => line.trim());\n  for (const line of lines) {\n    const colonIndex = line.indexOf(':');\n    if (colonIndex > 0) {\n      const key = line.substring(0, colonIndex).trim();\n      const value = line.substring(colonIndex + 1).trim();\n\n      // Remove quotes if present\n      const cleanValue = value.replace(/^['\"]|['\"]$/g, '');\n\n      // Try to parse as date\n      if (key === 'date' && cleanValue.match(/^\\d{4}-\\d{2}-\\d{2}$/)) {\n        frontmatter[key] = new Date(cleanValue).toISOString().split('T')[0];\n      } else {\n        frontmatter[key] = cleanValue;\n      }\n    }\n  }\n\n  return { data: frontmatter, content: markdown };\n}\n\nasync function processMarkdownFile(filePath: string, purifyHtml = true, highlighter?: SyntaxHighlighter | null): Promise<{ content: string; error?: string; errorContext?: string }> {\n  try {\n    const source = await readFile(filePath, 'utf8');\n    const { content: markdown } = parseFrontmatter(source);\n    const markdownString = typeof markdown === 'string' ? markdown : String(markdown || '');\n    const htmlContent = marked.parse(markdownString, { breaks: true, gfm: true });\n\n    if (typeof htmlContent !== 'string') {\n      return { content: markdownString, error: `Unexpected marked result type: ${typeof htmlContent}` };\n    }\n\n    const sanitizedContent = purifyHtml ? DOMPurify.sanitize(htmlContent, DOMPURIFY_CONFIG) : htmlContent;\n    const result = highlighter ? await highlightCodeBlocks(htmlContent, highlighter, filePath) : { content: sanitizedContent };\n\n    if ('error' in result) {\n      return { content: '', error: result.error, errorContext: result.errorContext };\n    }\n\n    return { content: result.content };\n  } catch (error) {\n    return {\n      content: '',\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\nfunction sortManifest(manifest: MarkdownMeta[]): MarkdownMeta[] {\n  return manifest.sort((a, b) => {\n    // Sort by folder first\n    const folderA = a.folder || '';\n    const folderB = b.folder || '';\n\n    if (folderA !== folderB) {\n      return folderA.localeCompare(folderB);\n    }\n\n    // Within same folder, sort by date (newest first)\n    if (a.date && b.date) {\n      return new Date(b.date).getTime() - new Date(a.date).getTime();\n    }\n\n    // Then by title\n    if (a.title && b.title) {\n      return a.title.localeCompare(b.title);\n    }\n\n    // Finally by slug to ensure deterministic ordering\n    return a.slug.localeCompare(b.slug);\n  });\n}\n\n// Create default Shiki highlighter\nasync function createShikiHighlighter(config: ShikiConfig = {}): Promise<SyntaxHighlighter> {\n  const { langs = [...HIGHLIGHTER_CONFIG.LANGS], themes = [...HIGHLIGHTER_CONFIG.THEMES] } = config;\n  const highlighter = await createHighlighter({ langs, themes });\n\n  return {\n    highlight: (code: string, language: string) => {\n      try {\n        const html = highlighter.codeToHtml(code, { lang: language, theme: 'night-owl', colorReplacements: { '#011627': '#1f2937' } });\n        // Add mobile-responsive classes to the generated pre element\n        return html.replace(/<pre[^>]*>/, '<pre class=\"overflow-x-auto text-xs md:text-sm\" style=\"background-color: #1f2937 !important;\">');\n      } catch (error) {\n        // Provide helpful error message for missing languages\n        if (error instanceof Error && error.message.includes('not found')) {\n          throw new Error(`Language \\`${language}\\` not found in Shiki highlighter`);\n        }\n        throw error;\n      }\n    },\n  };\n}\n\nasync function highlightCodeBlocks(htmlContent: string, highlighter: SyntaxHighlighter, filePath?: string): Promise<{ content: string } | { error: string; errorContext?: string }> {\n  // Regular expression to find code blocks: <pre><code class=\"language-xxx\">content</code></pre>\n  const codeBlockRegex = /<pre><code(?:\\s+class=\"language-([^\"]*)\")?>([\\s\\S]*?)<\\/code><\\/pre>/g;\n\n  let processedContent = htmlContent;\n  const matches = [...htmlContent.matchAll(codeBlockRegex)];\n\n  for (const match of matches) {\n    const [fullMatch, language, codeContent] = match;\n\n    if (!codeContent) continue;\n\n    // Decode HTML entities in the code content\n    const decodedContent = codeContent\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&amp;/g, '&')\n      .replace(/&quot;/g, '\"')\n      .replace(/&#39;/g, \"'\");\n\n    try {\n      const highlightedContent = await highlighter.highlight(decodedContent, language || 'text');\n      processedContent = processedContent.replace(fullMatch, highlightedContent);\n    } catch (error) {\n      // Extract a snippet of the code for context (first 100 chars)\n      const codeSnippet = decodedContent.substring(0, 100).replace(/\\n/g, '\\\\n');\n      const errorContext = `Language: \\`${language || 'text'}\\`\\n  Code snippet: \"${codeSnippet}${decodedContent.length > 100 ? '...' : ''}\"`;\n\n      console.error(`\\n‚ùå Markdown Processing Error:`);\n      console.error(`  File: ${filePath || 'unknown'}`);\n      console.error(`  ${errorContext}`);\n      console.error(`  Error: ${error instanceof Error ? error.message : String(error)}`);\n      console.error(`\\n  üí° Solution: Add '${language}' to HIGHLIGHTER_CONFIG.LANGS in markdown-config.ts\\n`);\n\n      // Return error with context instead of continuing\n      return {\n        error: `Failed to highlight code block with language \"${language}\"`,\n        errorContext,\n      };\n    }\n  }\n\n  return { content: processedContent };\n}\n\nasync function execConcurrently<T>(items: T[], limit: number, handler: (item: T) => Promise<void>): Promise<void> {\n  const executing: Promise<void>[] = [];\n\n  for (const item of items) {\n    const p = handler(item);\n    executing.push(p);\n\n    if (executing.length >= limit) {\n      await Promise.race(executing).catch(() => {});\n      for (let i = executing.length - 1; i >= 0; i--) {\n        try {\n          await executing[i];\n          executing.splice(i, 1);\n        } catch {\n          executing.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  await Promise.allSettled(executing);\n}\n",
    "// Central configuration for all markdown defaults and asset paths\nexport const MARKDOWN_CONFIG = {\n  EXTENSION: '.md',\n  CHUNK_BY_FOLDER: true,\n  INCREMENTAL_BY_FOLDER: false,\n  PREFIX: 'markdown',\n  PURIFY_HTML: true,\n  UPDATE_DATE: true,\n  COMPRESS: true,\n  CONCURRENCY: {\n    FOLDERS: 5,\n    FILES: 10,\n  },\n  CACHE: {\n    MAX_AGE: 3600, // 1 hour default\n  },\n} as const;\n\n// Central configuration for asset prefixes - change these to modify where markdown assets are stored/fetched\nexport const ASSET_PREFIX = {\n  build: '/assets/docs', // Where assets are written during build (relative to /public)\n  fetch: '/assets/docs', // URL prefix for fetching assets at runtime\n} as const;\n\nexport const ASSET_ROUTES = {\n  docs: (slug: string) => `/forge/docs/${slug}`,\n  docsApi: (slug: string) => `/forge/docs/${slug}?api`,\n};\n\n// DOMPurify configuration for markdown content\nexport const DOMPURIFY_CONFIG = {\n  ALLOWED_TAGS: [\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'p',\n    'br',\n    'strong',\n    'em',\n    'u',\n    's',\n    'del',\n    'a',\n    'img',\n    'ul',\n    'ol',\n    'li',\n    'blockquote',\n    'pre',\n    'code',\n    'table',\n    'thead',\n    'tbody',\n    'tr',\n    'th',\n    'td',\n    'hr',\n    'div',\n    'span',\n  ] as string[],\n  ALLOWED_ATTR: ['href', 'title', 'alt', 'src', 'class', 'id', 'start', 'type', 'colspan', 'rowspan', 'datetime', 'scope', 'data-*'] as string[],\n  FORBID_TAGS: ['script', 'object', 'embed', 'form', 'input', 'button', 'iframe', 'frame', 'frameset', 'noframes'] as string[],\n  FORBID_ATTR: ['style', 'on*'] as string[],\n  KEEP_CONTENT: true,\n  ALLOW_DATA_ATTR: false,\n};\n\n// Shiki highlighter configuration\nexport const HIGHLIGHTER_CONFIG = {\n  LANGS: ['bash', 'css', 'html', 'javascript', 'json', 'markdown', 'sql', 'text', 'ts', 'tsx', 'typescript', 'xml', 'yaml'] as string[],\n  THEMES: ['night-owl'] as string[],\n};\n",
    "import path from 'node:path';\nimport { ASSET_PREFIX } from '../markdown-config';\n\n/**\n * Get the full asset path for files during build time\n * @param filename - The filename to get the path for\n * @param prefix - Optional alternate prefix to use instead of default\n * @returns Full path where the file should be written during build\n */\nexport function getAssetPath(filename: string, prefix?: string): string {\n  // Use provided prefix or fall back to default build prefix\n  const buildPrefix = prefix || ASSET_PREFIX.build;\n  // Normalize the build prefix to handle leading slashes\n  const normalizedPrefix = buildPrefix.startsWith('/') ? buildPrefix.slice(1) : buildPrefix;\n  return path.join(process.cwd(), 'public', normalizedPrefix, filename);\n}\n"
  ],
  "mappings": "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",
  "debugId": "CE5291F22A26A22464756E2164756E21",
  "names": []
}