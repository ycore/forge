{
  "version": 3,
  "sources": ["../../src/logger/channels/kv-channel.ts", "../../src/logger/logger.config.ts", "../../src/logger/channels/console-channel.ts", "../../src/logger/channels/registry.ts", "../../src/logger/logger.helpers.ts", "../../src/logger/logger.ts"],
  "sourcesContent": [
    "import { nanoid } from 'nanoid';\nimport type { KVLogChannelConfig, LogChannel, LogEntry, LogMetadata } from '../@types/logger.types';\n\n/** Type guard to check if metadata is valid LogMetadata */\nconst isLogMetadata = (metadata: unknown): metadata is LogMetadata => {\n  return typeof metadata === 'object' && metadata !== null && 'timestamp' in metadata && 'level' in metadata && typeof metadata.timestamp === 'string' && typeof metadata.level === 'string';\n};\n\n/** Type guard to validate parsed log entry */\nconst isLogEntry = (data: unknown): data is LogEntry => {\n  return typeof data === 'object' && data !== null && 'event' in data && 'level' in data && 'timestamp' in data && typeof data.event === 'string' && typeof data.level === 'string' && typeof data.timestamp === 'string';\n};\n\nconst logEntryKvTemplate = (prefix: string, timestamp: number, workerId: string, uniqueId: string, attemptSuffix: string): string => `${prefix}${timestamp}-${workerId}-${uniqueId}${attemptSuffix}`;\n\n/**\n * Creates a KV-based log channel for Cloudflare Workers\n * Maintains logs with batched cleanup on threshold trigger\n * Enhanced uniqueness strategy with exponential backoff for race condition mitigation\n */\nexport function createKVLogChannel(config: KVLogChannelConfig, minLevel: LogEntry['level'] = 'info'): LogChannel {\n  const { kv, logsLimit = 500, logsTrigger = 1000, keyPrefix = 'log:' } = config;\n\n  // Worker-unique identifier to prevent cross-worker collisions\n  const workerId = nanoid(6);\n\n  return {\n    name: 'kv-storage',\n    minLevel,\n    enabled: true,\n    output: async (entry: LogEntry) => {\n      const storeLogWithRetry = async (maxAttempts = 3): Promise<boolean> => {\n        for (let attempt = 0; attempt < maxAttempts; attempt++) {\n          try {\n            // High-precision timestamp (microseconds) + worker ID + nanoid = collision-resistant\n            // Combines millisecond timestamp with microsecond precision from performance.now()\n            const timestamp = Date.now() * 1000 + Math.floor((performance.now() % 1) * 1000);\n            const uniqueId = nanoid(8); // 8 characters for compact yet collision-resistant IDs\n            const attemptSuffix = attempt > 0 ? `-r${attempt}` : '';\n            const logKey = logEntryKvTemplate(keyPrefix, timestamp, workerId, uniqueId, attemptSuffix);\n\n            // Store log entry with metadata\n            await kv.put(logKey, JSON.stringify(entry), {\n              metadata: {\n                timestamp: entry.timestamp,\n                level: entry.level,\n              },\n            });\n\n            return true;\n          } catch (_error) {\n            // Exponential backoff with jitter on failure (5ms base, doubles each attempt)\n            if (attempt < maxAttempts - 1) {\n              const backoff = 2 ** attempt * 5 + Math.random() * 5;\n              await new Promise(resolve => setTimeout(resolve, backoff));\n            }\n          }\n        }\n        return false;\n      };\n\n      try {\n        // Attempt to store log with exponential backoff retry strategy\n        await storeLogWithRetry();\n\n        // Check cleanup every ~50 logs using random sampling - ~1 in 50 logs\n        // Silently ignore cleanup failures to prevent cascading errors\n        if (Math.random() < 0.02) cleanupOldLogsIfNeeded(kv, logsLimit, logsTrigger, keyPrefix).catch(() => {});\n      } catch (_error) {\n        // Graceful degradation - Avoid logging the error details to prevent potential infinite loops\n      }\n    },\n  };\n}\n\n/**\n * Batch delete operations with size limits to avoid KV rate limits\n */\nasync function batchDeleteKeys(kv: KVNamespace, keys: string[], batchSize = 100): Promise<void> {\n  for (let i = 0; i < keys.length; i += batchSize) {\n    const batch = keys.slice(i, i + batchSize);\n    const deletePromises = batch.map(key => kv.delete(key));\n    await Promise.all(deletePromises);\n  }\n}\n\n/**\n * Check if cleanup is needed and trigger if threshold exceeded\n */\nasync function cleanupOldLogsIfNeeded(kv: KVNamespace, logsLimit: number, logsTrigger: number, keyPrefix: string): Promise<void> {\n  try {\n    // List with limit to see if trigger has been exceeded\n    const listResult = await kv.list({ prefix: keyPrefix, limit: logsTrigger + 1 });\n\n    if (listResult.keys.length <= logsTrigger) return;\n\n    // Crossed the trigger threshold, perform cleanup\n    await cleanupOldLogs(kv, logsLimit, keyPrefix);\n  } catch (_error) {} // Silently fail - cleanup is not critical\n}\n\n/**\n * Cleanup old logs keeping only the most recent logsLimit entries\n */\nasync function cleanupOldLogs(kv: KVNamespace, logsLimit: number, keyPrefix: string): Promise<void> {\n  try {\n    // List all log keys\n    const listResult = await kv.list({ prefix: keyPrefix });\n\n    if (listResult.keys.length <= logsLimit) {\n      return; // No cleanup needed\n    }\n\n    // Filter and transform keys with valid metadata into a typed structure\n    const validKeys = listResult.keys\n      .filter((key): key is typeof key & { metadata: LogMetadata } => isLogMetadata(key.metadata))\n      .map(key => ({\n        name: key.name,\n        timestamp: new Date(key.metadata.timestamp).getTime(),\n      }))\n      .sort((a, b) => a.timestamp - b.timestamp); // Oldest first\n\n    // Delete excess logs (keep only logsLimit number of logs)\n    const keysToDelete = validKeys.slice(0, Math.max(0, validKeys.length - logsLimit)).map(key => key.name);\n\n    // Batch delete operations to respect KV rate limits\n    if (keysToDelete.length > 0) {\n      await batchDeleteKeys(kv, keysToDelete);\n    }\n  } catch (_error) {\n    // Silently fail - cleanup failures shouldn't impact logging\n  }\n}\n\n/**\n * Retrieves logs from KV storage\n */\nexport async function getLogsFromKV(kv: KVNamespace, options: { limit?: number; keyPrefix?: string } = {}): Promise<LogEntry[]> {\n  const { limit = 100, keyPrefix = 'log:' } = options;\n\n  try {\n    // List all log keys\n    const listResult = await kv.list({ prefix: keyPrefix });\n\n    if (listResult.keys.length === 0) {\n      return [];\n    }\n\n    // Filter, sort, and limit keys with valid metadata\n    const sortedKeys = listResult.keys\n      .filter((key): key is typeof key & { metadata: LogMetadata } => isLogMetadata(key.metadata))\n      .sort((a, b) => {\n        const timestampA = new Date(a.metadata.timestamp).getTime();\n        const timestampB = new Date(b.metadata.timestamp).getTime();\n        return timestampB - timestampA; // Newest first\n      })\n      .slice(0, limit);\n\n    // Fetch and parse log entries\n    const logPromises = sortedKeys.map(async key => {\n      const logData = await kv.get(key.name);\n      if (!logData) return null;\n\n      try {\n        const parsed = JSON.parse(logData);\n        return isLogEntry(parsed) ? parsed : null;\n      } catch {\n        return null;\n      }\n    });\n\n    const logs = await Promise.all(logPromises);\n    return logs.filter((log): log is LogEntry => log !== null);\n  } catch (error) {\n    console.error('Failed to retrieve logs from KV:', error);\n    return [];\n  }\n}\n\n/**\n * Clears all logs from KV storage\n */\nexport async function clearLogsFromKV(kv: KVNamespace, options: { keyPrefix?: string } = {}): Promise<void> {\n  const { keyPrefix = 'log:' } = options;\n\n  try {\n    // List all log keys\n    const listResult = await kv.list({ prefix: keyPrefix });\n\n    // Delete all log entries using batching\n    const keysToDelete = listResult.keys.map(key => key.name);\n    await batchDeleteKeys(kv, keysToDelete);\n  } catch (error) {\n    console.error('Failed to clear logs from KV:', error);\n    throw error;\n  }\n}\n",
    "import type { LoggerConfig, LogLevel } from './@types/logger.types';\n\n// RFC 5424 log level hierarchy (higher number = higher severity)\nexport const LOG_LEVELS: Record<LogLevel, number> = {\n  emergency: 7,\n  alert: 6,\n  critical: 5,\n  error: 4,\n  warning: 3,\n  notice: 2,\n  info: 1,\n  debug: 0,\n} as const;\n\n/**\n * Check if a log level should be logged based on minimum level threshold\n */\nexport function shouldLog(level: LogLevel, minLevel: LogLevel): boolean {\n  return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];\n}\n\n/**\n * Get environment-specific channel options\n */\nexport function getChannelOptions(registry: 'console' | 'kv', production: boolean, baseOptions: Record<string, unknown> = {}, kv?: KVNamespace): Record<string, unknown> {\n  // Console channel environment-specific defaults\n  if (registry === 'console') {\n    const envDefaults = {\n      format: production ? 'raw' : 'json',\n      useLogLevelMethods: !production,\n    };\n    // Explicit options override environment defaults\n    return { ...envDefaults, ...baseOptions };\n  }\n\n  let options = { ...baseOptions };\n\n  // KV channel - inject KV namespace\n  if (registry === 'kv' && kv) {\n    options = { ...options, kv };\n  }\n\n  return options;\n}\n\n/**\n * Get environment-specific logger defaults\n */\nexport function getLoggerDefaults(config: LoggerConfig, production: boolean): { defaultLevel: LogLevel; enableSanitization: boolean } {\n  const defaults = production ? config.defaults?.production : config.defaults?.development;\n\n  return {\n    defaultLevel: defaults?.defaultLevel || (production ? 'warning' : 'info'),\n    enableSanitization: defaults?.enableSanitization ?? true,\n  };\n}\n\n/**\n * Default logger configuration\n */\nexport const defaultLoggerConfig: LoggerConfig = {\n  init: [\n    {\n      production: false,\n      channel: 'console',\n      level: 'debug',\n    },\n    {\n      production: false,\n      channel: 'console',\n      level: 'warning',\n    },\n    {\n      production: false,\n      channel: 'kv',\n      level: 'info',\n    },\n    {\n      production: true,\n      channel: 'kv',\n      level: 'warning',\n    },\n  ],\n  channels: {\n    console: {\n      registry: 'console',\n      options: {}, // Will be populated with environment defaults\n    },\n    kv: {\n      registry: 'kv',\n      options: {\n        logsLimit: 500,\n        logsTrigger: 750,\n      },\n    },\n  },\n  defaults: {\n    development: {\n      defaultLevel: 'debug',\n      enableSanitization: true,\n    },\n    production: {\n      defaultLevel: 'warning',\n      enableSanitization: true,\n    },\n  },\n};\n",
    "import type { ConsoleChannelConfig, ConsoleOutputFormat, LogChannel, LogEntry, LogLevel } from '../@types/logger.types';\n\n/**\n * Console channel with environment-appropriate formatting\n * Outputs structured logs to the browser/Node.js console\n */\nconst formatters: Record<ConsoleOutputFormat, (entry: LogEntry) => string> = {\n  json: (entry: LogEntry) => JSON.stringify(entry, null, 2),\n  compact: (entry: LogEntry) => {\n    const parts = [entry.level.toUpperCase(), entry.event || 'LOG', entry.timestamp];\n\n    if (entry.args && Array.isArray(entry.args) && entry.args.length > 0) {\n      parts.push(...entry.args.map(arg => (typeof arg === 'string' ? arg : JSON.stringify(arg))));\n    }\n\n    // Add any additional properties (excluding the ones already handled)\n    // biome-ignore lint/correctness/noUnusedVariables: extracting unused props\n    const { level, event, timestamp, args, ...rest } = entry;\n    if (Object.keys(rest).length > 0) {\n      parts.push(...Object.values(rest).map(val => (typeof val === 'string' ? val : JSON.stringify(val))));\n    }\n\n    return `[ ${parts.join(' || ')} ]`;\n  },\n  raw: (entry: LogEntry) => JSON.stringify(entry),\n};\n\nfunction formatLogEntry(entry: LogEntry, format: ConsoleOutputFormat): string {\n  return formatters[format](entry);\n}\n\nconst consoleMethods: Record<LogLevel, (message: string) => void> = {\n  emergency: console.error,\n  alert: console.error,\n  critical: console.error,\n  error: console.error,\n  warning: console.warn,\n  notice: console.info,\n  info: console.info,\n  debug: console.debug,\n};\n\nexport function createConsoleChannel(minLevel: LogLevel, config: ConsoleChannelConfig = {}): LogChannel {\n  const { format = 'raw', useLogLevelMethods = false } = config;\n\n  return {\n    name: 'console',\n    minLevel,\n    enabled: true,\n    output: (entry: LogEntry) => {\n      const output = formatLogEntry(entry, format);\n\n      if (useLogLevelMethods) {\n        consoleMethods[entry.level](output);\n      } else {\n        console.info(output);\n      }\n    },\n  };\n}\n",
    "import type { ConsoleChannelConfig, KVLogChannelConfig, LogLevel } from '../@types/logger.types';\nimport type { ConsoleChannelFactory, KVChannelFactory } from '../@types/registry.types';\nimport { createConsoleChannel } from './console-channel';\nimport { createKVLogChannel } from './kv-channel';\n\n/**\n * Registry of available channel factories\n */\nexport const ChannelRegistry: { console: ConsoleChannelFactory; kv: KVChannelFactory } = {\n  console: (minLevel: LogLevel, config?: ConsoleChannelConfig) => createConsoleChannel(minLevel, config),\n  kv: (minLevel: LogLevel, config: KVLogChannelConfig) => createKVLogChannel(config, minLevel),\n};\n",
    "import type { ChannelInitConfig, ConsoleChannelConfig, InternalLoggerConfig, KVLogChannelConfig, LoggerConfig, LogLevel } from './@types/logger.types';\nimport { ChannelRegistry } from './channels/registry';\nimport { getChannelOptions, getLoggerDefaults } from './logger.config';\n\n/**\n * Create internal logger configuration from declarative config\n */\nexport function createInternalLoggerConfig(config: LoggerConfig, production: boolean, kv?: KVNamespace): InternalLoggerConfig {\n  // Filter init configs for current environment\n  const relevantInits = config.init.filter((init: ChannelInitConfig) => init.production === production && init.level !== 'null');\n\n  // Create channels based on filtered init configs\n  const channels = relevantInits.map(init => {\n    const channelDef = config.channels[init.channel];\n    if (!channelDef) {\n      throw new Error(`Channel definition not found for: ${init.channel}`);\n    }\n\n    // Get environment-appropriate options using config logic\n    const options = getChannelOptions(channelDef.registry, production, channelDef.options as Record<string, unknown>, kv);\n\n    // Map-based channel factory lookup\n    const channelFactories = {\n      console: () => ChannelRegistry.console(init.level as LogLevel, options as ConsoleChannelConfig),\n      kv: () => {\n        if (!options.kv) {\n          throw new Error('KV namespace is required for KV channel');\n        }\n        return ChannelRegistry.kv(init.level as LogLevel, options as unknown as KVLogChannelConfig);\n      },\n    } as const;\n\n    const createChannel = channelFactories[channelDef.registry as keyof typeof channelFactories];\n    if (!createChannel) {\n      throw new Error(`Unsupported registry type: ${channelDef.registry}`);\n    }\n\n    return createChannel();\n  });\n\n  // Get environment defaults from config\n  const { defaultLevel, enableSanitization } = getLoggerDefaults(config, production);\n\n  return { defaultLevel, channels, enableSanitization };\n}\n",
    "/** biome-ignore-all lint/suspicious/noExplicitAny: acceptable */\nimport type { BaseLogParams, InternalLoggerConfig, LogArgs, LogEntry, Logger, LoggerConfig, LogLevel, LogParams } from './@types/logger.types';\nimport { shouldLog } from './logger.config';\nimport { createInternalLoggerConfig } from './logger.helpers';\n\nexport interface LoggerState {\n  initialized: boolean;\n  wasInitializedHere?: boolean;\n}\n\n// Global logger configuration\nlet loggerConfig: InternalLoggerConfig = {\n  defaultLevel: 'info',\n  channels: [],\n  enableSanitization: true,\n};\n\n/**\n * Sanitizes log parameters by removing sensitive fields\n */\nfunction sanitizeLogParams(params: LogParams): LogParams {\n  if (!loggerConfig.enableSanitization) {\n    return params;\n  }\n\n  // biome-ignore lint/correctness/noUnusedVariables: intentional\n  const { password, token, secret, apiKey, sessionToken, bearerToken, refreshToken, ...sanitized } = params as LogParams & {\n    password?: unknown;\n    token?: unknown;\n    secret?: unknown;\n    apiKey?: unknown;\n    sessionToken?: unknown;\n    bearerToken?: unknown;\n    refreshToken?: unknown;\n  };\n  return sanitized;\n}\n\n/**\n * Formats log arguments similar to diary's approach\n */\nfunction formatLogArgs(args: LogArgs): BaseLogParams {\n  const [message, ...rest] = args;\n\n  if (typeof message === 'object' && message !== null) {\n    return { ...message, ...(rest.length > 0 ? { args: rest } : {}) } as BaseLogParams;\n  }\n\n  return { event: String(message), ...(rest.length > 0 ? { args: rest } : {}) } as BaseLogParams;\n}\n\n/**\n * Creates a structured log entry\n */\nfunction createLogEntry(params: LogParams): LogEntry {\n  const sanitizedParams = sanitizeLogParams(params);\n  return {\n    ...sanitizedParams,\n    level: (sanitizedParams.level || loggerConfig.defaultLevel) as LogLevel,\n    timestamp: new Date().toISOString(),\n  } as LogEntry;\n}\n\n/**\n * Writes log entry to all enabled channels that meet the level threshold\n * Logging failures are silently ignored to prevent disrupting application flow\n */\nasync function writeToChannels(entry: LogEntry): Promise<void> {\n  const writePromises = loggerConfig.channels\n    .filter(channel => channel.enabled && shouldLog(entry.level, channel.minLevel))\n    .map(channel => {\n      try {\n        const result = channel.output(entry);\n        return result instanceof Promise ? result : Promise.resolve();\n      } catch (_error) {\n        // Silently ignore logging failures to prevent disrupting application flow\n        return Promise.resolve();\n      }\n    });\n\n  await Promise.allSettled(writePromises);\n}\n\n// Production optimizations are handled by the Vite logger plugin\n// These runtime checks will be replaced with static values during build\n\n/**\n * Enhanced Structured Logging Utility with Multi-Channel Support\n *\n * Features:\n * - RFC 5424 log levels with proper hierarchy\n * - Multi-channel output (console, webhooks, Slack, etc.)\n * - Environment-specific configuration\n * - Flexible API supporting both structured objects and diary-style strings\n * - Security sanitization for sensitive data\n * - Production build optimization with dead code elimination\n * - Optimized for Cloudflare Workers deployment\n * - **Error-safe**: Never throws or contributes to error flow - logging failures are silently ignored\n *\n * Usage patterns:\n * - Critical logging: `await logger.error(...)` - ensures completion\n * - Non-critical logging: `logger.debug(...)` - fire-and-forget\n * - All methods return Promise<void> but never throw or reject\n *\n * @see {@link https://developers.cloudflare.com/workers/observability/logs/workers-logs/}\n * @see {@link https://tools.ietf.org/html/rfc5424}\n */\nexport const logger: Logger = {\n  /**\n   * Configure the logger with custom settings\n   */\n  configure(config: Partial<InternalLoggerConfig>) {\n    loggerConfig = { ...loggerConfig, ...config };\n  },\n\n  /**\n   * Get current logger configuration\n   */\n  getConfig(): InternalLoggerConfig {\n    return { ...loggerConfig };\n  },\n\n  /**\n   * Core logging method that writes to all enabled channels\n   */\n  async log(params: LogParams): Promise<void> {\n    const entry = createLogEntry(params);\n    await writeToChannels(entry);\n  },\n\n  /**\n   * Genarates a support number\n   */\n  async support(): Promise<string> {\n    return crypto.randomUUID();\n  },\n  // RFC 5424 log levels in descending order of severity\n\n  /**\n   * System is unusable - emergency level\n   */\n  emergency(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'emergency' });\n  },\n\n  /**\n   * Action must be taken immediately - alert level\n   */\n  alert(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'alert' });\n  },\n\n  /**\n   * Critical conditions - critical level\n   */\n  critical(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'critical' });\n  },\n\n  /**\n   * Error conditions - error level\n   */\n  error(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'error' });\n  },\n\n  /**\n   * Warning conditions - warning level\n   */\n  warning(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'warning' });\n  },\n\n  /**\n   * Normal but significant conditions - notice level\n   */\n  notice(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'notice' });\n  },\n\n  /**\n   * Informational messages - info level\n   */\n  info(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'info' });\n  },\n\n  /**\n   * Debug-level messages - debug level\n   */\n  debug(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'debug' });\n  },\n};\n\n// Track initialization state\nlet isLoggerInitialized = false;\n\n/**\n * Logger initialization options\n */\nexport interface InitLoggerOptions {\n  config: LoggerConfig;\n  store: KVNamespace;\n  production: boolean;\n  startupCallback?: () => Promise<void>;\n}\n\n/**\n * Initialize logger with named options\n * Returns a boolean indicating whether initialization actually occurred (true) or was already done (false)\n * Handles race conditions internally - safe to call multiple times\n */\nexport async function initLogger(options: InitLoggerOptions): Promise<boolean> {\n  if (isLoggerInitialized) {\n    return false;\n  }\n\n  // Default to production for safety\n  const { config, store, production = true, startupCallback } = options;\n\n  // Create internal logger config from declarative config\n  const finalConfig = createInternalLoggerConfig(config, production, store);\n\n  logger.configure(finalConfig);\n  isLoggerInitialized = true;\n\n  // Execute optional startup logging callback\n  if (startupCallback) {\n    await startupCallback();\n  }\n\n  return true; // Initialization completed\n}\n\n/**\n * Check if logger has been initialized\n */\nexport function isInitialized(): boolean {\n  return isLoggerInitialized;\n}\n\n/**\n * Require logger to be initialized, throws if not\n */\nexport function requireInitialized(): void {\n  if (!isLoggerInitialized) {\n    throw new Error('Logger must be initialized before use. Call initLogger() in entry.worker.ts first.');\n  }\n}\n"
  ],
  "mappings": ";AAAA;AAIA,IAAM,gBAAgB,CAAC,aAA+C;AAAA,EACpE,OAAO,OAAO,aAAa,YAAY,aAAa,QAAQ,eAAe,YAAY,WAAW,YAAY,OAAO,SAAS,cAAc,YAAY,OAAO,SAAS,UAAU;AAAA;AAIpL,IAAM,aAAa,CAAC,SAAoC;AAAA,EACtD,OAAO,OAAO,SAAS,YAAY,SAAS,QAAQ,WAAW,QAAQ,WAAW,QAAQ,eAAe,QAAQ,OAAO,KAAK,UAAU,YAAY,OAAO,KAAK,UAAU,YAAY,OAAO,KAAK,cAAc;AAAA;AAGjN,IAAM,qBAAqB,CAAC,QAAgB,WAAmB,UAAkB,UAAkB,kBAAkC,GAAG,SAAS,aAAa,YAAY,WAAW;AAO9K,SAAS,kBAAkB,CAAC,QAA4B,WAA8B,QAAoB;AAAA,EAC/G,QAAQ,IAAI,YAAY,KAAK,cAAc,MAAM,YAAY,WAAW;AAAA,EAGxE,MAAM,WAAW,OAAO,CAAC;AAAA,EAEzB,OAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA,SAAS;AAAA,IACT,QAAQ,OAAO,UAAoB;AAAA,MACjC,MAAM,oBAAoB,OAAO,cAAc,MAAwB;AAAA,QACrE,SAAS,UAAU,EAAG,UAAU,aAAa,WAAW;AAAA,UACtD,IAAI;AAAA,YAGF,MAAM,YAAY,KAAK,IAAI,IAAI,OAAO,KAAK,MAAO,YAAY,IAAI,IAAI,IAAK,IAAI;AAAA,YAC/E,MAAM,WAAW,OAAO,CAAC;AAAA,YACzB,MAAM,gBAAgB,UAAU,IAAI,KAAK,YAAY;AAAA,YACrD,MAAM,SAAS,mBAAmB,WAAW,WAAW,UAAU,UAAU,aAAa;AAAA,YAGzF,MAAM,GAAG,IAAI,QAAQ,KAAK,UAAU,KAAK,GAAG;AAAA,cAC1C,UAAU;AAAA,gBACR,WAAW,MAAM;AAAA,gBACjB,OAAO,MAAM;AAAA,cACf;AAAA,YACF,CAAC;AAAA,YAED,OAAO;AAAA,YACP,OAAO,QAAQ;AAAA,YAEf,IAAI,UAAU,cAAc,GAAG;AAAA,cAC7B,MAAM,UAAU,KAAK,UAAU,IAAI,KAAK,OAAO,IAAI;AAAA,cACnD,MAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,OAAO,CAAC;AAAA,YAC3D;AAAA;AAAA,QAEJ;AAAA,QACA,OAAO;AAAA;AAAA,MAGT,IAAI;AAAA,QAEF,MAAM,kBAAkB;AAAA,QAIxB,IAAI,KAAK,OAAO,IAAI;AAAA,UAAM,uBAAuB,IAAI,WAAW,aAAa,SAAS,EAAE,MAAM,MAAM,EAAE;AAAA,QACtG,OAAO,QAAQ;AAAA;AAAA,EAIrB;AAAA;AAMF,eAAe,eAAe,CAAC,IAAiB,MAAgB,YAAY,KAAoB;AAAA,EAC9F,SAAS,IAAI,EAAG,IAAI,KAAK,QAAQ,KAAK,WAAW;AAAA,IAC/C,MAAM,QAAQ,KAAK,MAAM,GAAG,IAAI,SAAS;AAAA,IACzC,MAAM,iBAAiB,MAAM,IAAI,SAAO,GAAG,OAAO,GAAG,CAAC;AAAA,IACtD,MAAM,QAAQ,IAAI,cAAc;AAAA,EAClC;AAAA;AAMF,eAAe,sBAAsB,CAAC,IAAiB,WAAmB,aAAqB,WAAkC;AAAA,EAC/H,IAAI;AAAA,IAEF,MAAM,aAAa,MAAM,GAAG,KAAK,EAAE,QAAQ,WAAW,OAAO,cAAc,EAAE,CAAC;AAAA,IAE9E,IAAI,WAAW,KAAK,UAAU;AAAA,MAAa;AAAA,IAG3C,MAAM,eAAe,IAAI,WAAW,SAAS;AAAA,IAC7C,OAAO,QAAQ;AAAA;AAMnB,eAAe,cAAc,CAAC,IAAiB,WAAmB,WAAkC;AAAA,EAClG,IAAI;AAAA,IAEF,MAAM,aAAa,MAAM,GAAG,KAAK,EAAE,QAAQ,UAAU,CAAC;AAAA,IAEtD,IAAI,WAAW,KAAK,UAAU,WAAW;AAAA,MACvC;AAAA,IACF;AAAA,IAGA,MAAM,YAAY,WAAW,KAC1B,OAAO,CAAC,QAAuD,cAAc,IAAI,QAAQ,CAAC,EAC1F,IAAI,UAAQ;AAAA,MACX,MAAM,IAAI;AAAA,MACV,WAAW,IAAI,KAAK,IAAI,SAAS,SAAS,EAAE,QAAQ;AAAA,IACtD,EAAE,EACD,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS;AAAA,IAG3C,MAAM,eAAe,UAAU,MAAM,GAAG,KAAK,IAAI,GAAG,UAAU,SAAS,SAAS,CAAC,EAAE,IAAI,SAAO,IAAI,IAAI;AAAA,IAGtG,IAAI,aAAa,SAAS,GAAG;AAAA,MAC3B,MAAM,gBAAgB,IAAI,YAAY;AAAA,IACxC;AAAA,IACA,OAAO,QAAQ;AAAA;AAQnB,eAAsB,aAAa,CAAC,IAAiB,UAAkD,CAAC,GAAwB;AAAA,EAC9H,QAAQ,QAAQ,KAAK,YAAY,WAAW;AAAA,EAE5C,IAAI;AAAA,IAEF,MAAM,aAAa,MAAM,GAAG,KAAK,EAAE,QAAQ,UAAU,CAAC;AAAA,IAEtD,IAAI,WAAW,KAAK,WAAW,GAAG;AAAA,MAChC,OAAO,CAAC;AAAA,IACV;AAAA,IAGA,MAAM,aAAa,WAAW,KAC3B,OAAO,CAAC,QAAuD,cAAc,IAAI,QAAQ,CAAC,EAC1F,KAAK,CAAC,GAAG,MAAM;AAAA,MACd,MAAM,aAAa,IAAI,KAAK,EAAE,SAAS,SAAS,EAAE,QAAQ;AAAA,MAC1D,MAAM,aAAa,IAAI,KAAK,EAAE,SAAS,SAAS,EAAE,QAAQ;AAAA,MAC1D,OAAO,aAAa;AAAA,KACrB,EACA,MAAM,GAAG,KAAK;AAAA,IAGjB,MAAM,cAAc,WAAW,IAAI,OAAM,QAAO;AAAA,MAC9C,MAAM,UAAU,MAAM,GAAG,IAAI,IAAI,IAAI;AAAA,MACrC,IAAI,CAAC;AAAA,QAAS,OAAO;AAAA,MAErB,IAAI;AAAA,QACF,MAAM,SAAS,KAAK,MAAM,OAAO;AAAA,QACjC,OAAO,WAAW,MAAM,IAAI,SAAS;AAAA,QACrC,MAAM;AAAA,QACN,OAAO;AAAA;AAAA,KAEV;AAAA,IAED,MAAM,OAAO,MAAM,QAAQ,IAAI,WAAW;AAAA,IAC1C,OAAO,KAAK,OAAO,CAAC,QAAyB,QAAQ,IAAI;AAAA,IACzD,OAAO,OAAO;AAAA,IACd,QAAQ,MAAM,oCAAoC,KAAK;AAAA,IACvD,OAAO,CAAC;AAAA;AAAA;AAOZ,eAAsB,eAAe,CAAC,IAAiB,UAAkC,CAAC,GAAkB;AAAA,EAC1G,QAAQ,YAAY,WAAW;AAAA,EAE/B,IAAI;AAAA,IAEF,MAAM,aAAa,MAAM,GAAG,KAAK,EAAE,QAAQ,UAAU,CAAC;AAAA,IAGtD,MAAM,eAAe,WAAW,KAAK,IAAI,SAAO,IAAI,IAAI;AAAA,IACxD,MAAM,gBAAgB,IAAI,YAAY;AAAA,IACtC,OAAO,OAAO;AAAA,IACd,QAAQ,MAAM,iCAAiC,KAAK;AAAA,IACpD,MAAM;AAAA;AAAA;;AC/LH,IAAM,aAAuC;AAAA,EAClD,WAAW;AAAA,EACX,OAAO;AAAA,EACP,UAAU;AAAA,EACV,OAAO;AAAA,EACP,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AACT;AAKO,SAAS,SAAS,CAAC,OAAiB,UAA6B;AAAA,EACtE,OAAO,WAAW,UAAU,WAAW;AAAA;AAMlC,SAAS,iBAAiB,CAAC,UAA4B,YAAqB,cAAuC,CAAC,GAAG,IAA2C;AAAA,EAEvK,IAAI,aAAa,WAAW;AAAA,IAC1B,MAAM,cAAc;AAAA,MAClB,QAAQ,aAAa,QAAQ;AAAA,MAC7B,oBAAoB,CAAC;AAAA,IACvB;AAAA,IAEA,OAAO,KAAK,gBAAgB,YAAY;AAAA,EAC1C;AAAA,EAEA,IAAI,UAAU,KAAK,YAAY;AAAA,EAG/B,IAAI,aAAa,QAAQ,IAAI;AAAA,IAC3B,UAAU,KAAK,SAAS,GAAG;AAAA,EAC7B;AAAA,EAEA,OAAO;AAAA;AAMF,SAAS,iBAAiB,CAAC,QAAsB,YAA8E;AAAA,EACpI,MAAM,WAAW,aAAa,OAAO,UAAU,aAAa,OAAO,UAAU;AAAA,EAE7E,OAAO;AAAA,IACL,cAAc,UAAU,iBAAiB,aAAa,YAAY;AAAA,IAClE,oBAAoB,UAAU,sBAAsB;AAAA,EACtD;AAAA;AAMK,IAAM,sBAAoC;AAAA,EAC/C,MAAM;AAAA,IACJ;AAAA,MACE,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,OAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,OAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,OAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,OAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,UAAU;AAAA,IACR,SAAS;AAAA,MACP,UAAU;AAAA,MACV,SAAS,CAAC;AAAA,IACZ;AAAA,IACA,IAAI;AAAA,MACF,UAAU;AAAA,MACV,SAAS;AAAA,QACP,WAAW;AAAA,QACX,aAAa;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAAA,EACA,UAAU;AAAA,IACR,aAAa;AAAA,MACX,cAAc;AAAA,MACd,oBAAoB;AAAA,IACtB;AAAA,IACA,YAAY;AAAA,MACV,cAAc;AAAA,MACd,oBAAoB;AAAA,IACtB;AAAA,EACF;AACF;;;ACpGA,IAAM,aAAuE;AAAA,EAC3E,MAAM,CAAC,UAAoB,KAAK,UAAU,OAAO,MAAM,CAAC;AAAA,EACxD,SAAS,CAAC,UAAoB;AAAA,IAC5B,MAAM,QAAQ,CAAC,MAAM,MAAM,YAAY,GAAG,MAAM,SAAS,OAAO,MAAM,SAAS;AAAA,IAE/E,IAAI,MAAM,QAAQ,MAAM,QAAQ,MAAM,IAAI,KAAK,MAAM,KAAK,SAAS,GAAG;AAAA,MACpE,MAAM,KAAK,GAAG,MAAM,KAAK,IAAI,SAAQ,OAAO,QAAQ,WAAW,MAAM,KAAK,UAAU,GAAG,CAAE,CAAC;AAAA,IAC5F;AAAA,IAIA,QAAQ,OAAO,OAAO,WAAW,SAAS,SAAS;AAAA,IACnD,IAAI,OAAO,KAAK,IAAI,EAAE,SAAS,GAAG;AAAA,MAChC,MAAM,KAAK,GAAG,OAAO,OAAO,IAAI,EAAE,IAAI,SAAQ,OAAO,QAAQ,WAAW,MAAM,KAAK,UAAU,GAAG,CAAE,CAAC;AAAA,IACrG;AAAA,IAEA,OAAO,KAAK,MAAM,KAAK,MAAM;AAAA;AAAA,EAE/B,KAAK,CAAC,UAAoB,KAAK,UAAU,KAAK;AAChD;AAEA,SAAS,cAAc,CAAC,OAAiB,QAAqC;AAAA,EAC5E,OAAO,WAAW,QAAQ,KAAK;AAAA;AAGjC,IAAM,iBAA8D;AAAA,EAClE,WAAW,QAAQ;AAAA,EACnB,OAAO,QAAQ;AAAA,EACf,UAAU,QAAQ;AAAA,EAClB,OAAO,QAAQ;AAAA,EACf,SAAS,QAAQ;AAAA,EACjB,QAAQ,QAAQ;AAAA,EAChB,MAAM,QAAQ;AAAA,EACd,OAAO,QAAQ;AACjB;AAEO,SAAS,oBAAoB,CAAC,UAAoB,SAA+B,CAAC,GAAe;AAAA,EACtG,QAAQ,SAAS,OAAO,qBAAqB,UAAU;AAAA,EAEvD,OAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA,SAAS;AAAA,IACT,QAAQ,CAAC,UAAoB;AAAA,MAC3B,MAAM,SAAS,eAAe,OAAO,MAAM;AAAA,MAE3C,IAAI,oBAAoB;AAAA,QACtB,eAAe,MAAM,OAAO,MAAM;AAAA,MACpC,EAAO;AAAA,QACL,QAAQ,KAAK,MAAM;AAAA;AAAA;AAAA,EAGzB;AAAA;;;AClDK,IAAM,kBAA4E;AAAA,EACvF,SAAS,CAAC,UAAoB,WAAkC,qBAAqB,UAAU,MAAM;AAAA,EACrG,IAAI,CAAC,UAAoB,WAA+B,mBAAmB,QAAQ,QAAQ;AAC7F;;;ACJO,SAAS,0BAA0B,CAAC,QAAsB,YAAqB,IAAwC;AAAA,EAE5H,MAAM,gBAAgB,OAAO,KAAK,OAAO,CAAC,SAA4B,KAAK,eAAe,cAAc,KAAK,UAAU,MAAM;AAAA,EAG7H,MAAM,WAAW,cAAc,IAAI,UAAQ;AAAA,IACzC,MAAM,aAAa,OAAO,SAAS,KAAK;AAAA,IACxC,IAAI,CAAC,YAAY;AAAA,MACf,MAAM,IAAI,MAAM,qCAAqC,KAAK,SAAS;AAAA,IACrE;AAAA,IAGA,MAAM,UAAU,kBAAkB,WAAW,UAAU,YAAY,WAAW,SAAoC,EAAE;AAAA,IAGpH,MAAM,mBAAmB;AAAA,MACvB,SAAS,MAAM,gBAAgB,QAAQ,KAAK,OAAmB,OAA+B;AAAA,MAC9F,IAAI,MAAM;AAAA,QACR,IAAI,CAAC,QAAQ,IAAI;AAAA,UACf,MAAM,IAAI,MAAM,yCAAyC;AAAA,QAC3D;AAAA,QACA,OAAO,gBAAgB,GAAG,KAAK,OAAmB,OAAwC;AAAA;AAAA,IAE9F;AAAA,IAEA,MAAM,gBAAgB,iBAAiB,WAAW;AAAA,IAClD,IAAI,CAAC,eAAe;AAAA,MAClB,MAAM,IAAI,MAAM,8BAA8B,WAAW,UAAU;AAAA,IACrE;AAAA,IAEA,OAAO,cAAc;AAAA,GACtB;AAAA,EAGD,QAAQ,cAAc,uBAAuB,kBAAkB,QAAQ,UAAU;AAAA,EAEjF,OAAO,EAAE,cAAc,UAAU,mBAAmB;AAAA;;;AChCtD,IAAI,eAAqC;AAAA,EACvC,cAAc;AAAA,EACd,UAAU,CAAC;AAAA,EACX,oBAAoB;AACtB;AAKA,SAAS,iBAAiB,CAAC,QAA8B;AAAA,EACvD,IAAI,CAAC,aAAa,oBAAoB;AAAA,IACpC,OAAO;AAAA,EACT;AAAA,EAGA,QAAQ,UAAU,OAAO,QAAQ,QAAQ,cAAc,aAAa,iBAAiB,cAAc;AAAA,EASnG,OAAO;AAAA;AAMT,SAAS,aAAa,CAAC,MAA8B;AAAA,EACnD,OAAO,YAAY,QAAQ;AAAA,EAE3B,IAAI,OAAO,YAAY,YAAY,YAAY,MAAM;AAAA,IACnD,OAAO,KAAK,YAAa,KAAK,SAAS,IAAI,EAAE,MAAM,KAAK,IAAI,CAAC,EAAG;AAAA,EAClE;AAAA,EAEA,OAAO,EAAE,OAAO,OAAO,OAAO,MAAO,KAAK,SAAS,IAAI,EAAE,MAAM,KAAK,IAAI,CAAC,EAAG;AAAA;AAM9E,SAAS,cAAc,CAAC,QAA6B;AAAA,EACnD,MAAM,kBAAkB,kBAAkB,MAAM;AAAA,EAChD,OAAO;AAAA,OACF;AAAA,IACH,OAAQ,gBAAgB,SAAS,aAAa;AAAA,IAC9C,WAAW,IAAI,KAAK,EAAE,YAAY;AAAA,EACpC;AAAA;AAOF,eAAe,eAAe,CAAC,OAAgC;AAAA,EAC7D,MAAM,gBAAgB,aAAa,SAChC,OAAO,aAAW,QAAQ,WAAW,UAAU,MAAM,OAAO,QAAQ,QAAQ,CAAC,EAC7E,IAAI,aAAW;AAAA,IACd,IAAI;AAAA,MACF,MAAM,SAAS,QAAQ,OAAO,KAAK;AAAA,MACnC,OAAO,kBAAkB,UAAU,SAAS,QAAQ,QAAQ;AAAA,MAC5D,OAAO,QAAQ;AAAA,MAEf,OAAO,QAAQ,QAAQ;AAAA;AAAA,GAE1B;AAAA,EAEH,MAAM,QAAQ,WAAW,aAAa;AAAA;AA2BjC,IAAM,SAAiB;AAAA,EAI5B,SAAS,CAAC,QAAuC;AAAA,IAC/C,eAAe,KAAK,iBAAiB,OAAO;AAAA;AAAA,EAM9C,SAAS,GAAyB;AAAA,IAChC,OAAO,KAAK,aAAa;AAAA;AAAA,OAMrB,IAAG,CAAC,QAAkC;AAAA,IAC1C,MAAM,QAAQ,eAAe,MAAM;AAAA,IACnC,MAAM,gBAAgB,KAAK;AAAA;AAAA,OAMvB,QAAO,GAAoB;AAAA,IAC/B,OAAO,OAAO,WAAW;AAAA;AAAA,EAO3B,SAAS,IAAI,MAA8B;AAAA,IACzC,MAAM,SAAS,cAAc,IAAI;AAAA,IACjC,OAAO,KAAK,IAAI,KAAK,QAAQ,OAAO,YAAY,CAAC;AAAA;AAAA,EAMnD,KAAK,IAAI,MAA8B;AAAA,IACrC,MAAM,SAAS,cAAc,IAAI;AAAA,IACjC,OAAO,KAAK,IAAI,KAAK,QAAQ,OAAO,QAAQ,CAAC;AAAA;AAAA,EAM/C,QAAQ,IAAI,MAA8B;AAAA,IACxC,MAAM,SAAS,cAAc,IAAI;AAAA,IACjC,OAAO,KAAK,IAAI,KAAK,QAAQ,OAAO,WAAW,CAAC;AAAA;AAAA,EAMlD,KAAK,IAAI,MAA8B;AAAA,IACrC,MAAM,SAAS,cAAc,IAAI;AAAA,IACjC,OAAO,KAAK,IAAI,KAAK,QAAQ,OAAO,QAAQ,CAAC;AAAA;AAAA,EAM/C,OAAO,IAAI,MAA8B;AAAA,IACvC,MAAM,SAAS,cAAc,IAAI;AAAA,IACjC,OAAO,KAAK,IAAI,KAAK,QAAQ,OAAO,UAAU,CAAC;AAAA;AAAA,EAMjD,MAAM,IAAI,MAA8B;AAAA,IACtC,MAAM,SAAS,cAAc,IAAI;AAAA,IACjC,OAAO,KAAK,IAAI,KAAK,QAAQ,OAAO,SAAS,CAAC;AAAA;AAAA,EAMhD,IAAI,IAAI,MAA8B;AAAA,IACpC,MAAM,SAAS,cAAc,IAAI;AAAA,IACjC,OAAO,KAAK,IAAI,KAAK,QAAQ,OAAO,OAAO,CAAC;AAAA;AAAA,EAM9C,KAAK,IAAI,MAA8B;AAAA,IACrC,MAAM,SAAS,cAAc,IAAI;AAAA,IACjC,OAAO,KAAK,IAAI,KAAK,QAAQ,OAAO,QAAQ,CAAC;AAAA;AAEjD;AAGA,IAAI,sBAAsB;AAiB1B,eAAsB,UAAU,CAAC,SAA8C;AAAA,EAC7E,IAAI,qBAAqB;AAAA,IACvB,OAAO;AAAA,EACT;AAAA,EAGA,QAAQ,QAAQ,OAAO,aAAa,MAAM,oBAAoB;AAAA,EAG9D,MAAM,cAAc,2BAA2B,QAAQ,YAAY,KAAK;AAAA,EAExE,OAAO,UAAU,WAAW;AAAA,EAC5B,sBAAsB;AAAA,EAGtB,IAAI,iBAAiB;AAAA,IACnB,MAAM,gBAAgB;AAAA,EACxB;AAAA,EAEA,OAAO;AAAA;AAMF,SAAS,aAAa,GAAY;AAAA,EACvC,OAAO;AAAA;AAMF,SAAS,kBAAkB,GAAS;AAAA,EACzC,IAAI,CAAC,qBAAqB;AAAA,IACxB,MAAM,IAAI,MAAM,oFAAoF;AAAA,EACtG;AAAA;",
  "debugId": "5F1136911262FC2664756E2164756E21",
  "names": []
}