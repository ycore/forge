{"version":3,"file":"index.js","sources":["../../../../node_modules/.bun/nanoid@5.1.6/node_modules/nanoid/url-alphabet/index.js","../../../../node_modules/.bun/nanoid@5.1.6/node_modules/nanoid/index.browser.js","../../src/logger/channels/kv-channel.ts","../../src/logger/logger.config.ts","../../src/logger/channels/console-channel.ts","../../src/logger/channels/registry.ts","../../src/logger/logger.helpers.ts","../../src/logger/logger.ts"],"sourcesContent":["export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","/// <reference path=\"../../@types/worker-runtime.d.ts\" />\n\nimport { nanoid } from 'nanoid';\nimport type { KVLogChannelConfig, LogChannel, LogEntry, LogMetadata } from '../@types/logger.types';\n\n/** Type guard to check if metadata is valid LogMetadata */\nconst isLogMetadata = (metadata: unknown): metadata is LogMetadata => {\n  return typeof metadata === 'object' && metadata !== null && 'timestamp' in metadata && 'level' in metadata && typeof metadata.timestamp === 'string' && typeof metadata.level === 'string';\n};\n\n/** Type guard to validate parsed log entry */\nconst isLogEntry = (data: unknown): data is LogEntry => {\n  return typeof data === 'object' && data !== null && 'event' in data && 'level' in data && 'timestamp' in data && typeof data.event === 'string' && typeof data.level === 'string' && typeof data.timestamp === 'string';\n};\n\nconst logEntryKvTemplate = (prefix: string, timestamp: number, workerId: string, uniqueId: string, attemptSuffix: string): string => `${prefix}${timestamp}-${workerId}-${uniqueId}${attemptSuffix}`;\n\n/**\n * Creates a KV-based log channel for Cloudflare Workers\n * Maintains logs with batched cleanup on threshold trigger\n * Enhanced uniqueness strategy with exponential backoff for race condition mitigation\n */\nexport function createKVLogChannel(config: KVLogChannelConfig, minLevel: LogEntry['level'] = 'info'): LogChannel {\n  const { kv, logsLimit = 500, logsTrigger = 1000, keyPrefix = 'log:' } = config;\n\n  // Worker-unique identifier to prevent cross-worker collisions\n  const workerId = nanoid(6);\n\n  return {\n    name: 'kv-storage',\n    minLevel,\n    enabled: true,\n    output: async (entry: LogEntry) => {\n      const storeLogWithRetry = async (maxAttempts = 3): Promise<boolean> => {\n        for (let attempt = 0; attempt < maxAttempts; attempt++) {\n          try {\n            // High-precision timestamp (microseconds) + worker ID + nanoid = collision-resistant\n            // Combines millisecond timestamp with microsecond precision from performance.now()\n            const timestamp = Date.now() * 1000 + Math.floor((performance.now() % 1) * 1000);\n            const uniqueId = nanoid(8); // 8 characters for compact yet collision-resistant IDs\n            const attemptSuffix = attempt > 0 ? `-r${attempt}` : '';\n            const logKey = logEntryKvTemplate(keyPrefix, timestamp, workerId, uniqueId, attemptSuffix);\n\n            // Store log entry with metadata\n            await kv.put(logKey, JSON.stringify(entry), {\n              metadata: {\n                timestamp: entry.timestamp,\n                level: entry.level,\n              },\n            });\n\n            return true;\n          } catch (_error) {\n            // Exponential backoff with jitter on failure (5ms base, doubles each attempt)\n            if (attempt < maxAttempts - 1) {\n              const backoff = 2 ** attempt * 5 + Math.random() * 5;\n              await new Promise(resolve => setTimeout(resolve, backoff));\n            }\n          }\n        }\n        return false;\n      };\n\n      try {\n        // Attempt to store log with exponential backoff retry strategy\n        await storeLogWithRetry();\n\n        // Check cleanup every ~50 logs using random sampling - ~1 in 50 logs\n        // Silently ignore cleanup failures to prevent cascading errors\n        if (Math.random() < 0.02) cleanupOldLogsIfNeeded(kv, logsLimit, logsTrigger, keyPrefix).catch(() => {});\n      } catch (_error) {\n        // Graceful degradation - Avoid logging the error details to prevent potential infinite loops\n      }\n    },\n  };\n}\n\n/**\n * Batch delete operations with size limits to avoid KV rate limits\n */\nasync function batchDeleteKeys(kv: KVNamespace, keys: string[], batchSize = 100): Promise<void> {\n  for (let i = 0; i < keys.length; i += batchSize) {\n    const batch = keys.slice(i, i + batchSize);\n    const deletePromises = batch.map(key => kv.delete(key));\n    await Promise.all(deletePromises);\n  }\n}\n\n/**\n * Check if cleanup is needed and trigger if threshold exceeded\n */\nasync function cleanupOldLogsIfNeeded(kv: KVNamespace, logsLimit: number, logsTrigger: number, keyPrefix: string): Promise<void> {\n  try {\n    // List with limit to see if trigger has been exceeded\n    const listResult = await kv.list({ prefix: keyPrefix, limit: logsTrigger + 1 });\n\n    if (listResult.keys.length <= logsTrigger) return;\n\n    // Crossed the trigger threshold, perform cleanup\n    await cleanupOldLogs(kv, logsLimit, keyPrefix);\n  } catch (_error) {} // Silently fail - cleanup is not critical\n}\n\n/**\n * Cleanup old logs keeping only the most recent logsLimit entries\n */\nasync function cleanupOldLogs(kv: KVNamespace, logsLimit: number, keyPrefix: string): Promise<void> {\n  try {\n    // List all log keys\n    const listResult = await kv.list({ prefix: keyPrefix });\n\n    if (listResult.keys.length <= logsLimit) {\n      return; // No cleanup needed\n    }\n\n    // Filter and transform keys with valid metadata into a typed structure\n    const validKeys = listResult.keys\n      .filter((key): key is typeof key & { metadata: LogMetadata } => isLogMetadata(key.metadata))\n      .map(key => ({\n        name: key.name,\n        timestamp: new Date(key.metadata.timestamp).getTime(),\n      }))\n      .sort((a, b) => a.timestamp - b.timestamp); // Oldest first\n\n    // Delete excess logs (keep only logsLimit number of logs)\n    const keysToDelete = validKeys.slice(0, Math.max(0, validKeys.length - logsLimit)).map(key => key.name);\n\n    // Batch delete operations to respect KV rate limits\n    if (keysToDelete.length > 0) {\n      await batchDeleteKeys(kv, keysToDelete);\n    }\n  } catch (_error) {\n    // Silently fail - cleanup failures shouldn't impact logging\n  }\n}\n\n/**\n * Retrieves logs from KV storage\n */\nexport async function getLogsFromKV(kv: KVNamespace, options: { limit?: number; keyPrefix?: string } = {}): Promise<LogEntry[]> {\n  const { limit = 100, keyPrefix = 'log:' } = options;\n\n  try {\n    // List all log keys\n    const listResult = await kv.list({ prefix: keyPrefix });\n\n    if (listResult.keys.length === 0) {\n      return [];\n    }\n\n    // Filter, sort, and limit keys with valid metadata\n    const sortedKeys = listResult.keys\n      .filter((key): key is typeof key & { metadata: LogMetadata } => isLogMetadata(key.metadata))\n      .sort((a, b) => {\n        const timestampA = new Date(a.metadata.timestamp).getTime();\n        const timestampB = new Date(b.metadata.timestamp).getTime();\n        return timestampB - timestampA; // Newest first\n      })\n      .slice(0, limit);\n\n    // Fetch and parse log entries\n    const logPromises = sortedKeys.map(async key => {\n      const logData = await kv.get(key.name);\n      if (!logData) return null;\n\n      try {\n        const parsed = JSON.parse(logData);\n        return isLogEntry(parsed) ? parsed : null;\n      } catch {\n        return null;\n      }\n    });\n\n    const logs = await Promise.all(logPromises);\n    return logs.filter((log): log is LogEntry => log !== null);\n  } catch (error) {\n    console.error('Failed to retrieve logs from KV:', error);\n    return [];\n  }\n}\n\n/**\n * Clears all logs from KV storage\n */\nexport async function clearLogsFromKV(kv: KVNamespace, options: { keyPrefix?: string } = {}): Promise<void> {\n  const { keyPrefix = 'log:' } = options;\n\n  try {\n    // List all log keys\n    const listResult = await kv.list({ prefix: keyPrefix });\n\n    // Delete all log entries using batching\n    const keysToDelete = listResult.keys.map(key => key.name);\n    await batchDeleteKeys(kv, keysToDelete);\n  } catch (error) {\n    console.error('Failed to clear logs from KV:', error);\n    throw error;\n  }\n}\n","/// <reference path=\"../@types/worker-runtime.d.ts\" />\n\nimport type { LoggerConfig, LogLevel } from './@types/logger.types';\n\n// RFC 5424 log level hierarchy (higher number = higher severity)\nexport const LOG_LEVELS: Record<LogLevel, number> = {\n  emergency: 7,\n  alert: 6,\n  critical: 5,\n  error: 4,\n  warning: 3,\n  notice: 2,\n  info: 1,\n  debug: 0,\n} as const;\n\n/**\n * Check if a log level should be logged based on minimum level threshold\n */\nexport function shouldLog(level: LogLevel, minLevel: LogLevel): boolean {\n  return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];\n}\n\n/**\n * Get environment-specific channel options\n */\nexport function getChannelOptions(registry: 'console' | 'kv', production: boolean, baseOptions: Record<string, unknown> = {}, kv?: KVNamespace): Record<string, unknown> {\n  // Console channel environment-specific defaults\n  if (registry === 'console') {\n    const envDefaults = {\n      format: production ? 'raw' : 'json',\n      useLogLevelMethods: !production,\n    };\n    // Explicit options override environment defaults\n    return { ...envDefaults, ...baseOptions };\n  }\n\n  let options = { ...baseOptions };\n\n  // KV channel - inject KV namespace\n  if (registry === 'kv' && kv) {\n    options = { ...options, kv };\n  }\n\n  return options;\n}\n\n/**\n * Get environment-specific logger defaults\n */\nexport function getLoggerDefaults(config: LoggerConfig, production: boolean): { defaultLevel: LogLevel; enableSanitization: boolean } {\n  const defaults = production ? config.defaults?.production : config.defaults?.development;\n\n  return {\n    defaultLevel: defaults?.defaultLevel || (production ? 'warning' : 'info'),\n    enableSanitization: defaults?.enableSanitization ?? true,\n  };\n}\n\n/**\n * Default logger configuration\n */\nexport const defaultLoggerConfig: LoggerConfig = {\n  init: [\n    {\n      production: false,\n      channel: 'console',\n      level: 'debug',\n    },\n    {\n      production: false,\n      channel: 'console',\n      level: 'warning',\n    },\n    {\n      production: false,\n      channel: 'kv',\n      level: 'info',\n    },\n    {\n      production: true,\n      channel: 'kv',\n      level: 'warning',\n    },\n  ],\n  channels: {\n    console: {\n      registry: 'console',\n      options: {}, // Will be populated with environment defaults\n    },\n    kv: {\n      registry: 'kv',\n      options: {\n        logsLimit: 500,\n        logsTrigger: 750,\n      },\n    },\n  },\n  defaults: {\n    development: {\n      defaultLevel: 'debug',\n      enableSanitization: true,\n    },\n    production: {\n      defaultLevel: 'warning',\n      enableSanitization: true,\n    },\n  },\n};\n","import type { ConsoleChannelConfig, ConsoleOutputFormat, LogChannel, LogEntry, LogLevel } from '../@types/logger.types';\n\n/**\n * Console channel with environment-appropriate formatting\n * Outputs structured logs to the browser/Node.js console\n */\nconst formatters: Record<ConsoleOutputFormat, (entry: LogEntry) => string> = {\n  json: (entry: LogEntry) => JSON.stringify(entry, null, 2),\n  compact: (entry: LogEntry) => {\n    const parts = [entry.level.toUpperCase(), entry.event || 'LOG', entry.timestamp];\n\n    if (entry.args && Array.isArray(entry.args) && entry.args.length > 0) {\n      parts.push(...entry.args.map(arg => (typeof arg === 'string' ? arg : JSON.stringify(arg))));\n    }\n\n    // Add any additional properties (excluding the ones already handled)\n    // biome-ignore lint/correctness/noUnusedVariables: extracting unused props\n    const { level, event, timestamp, args, ...rest } = entry;\n    if (Object.keys(rest).length > 0) {\n      parts.push(...Object.values(rest).map(val => (typeof val === 'string' ? val : JSON.stringify(val))));\n    }\n\n    return `[ ${parts.join(' || ')} ]`;\n  },\n  raw: (entry: LogEntry) => JSON.stringify(entry),\n};\n\nfunction formatLogEntry(entry: LogEntry, format: ConsoleOutputFormat): string {\n  return formatters[format](entry);\n}\n\nconst consoleMethods: Record<LogLevel, (message: string) => void> = {\n  emergency: console.error,\n  alert: console.error,\n  critical: console.error,\n  error: console.error,\n  warning: console.warn,\n  notice: console.info,\n  info: console.info,\n  debug: console.debug,\n};\n\nexport function createConsoleChannel(minLevel: LogLevel, config: ConsoleChannelConfig = {}): LogChannel {\n  const { format = 'raw', useLogLevelMethods = false } = config;\n\n  return {\n    name: 'console',\n    minLevel,\n    enabled: true,\n    output: (entry: LogEntry) => {\n      const output = formatLogEntry(entry, format);\n\n      if (useLogLevelMethods) {\n        consoleMethods[entry.level](output);\n      } else {\n        console.info(output);\n      }\n    },\n  };\n}\n","import type { ConsoleChannelConfig, KVLogChannelConfig, LogLevel } from '../@types/logger.types';\nimport type { ConsoleChannelFactory, KVChannelFactory } from '../@types/registry.types';\nimport { createConsoleChannel } from './console-channel';\nimport { createKVLogChannel } from './kv-channel';\n\n/**\n * Registry of available channel factories\n */\nexport const ChannelRegistry: { console: ConsoleChannelFactory; kv: KVChannelFactory } = {\n  console: (minLevel: LogLevel, config?: ConsoleChannelConfig) => createConsoleChannel(minLevel, config),\n  kv: (minLevel: LogLevel, config: KVLogChannelConfig) => createKVLogChannel(config, minLevel),\n};\n","/// <reference path=\"../@types/worker-runtime.d.ts\" />\n\nimport type { ChannelInitConfig, ConsoleChannelConfig, InternalLoggerConfig, KVLogChannelConfig, LoggerConfig, LogLevel } from './@types/logger.types';\nimport { ChannelRegistry } from './channels/registry';\nimport { getChannelOptions, getLoggerDefaults } from './logger.config';\n\n/**\n * Create internal logger configuration from declarative config\n */\nexport function createInternalLoggerConfig(config: LoggerConfig, production: boolean, kv?: KVNamespace): InternalLoggerConfig {\n  // Filter init configs for current environment\n  const relevantInits = config.init.filter((init: ChannelInitConfig) => init.production === production && init.level !== 'null');\n\n  // Create channels based on filtered init configs\n  const channels = relevantInits.map(init => {\n    const channelDef = config.channels[init.channel];\n    if (!channelDef) {\n      throw new Error(`Channel definition not found for: ${init.channel}`);\n    }\n\n    // Get environment-appropriate options using config logic\n    const options = getChannelOptions(channelDef.registry, production, channelDef.options as Record<string, unknown>, kv);\n\n    // Map-based channel factory lookup\n    const channelFactories = {\n      console: () => ChannelRegistry.console(init.level as LogLevel, options as ConsoleChannelConfig),\n      kv: () => {\n        if (!options.kv) {\n          throw new Error('KV namespace is required for KV channel');\n        }\n        return ChannelRegistry.kv(init.level as LogLevel, options as unknown as KVLogChannelConfig);\n      },\n    } as const;\n\n    const createChannel = channelFactories[channelDef.registry as keyof typeof channelFactories];\n    if (!createChannel) {\n      throw new Error(`Unsupported registry type: ${channelDef.registry}`);\n    }\n\n    return createChannel();\n  });\n\n  // Get environment defaults from config\n  const { defaultLevel, enableSanitization } = getLoggerDefaults(config, production);\n\n  return { defaultLevel, channels, enableSanitization };\n}\n","/// <reference path=\"../@types/worker-runtime.d.ts\" />\n\n/** biome-ignore-all lint/suspicious/noExplicitAny: acceptable */\nimport type { BaseLogParams, InternalLoggerConfig, LogArgs, LogEntry, Logger, LoggerConfig, LogLevel, LogParams } from './@types/logger.types';\nimport { shouldLog } from './logger.config';\nimport { createInternalLoggerConfig } from './logger.helpers';\n\nexport interface LoggerState {\n  initialized: boolean;\n  wasInitializedHere?: boolean;\n}\n\n// Global logger configuration\nlet loggerConfig: InternalLoggerConfig = {\n  defaultLevel: 'info',\n  channels: [],\n  enableSanitization: true,\n};\n\n/**\n * Sanitizes log parameters by removing sensitive fields\n */\nfunction sanitizeLogParams(params: LogParams): LogParams {\n  if (!loggerConfig.enableSanitization) {\n    return params;\n  }\n\n  // biome-ignore lint/correctness/noUnusedVariables: intentional\n  const { password, token, secret, apiKey, sessionToken, bearerToken, refreshToken, ...sanitized } = params as LogParams & {\n    password?: unknown;\n    token?: unknown;\n    secret?: unknown;\n    apiKey?: unknown;\n    sessionToken?: unknown;\n    bearerToken?: unknown;\n    refreshToken?: unknown;\n  };\n  return sanitized;\n}\n\n/**\n * Formats log arguments similar to diary's approach\n */\nfunction formatLogArgs(args: LogArgs): BaseLogParams {\n  const [message, ...rest] = args;\n\n  if (typeof message === 'object' && message !== null) {\n    return { ...message, ...(rest.length > 0 ? { args: rest } : {}) } as BaseLogParams;\n  }\n\n  return { event: String(message), ...(rest.length > 0 ? { args: rest } : {}) } as BaseLogParams;\n}\n\n/**\n * Creates a structured log entry\n */\nfunction createLogEntry(params: LogParams): LogEntry {\n  const sanitizedParams = sanitizeLogParams(params);\n  return {\n    ...sanitizedParams,\n    level: (sanitizedParams.level || loggerConfig.defaultLevel) as LogLevel,\n    timestamp: new Date().toISOString(),\n  } as LogEntry;\n}\n\n/**\n * Writes log entry to all enabled channels that meet the level threshold\n * Logging failures are silently ignored to prevent disrupting application flow\n */\nasync function writeToChannels(entry: LogEntry): Promise<void> {\n  const writePromises = loggerConfig.channels\n    .filter(channel => channel.enabled && shouldLog(entry.level, channel.minLevel))\n    .map(channel => {\n      try {\n        const result = channel.output(entry);\n        return result instanceof Promise ? result : Promise.resolve();\n      } catch (_error) {\n        // Silently ignore logging failures to prevent disrupting application flow\n        return Promise.resolve();\n      }\n    });\n\n  await Promise.allSettled(writePromises);\n}\n\n// Production optimizations are handled by the Vite logger plugin\n// These runtime checks will be replaced with static values during build\n\n/**\n * Enhanced Structured Logging Utility with Multi-Channel Support\n *\n * Features:\n * - RFC 5424 log levels with proper hierarchy\n * - Multi-channel output (console, webhooks, Slack, etc.)\n * - Environment-specific configuration\n * - Flexible API supporting both structured objects and diary-style strings\n * - Security sanitization for sensitive data\n * - Production build optimization with dead code elimination\n * - Optimized for Cloudflare Workers deployment\n * - **Error-safe**: Never throws or contributes to error flow - logging failures are silently ignored\n *\n * Usage patterns:\n * - Critical logging: `await logger.error(...)` - ensures completion\n * - Non-critical logging: `logger.debug(...)` - fire-and-forget\n * - All methods return Promise<void> but never throw or reject\n *\n * @see {@link https://developers.cloudflare.com/workers/observability/logs/workers-logs/}\n * @see {@link https://tools.ietf.org/html/rfc5424}\n */\nexport const logger: Logger = {\n  /**\n   * Configure the logger with custom settings\n   */\n  configure(config: Partial<InternalLoggerConfig>) {\n    loggerConfig = { ...loggerConfig, ...config };\n  },\n\n  /**\n   * Get current logger configuration\n   */\n  getConfig(): InternalLoggerConfig {\n    return { ...loggerConfig };\n  },\n\n  /**\n   * Core logging method that writes to all enabled channels\n   */\n  async log(params: LogParams): Promise<void> {\n    const entry = createLogEntry(params);\n    await writeToChannels(entry);\n  },\n\n  /**\n   * Genarates a support number\n   */\n  async support(): Promise<string> {\n    return crypto.randomUUID();\n  },\n  // RFC 5424 log levels in descending order of severity\n\n  /**\n   * System is unusable - emergency level\n   */\n  emergency(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'emergency' });\n  },\n\n  /**\n   * Action must be taken immediately - alert level\n   */\n  alert(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'alert' });\n  },\n\n  /**\n   * Critical conditions - critical level\n   */\n  critical(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'critical' });\n  },\n\n  /**\n   * Error conditions - error level\n   */\n  error(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'error' });\n  },\n\n  /**\n   * Warning conditions - warning level\n   */\n  warning(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'warning' });\n  },\n\n  /**\n   * Normal but significant conditions - notice level\n   */\n  notice(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'notice' });\n  },\n\n  /**\n   * Informational messages - info level\n   */\n  info(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'info' });\n  },\n\n  /**\n   * Debug-level messages - debug level\n   */\n  debug(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'debug' });\n  },\n};\n\n// Track initialization state\nlet isLoggerInitialized = false;\n\n/**\n * Logger initialization options\n */\nexport interface InitLoggerOptions {\n  config: LoggerConfig;\n  store: KVNamespace;\n  production: boolean;\n  startupCallback?: () => Promise<void>;\n}\n\n/**\n * Initialize logger with named options\n * Returns a boolean indicating whether initialization actually occurred (true) or was already done (false)\n * Handles race conditions internally - safe to call multiple times\n */\nexport async function initLogger(options: InitLoggerOptions): Promise<boolean> {\n  if (isLoggerInitialized) {\n    return false;\n  }\n\n  // Default to production for safety\n  const { config, store, production = true, startupCallback } = options;\n\n  // Create internal logger config from declarative config\n  const finalConfig = createInternalLoggerConfig(config, production, store);\n\n  logger.configure(finalConfig);\n  isLoggerInitialized = true;\n\n  // Execute optional startup logging callback\n  if (startupCallback) {\n    await startupCallback();\n  }\n\n  return true; // Initialization completed\n}\n\n/**\n * Check if logger has been initialized\n */\nexport function isInitialized(): boolean {\n  return isLoggerInitialized;\n}\n\n/**\n * Require logger to be initialized, throws if not\n */\nexport function requireInitialized(): void {\n  if (!isLoggerInitialized) {\n    throw new Error('Logger must be initialized before use. Call initLogger() in entry.worker.ts first.');\n  }\n}\n"],"names":["scopedUrlAlphabet"],"mappings":"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","x_google_ignoreList":[0,1]}