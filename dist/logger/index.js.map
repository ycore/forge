{
  "version": 3,
  "sources": ["../../src/logger/channels/console-channel.ts", "../../src/logger/channels/kv-channel.ts", "../../src/logger/channels/webhook-channel.ts", "../../src/logger/channels/registry.ts", "../../src/logger/logger.config.ts", "../../src/logger/logger.ts"],
  "sourcesContent": [
    "import type { LogChannel, LogEntry, LogLevel } from '../@types/logger.types';\n\nexport interface ConsoleChannelConfig {\n  /** Pretty print JSON output (default: false) */\n  prettyPrint?: boolean;\n  /** Custom console method for different log levels */\n  useLogLevelMethods?: boolean;\n}\n\n/**\n * Console channel with environment-appropriate formatting\n * Outputs structured logs to the browser/Node.js console\n */\nexport function createConsoleChannel(\n  minLevel: LogLevel,\n  config: ConsoleChannelConfig = {}\n): LogChannel {\n  const { prettyPrint = false, useLogLevelMethods = false } = config;\n\n  return {\n    name: 'console',\n    minLevel,\n    enabled: true,\n    output: (entry: LogEntry) => {\n      const output = prettyPrint ? JSON.stringify(entry, null, 2) : JSON.stringify(entry);\n      \n      if (useLogLevelMethods) {\n        // Use appropriate console method based on log level\n        switch (entry.level) {\n          case 'emergency':\n          case 'alert':\n          case 'critical':\n          case 'error':\n            console.error(output);\n            break;\n          case 'warning':\n            console.warn(output);\n            break;\n          case 'debug':\n            console.debug(output);\n            break;\n          case 'info':\n          case 'notice':\n          default:\n            console.info(output);\n            break;\n        }\n      } else {\n        console.log(output);\n      }\n    },\n  };\n}",
    "import type { LogChannel, LogEntry } from '../@types/logger.types';\n\ninterface LogMetadata {\n  timestamp: string;\n  level: string;\n  count: number;\n}\n\nexport interface KVLogChannelConfig {\n  /** KV namespace to store logs */\n  kv: KVNamespace;\n  /** Maximum number of logs to keep in storage (default: 500) */\n  logsLimit?: number;\n  /** Trigger cleanup when logs exceed this number (default: 1000) */\n  logsTrigger?: number;\n  /** Log key prefix (default: 'log:') */\n  keyPrefix?: string;\n  /** Metadata key for log count (default: 'log_count') */\n  countKey?: string;\n}\n\n/**\n * Creates a KV-based log channel for Cloudflare Workers\n * Maintains logs with batched cleanup when trigger threshold is reached\n */\nexport function createKVLogChannel(config: KVLogChannelConfig, minLevel: LogEntry['level'] = 'info'): LogChannel {\n  const { kv, logsLimit = 500, logsTrigger = 1000, keyPrefix = 'log:', countKey = 'log_count' } = config;\n\n  return {\n    name: 'kv-storage',\n    minLevel,\n    enabled: true,\n    output: async (entry: LogEntry) => {\n      try {\n        // Get current log count\n        const currentCountStr = await kv.get(countKey);\n        const currentCount = currentCountStr ? Number.parseInt(currentCountStr, 10) : 0;\n        const nextCount = currentCount + 1;\n\n        // Create unique key with timestamp for natural ordering (most recent first when listed)\n        const timestamp = new Date(entry.timestamp).getTime();\n        const logKey = `${keyPrefix}${timestamp}-${nextCount}`;\n\n        // Store log entry with metadata\n        await kv.put(logKey, JSON.stringify(entry), {\n          metadata: {\n            timestamp: entry.timestamp,\n            level: entry.level,\n            count: nextCount,\n          },\n        });\n\n        // Update the log count\n        await kv.put(countKey, nextCount.toString());\n\n        // Trigger cleanup if we've exceeded the trigger threshold\n        if (nextCount >= logsTrigger) {\n          // Don't await cleanup to avoid blocking log writing\n          cleanupOldLogs(kv, logsLimit, keyPrefix, countKey).catch(error => {\n            console.error('Failed to cleanup old logs:', error);\n          });\n        }\n      } catch (error) {\n        console.error('Failed to store log in KV:', error);\n      }\n    },\n  };\n}\n\n/**\n * Batch delete operations with size limits to avoid KV rate limits\n */\nasync function batchDeleteKeys(kv: KVNamespace, keys: string[], batchSize = 100): Promise<void> {\n  for (let i = 0; i < keys.length; i += batchSize) {\n    const batch = keys.slice(i, i + batchSize);\n    const deletePromises = batch.map(key => kv.delete(key));\n    await Promise.all(deletePromises);\n  }\n}\n\n/**\n * Cleanup old logs when trigger threshold is reached\n */\nasync function cleanupOldLogs(kv: KVNamespace, logsLimit: number, keyPrefix: string, countKey: string): Promise<void> {\n  try {\n    // List all log keys\n    const listResult = await kv.list({ prefix: keyPrefix });\n\n    if (listResult.keys.length <= logsLimit) {\n      return; // No cleanup needed\n    }\n\n    // Sort keys by timestamp (oldest first for deletion)\n    const sortedKeys = listResult.keys\n      .filter(key => key.metadata && (key.metadata as LogMetadata).timestamp)\n      .sort((a, b) => {\n        const timestampA = new Date((a.metadata as LogMetadata).timestamp).getTime();\n        const timestampB = new Date((b.metadata as LogMetadata).timestamp).getTime();\n        return timestampA - timestampB; // Oldest first\n      });\n\n    // Delete excess logs (keep only logsLimit number of logs)\n    const logsToDelete = sortedKeys.slice(0, sortedKeys.length - logsLimit);\n    const keysToDelete = logsToDelete.map(key => key.name);\n\n    // Batch delete operations to respect KV rate limits\n    await batchDeleteKeys(kv, keysToDelete);\n\n    // Update count after cleanup to maintain consistency\n    const remainingCount = sortedKeys.length - logsToDelete.length;\n    await kv.put(countKey, remainingCount.toString());\n\n    console.log(`Cleaned up ${logsToDelete.length} old logs, keeping ${logsLimit} most recent logs`);\n  } catch (error) {\n    console.error('Failed to cleanup old logs:', error);\n    throw error;\n  }\n}\n\n/**\n * Retrieves logs from KV storage\n */\nexport async function getLogsFromKV(\n  kv: KVNamespace,\n  options: {\n    limit?: number;\n    keyPrefix?: string;\n    countKey?: string;\n  } = {}\n): Promise<LogEntry[]> {\n  const { limit = 100, keyPrefix = 'log:', countKey = 'log_count' } = options;\n\n  try {\n    // List all log keys\n    const listResult = await kv.list({ prefix: keyPrefix });\n\n    if (!listResult.keys.length) {\n      return [];\n    }\n\n    // Sort keys by their metadata timestamp (newest first)\n    const sortedKeys = listResult.keys\n      .filter(key => key.metadata && (key.metadata as LogMetadata).timestamp)\n      .sort((a, b) => {\n        const timestampA = new Date((a.metadata as LogMetadata).timestamp).getTime();\n        const timestampB = new Date((b.metadata as LogMetadata).timestamp).getTime();\n        return timestampB - timestampA; // Newest first\n      })\n      .slice(0, limit);\n\n    // Fetch log entries\n    const logPromises = sortedKeys.map(async key => {\n      const logData = await kv.get(key.name);\n      return logData ? (JSON.parse(logData) as LogEntry) : null;\n    });\n\n    const logs = await Promise.all(logPromises);\n    return logs.filter((log): log is LogEntry => log !== null);\n  } catch (error) {\n    console.error('Failed to retrieve logs from KV:', error);\n    return [];\n  }\n}\n\n/**\n * Clears all logs from KV storage\n */\nexport async function clearLogsFromKV(\n  kv: KVNamespace,\n  options: {\n    keyPrefix?: string;\n    countKey?: string;\n  } = {}\n): Promise<void> {\n  const { keyPrefix = 'log:', countKey = 'log_count' } = options;\n\n  try {\n    // List all log keys\n    const listResult = await kv.list({ prefix: keyPrefix });\n\n    // Delete all log entries using batching\n    const keysToDelete = listResult.keys.map(key => key.name);\n    await batchDeleteKeys(kv, keysToDelete);\n\n    // Reset the count\n    await kv.delete(countKey);\n  } catch (error) {\n    console.error('Failed to clear logs from KV:', error);\n    throw error;\n  }\n}\n",
    "import type { LogChannel, LogEntry, LogLevel } from '../@types/logger.types';\n\nexport interface WebhookChannelConfig {\n  /** Webhook URL to send logs to */\n  webhookUrl: string;\n  /** Custom headers to include in webhook requests */\n  headers?: Record<string, string>;\n  /** Timeout for webhook requests in milliseconds (default: 5000) */\n  timeout?: number;\n  /** Retry configuration */\n  retry?: {\n    attempts: number;\n    delay: number;\n  };\n  /** Custom payload formatter */\n  formatter?: (entry: LogEntry) => Record<string, unknown>;\n}\n\n/**\n * External webhook channel for critical alerts and monitoring integrations\n * Sends structured log data to external services via HTTP webhooks\n */\nexport function createWebhookChannel(\n  config: WebhookChannelConfig,\n  minLevel: LogLevel = 'error'\n): LogChannel {\n  const {\n    webhookUrl,\n    headers = {},\n    timeout = 5000,\n    retry,\n    formatter,\n  } = config;\n\n  const defaultHeaders = {\n    'Content-Type': 'application/json',\n    'User-Agent': 'forge-logger/1.0',\n    ...headers,\n  };\n\n  const defaultFormatter = (entry: LogEntry) => ({\n    level: entry.level,\n    timestamp: entry.timestamp,\n    event: entry.event,\n    message: `${entry.event}: ${entry.timestamp}`,\n    data: entry,\n    source: 'forge-logger',\n  });\n\n  const sendWebhook = async (entry: LogEntry, attempt = 1): Promise<void> => {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      const payload = formatter ? formatter(entry) : defaultFormatter(entry);\n\n      const response = await fetch(webhookUrl, {\n        method: 'POST',\n        headers: defaultHeaders,\n        body: JSON.stringify(payload),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`Webhook request failed: ${response.status} ${response.statusText}`);\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      // Retry logic\n      if (retry && attempt < retry.attempts) {\n        setTimeout(() => {\n          sendWebhook(entry, attempt + 1).catch(retryError => {\n            console.error(`Webhook retry ${attempt + 1} failed:`, retryError);\n          });\n        }, retry.delay * attempt);\n        return;\n      }\n\n      // Fallback to console if webhook fails (avoid infinite loops)\n      console.error(`Failed to send log to webhook after ${attempt} attempts:`, errorMessage);\n    }\n  };\n\n  return {\n    name: 'webhook',\n    minLevel,\n    enabled: true,\n    output: async (entry: LogEntry) => {\n      // Don't await to avoid blocking log writing\n      sendWebhook(entry).catch(error => {\n        console.error('Webhook channel error:', error);\n      });\n    },\n  };\n}\n",
    "import type { LogChannel, LogLevel } from '../@types/logger.types';\nimport { type ConsoleChannelConfig, createConsoleChannel } from './console-channel';\nimport { createKVLogChannel, type KVLogChannelConfig } from './kv-channel';\nimport { createWebhookChannel, type WebhookChannelConfig } from './webhook-channel';\n\n/**\n * Configuration for different channel types\n */\nexport type ChannelConfig = {\n  console: {\n    type: 'console';\n    minLevel: LogLevel;\n    config?: ConsoleChannelConfig;\n  };\n  webhook: {\n    type: 'webhook';\n    minLevel: LogLevel;\n    config: WebhookChannelConfig;\n  };\n  kv: {\n    type: 'kv';\n    minLevel: LogLevel;\n    config: KVLogChannelConfig;\n  };\n};\n\n/**\n * Factory function for creating channels\n */\nexport type ChannelFactory<T extends keyof ChannelConfig> = (minLevel: LogLevel, config: ChannelConfig[T]['config']) => LogChannel;\n\n/**\n * Registry of available channel factories\n */\nexport const ChannelRegistry: Record<keyof ChannelConfig, ChannelFactory<any>> = {\n  console: (minLevel: LogLevel, config?: ConsoleChannelConfig) => createConsoleChannel(minLevel, config),\n\n  webhook: (minLevel: LogLevel, config: WebhookChannelConfig) => createWebhookChannel(config, minLevel),\n\n  kv: (minLevel: LogLevel, config: KVLogChannelConfig) => createKVLogChannel(config, minLevel),\n};\n\n/**\n * Situation-based channel configuration\n */\nexport interface SituationConfig {\n  /** Default channels for general logging */\n  default: Array<ChannelConfig[keyof ChannelConfig]>;\n  /** Channels for development environment */\n  development?: Array<ChannelConfig[keyof ChannelConfig]>;\n  /** Channels for production environment */\n  production?: Array<ChannelConfig[keyof ChannelConfig]>;\n  /** Channels for specific situations or contexts */\n  situations?: {\n    [situationName: string]: Array<ChannelConfig[keyof ChannelConfig]>;\n  };\n}\n\n/**\n * Creates channels based on configuration\n */\nexport function createChannelsFromConfig(configs: Array<ChannelConfig[keyof ChannelConfig]>): LogChannel[] {\n  return configs.map(channelConfig => {\n    const factory = ChannelRegistry[channelConfig.type];\n    if (!factory) {\n      throw new Error(`Unknown channel type: ${channelConfig.type}`);\n    }\n    return factory(channelConfig.minLevel, channelConfig.config);\n  });\n}\n\n/**\n * Gets appropriate channel configuration based on environment and situation\n */\nexport function getChannelConfigForSituation(situationConfig: SituationConfig, environment: 'development' | 'production' | 'default' = 'default', situation?: string): Array<ChannelConfig[keyof ChannelConfig]> {\n  // Check for specific situation first\n  if (situation && situationConfig.situations?.[situation]) {\n    return situationConfig.situations[situation];\n  }\n\n  // Check for environment-specific config\n  if (environment !== 'default' && situationConfig[environment]) {\n    return situationConfig[environment];\n  }\n\n  // Fall back to default\n  return situationConfig.default;\n}\n",
    "import type { LoggerConfig, LogLevel } from './@types/logger.types';\nimport { createChannelsFromConfig, getChannelConfigForSituation, type SituationConfig } from './channels/registry';\n\n// RFC 5424 log level hierarchy (higher number = higher severity)\nexport const LOG_LEVELS: Record<LogLevel, number> = {\n  emergency: 7,\n  alert: 6,\n  critical: 5,\n  error: 4,\n  warning: 3,\n  notice: 2,\n  info: 1,\n  debug: 0,\n} as const;\n\n/**\n * Check if a log level should be logged based on minimum level threshold\n */\nexport function shouldLog(level: LogLevel, minLevel: LogLevel): boolean {\n  return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];\n}\n\n/**\n * Safe environment variable access for different runtimes\n */\nfunction getEnvVar(name: string): string | undefined {\n  // Cloudflare Workers environment\n  // biome-ignore lint/suspicious/noExplicitAny: acceptable\n  if (typeof globalThis !== 'undefined' && (globalThis as any).ENVIRONMENT) {\n    // biome-ignore lint/suspicious/noExplicitAny: acceptable\n    return (globalThis as any).ENVIRONMENT[name];\n  }\n\n  // Vite environment (browser/SSR)\n  // biome-ignore lint/suspicious/noExplicitAny: acceptable\n  if (typeof import.meta !== 'undefined' && (import.meta as any).env) {\n    // biome-ignore lint/suspicious/noExplicitAny: acceptable\n    return (import.meta as any).env[name];\n  }\n\n  // Node.js environment\n  if (typeof process !== 'undefined' && process.env) {\n    return process.env[name];\n  }\n\n  return undefined;\n}\n\n/**\n * Runtime environment detection\n */\nexport function isCloudflareWorker(): boolean {\n  return typeof caches !== 'undefined' && typeof navigator === 'undefined';\n}\n\nexport function isDevelopment(): boolean {\n  const nodeEnv = getEnvVar('NODE_ENV');\n  return nodeEnv === 'development' || (!nodeEnv && !isCloudflareWorker());\n}\n\nexport function isProduction(): boolean {\n  return getEnvVar('NODE_ENV') === 'production';\n}\n\n/**\n * Default channel configurations for different environments\n */\nexport const DEFAULT_CHANNEL_CONFIG: SituationConfig = {\n  default: [\n    {\n      type: 'console',\n      minLevel: 'info',\n      config: { prettyPrint: false },\n    },\n  ],\n  development: [\n    {\n      type: 'console',\n      minLevel: 'debug',\n      config: { prettyPrint: true, useLogLevelMethods: true },\n    },\n  ],\n  production: [\n    {\n      type: 'console',\n      minLevel: 'warning',\n      config: { prettyPrint: false },\n    },\n  ],\n  situations: {\n    'cloudflare-worker': [\n      {\n        type: 'console',\n        minLevel: 'info',\n        config: { prettyPrint: false },\n      },\n    ],\n    'with-webhook': [\n      {\n        type: 'console',\n        minLevel: 'info',\n        config: { prettyPrint: false },\n      },\n      {\n        type: 'webhook',\n        minLevel: 'error',\n        config: {\n          webhookUrl: '', // Will be populated from environment\n          timeout: 5000,\n          retry: { attempts: 3, delay: 1000 },\n        },\n      },\n    ],\n  },\n};\n\n/**\n * Create environment-specific logger configuration\n */\nexport function createLoggerConfig(): LoggerConfig {\n  const environment = isDevelopment() ? 'development' : isProduction() ? 'production' : 'default';\n  const debugEnabled = getEnvVar('DEBUG') === 'true';\n  const webhookUrl = getEnvVar('LOG_WEBHOOK_URL');\n\n  // Determine situation\n  let situation: string | undefined;\n  if (isCloudflareWorker()) {\n    situation = webhookUrl ? 'with-webhook' : 'cloudflare-worker';\n  } else if (webhookUrl) {\n    situation = 'with-webhook';\n  }\n\n  // Get base channel configuration\n  let channelConfigs = getChannelConfigForSituation(\n    DEFAULT_CHANNEL_CONFIG,\n    environment,\n    situation\n  );\n\n  // Adjust console level for debug mode in development\n  if (isDevelopment() && debugEnabled) {\n    channelConfigs = channelConfigs.map(config => {\n      if (config.type === 'console') {\n        return {\n          ...config,\n          minLevel: 'debug' as LogLevel,\n        };\n      }\n      return config;\n    });\n  }\n\n  // Populate webhook URL if needed\n  if (webhookUrl) {\n    channelConfigs = channelConfigs.map(config => {\n      if (config.type === 'webhook' && config.config) {\n        return {\n          ...config,\n          config: {\n            ...config.config,\n            webhookUrl,\n          },\n        };\n      }\n      return config;\n    });\n  }\n\n  const channels = createChannelsFromConfig(channelConfigs);\n\n  return {\n    defaultLevel: isDevelopment() && debugEnabled ? 'debug' :\n      isProduction() ? 'warning' : 'info',\n    channels,\n    enableSanitization: true,\n  };\n}\n\n/**\n * Create logger configuration with KV storage support\n */\nexport function createLoggerConfigWithKV(kv: KVNamespace): LoggerConfig {\n  const baseConfig = createLoggerConfig();\n\n  // KV storage configuration by environment\n  const kvConfig = {\n    production: { logsLimit: 500, logsTrigger: 750 },\n    development: { logsLimit: 100, logsTrigger: 150 },\n  } as const;\n\n  const environment = isDevelopment() ? 'development' : 'production';\n  const kvSettings = kvConfig[environment];\n\n  // Add KV channel\n  const kvChannelConfig = {\n    type: 'kv' as const,\n    minLevel: isDevelopment() ? baseConfig.defaultLevel : 'debug' as LogLevel,\n    config: {\n      kv,\n      ...kvSettings,\n    },\n  };\n\n  const kvChannels = createChannelsFromConfig([kvChannelConfig]);\n\n  return {\n    ...baseConfig,\n    channels: [...baseConfig.channels, ...kvChannels],\n  };\n}\n\n/**\n * Create custom logger configuration with specific channel setup\n */\nexport function createCustomLoggerConfig(\n  situationConfig: SituationConfig,\n  environment: 'development' | 'production' | 'default' = 'default',\n  situation?: string\n): LoggerConfig {\n  const channelConfigs = getChannelConfigForSituation(situationConfig, environment, situation);\n  const channels = createChannelsFromConfig(channelConfigs);\n\n  return {\n    defaultLevel: environment === 'production' ? 'warning' : 'info',\n    channels,\n    enableSanitization: true,\n  };\n}\n",
    "/** biome-ignore-all lint/suspicious/noExplicitAny: acceptable */\nimport type { BaseLogParams, LogEntry, LoggerConfig, LogLevel, LogParams } from './@types/logger.types';\nimport { createLoggerConfig, shouldLog } from './logger.config';\n\ntype LogMessage = string | BaseLogParams;\ntype LogArgs = [LogMessage, ...any[]];\n\n// Global logger configuration\nlet loggerConfig: LoggerConfig = createLoggerConfig();\n\n/**\n * Sanitizes log parameters by removing sensitive fields\n */\nfunction sanitizeLogParams(params: LogParams): LogParams {\n  if (!loggerConfig.enableSanitization) {\n    return params;\n  }\n\n  // biome-ignore lint/correctness/noUnusedVariables: intentional\n  const { password, token, secret, apiKey, sessionToken, bearerToken, refreshToken, ...sanitized } = params as LogParams & {\n    password?: unknown;\n    token?: unknown;\n    secret?: unknown;\n    apiKey?: unknown;\n    sessionToken?: unknown;\n    bearerToken?: unknown;\n    refreshToken?: unknown;\n  };\n  return sanitized;\n}\n\n/**\n * Formats log arguments similar to diary's approach\n */\nfunction formatLogArgs(args: LogArgs): BaseLogParams {\n  const [message, ...rest] = args;\n\n  if (typeof message === 'object' && message !== null) {\n    return { ...message, ...(rest.length > 0 ? { args: rest } : {}) } as BaseLogParams;\n  }\n\n  return { event: String(message), ...(rest.length > 0 ? { args: rest } : {}) } as BaseLogParams;\n}\n\n/**\n * Creates a structured log entry\n */\nfunction createLogEntry(params: LogParams): LogEntry {\n  const sanitizedParams = sanitizeLogParams(params);\n  return {\n    ...sanitizedParams,\n    level: (sanitizedParams.level || loggerConfig.defaultLevel) as LogLevel,\n    timestamp: new Date().toISOString(),\n  } as LogEntry;\n}\n\n/**\n * Writes log entry to all enabled channels that meet the level threshold\n */\nasync function writeToChannels(entry: LogEntry): Promise<void> {\n  const writePromises = loggerConfig.channels\n    .filter(channel => channel.enabled && shouldLog(entry.level, channel.minLevel))\n    .map(channel => {\n      try {\n        const result = channel.output(entry);\n        return result instanceof Promise ? result : Promise.resolve();\n      } catch (error) {\n        // Prevent logging failures from breaking the application\n        console.error(`Failed to write to channel ${channel.name}:`, error);\n        return Promise.resolve();\n      }\n    });\n\n  await Promise.allSettled(writePromises);\n}\n\n/**\n * Enhanced Structured Logging Utility with Multi-Channel Support\n *\n * Features:\n * - RFC 5424 log levels with proper hierarchy\n * - Multi-channel output (console, webhooks, Slack, etc.)\n * - Environment-specific configuration\n * - Flexible API supporting both structured objects and diary-style strings\n * - Security sanitization for sensitive data\n * - Optimized for Cloudflare Workers deployment\n *\n * @see {@link https://developers.cloudflare.com/workers/observability/logs/workers-logs/}\n * @see {@link https://tools.ietf.org/html/rfc5424}\n */\nexport const logger = {\n  /**\n   * Configure the logger with custom settings\n   */\n  configure(config: Partial<LoggerConfig>) {\n    loggerConfig = { ...loggerConfig, ...config };\n  },\n\n  /**\n   * Get current logger configuration\n   */\n  getConfig(): LoggerConfig {\n    return { ...loggerConfig };\n  },\n\n  /**\n   * Core logging method that writes to all enabled channels\n   */\n  async log(params: LogParams): Promise<void> {\n    const entry = createLogEntry(params);\n    await writeToChannels(entry);\n  },\n\n  // RFC 5424 log levels in descending order of severity\n\n  /**\n   * System is unusable - emergency level\n   */\n  emergency(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'emergency' });\n  },\n\n  /**\n   * Action must be taken immediately - alert level\n   */\n  alert(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'alert' });\n  },\n\n  /**\n   * Critical conditions - critical level\n   */\n  critical(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'critical' });\n  },\n\n  /**\n   * Error conditions - error level\n   */\n  error(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'error' });\n  },\n\n  /**\n   * Warning conditions - warning level\n   */\n  warning(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'warning' });\n  },\n\n  /**\n   * Normal but significant conditions - notice level\n   */\n  notice(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'notice' });\n  },\n\n  /**\n   * Informational messages - info level\n   */\n  info(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'info' });\n  },\n\n  /**\n   * Debug-level messages - debug level\n   */\n  debug(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'debug' });\n  },\n\n  // Legacy aliases for backward compatibility\n  warn(...args: LogArgs): Promise<void> {\n    return this.warning(...args);\n  },\n};\n"
  ],
  "mappings": "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",
  "debugId": "77EC84DBCF896EB064756E2164756E21",
  "names": []
}