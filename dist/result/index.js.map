{"version":3,"file":"index.js","sources":["../../src/result/@types/result.types.ts","../../src/result/core/result.ts","../../src/result/core/error.ts","../../src/result/http/headers.ts","../../src/result/http/middleware.ts","../../src/result/http/response.ts","../../src/result/validation/form.ts"],"sourcesContent":["/**\n * Result System - Direct value or error pattern\n *\n * This simplified approach returns either the actual value T or an AppError,\n * eliminating the need for success flags and data wrapping.\n */\n\n/**\n * A Result is either a successful value T or an AppError\n * The discriminator is the presence of the 'message' property and absence of any T properties\n */\nexport type Result<T, E = AppError> = T | E;\n\n/**\n * Application error structure\n * Must have 'message' property to distinguish from success values\n */\nexport interface AppError {\n  readonly message: string;\n  readonly details?: Record<string, unknown>;\n  readonly cause?: Error | unknown;\n  readonly code?: string;\n  readonly status?: number;\n}\n\n/**\n * Response metadata for HTTP layer (status and headers only)\n */\nexport interface ResponseMeta {\n  status?: number;\n  headers?: HeadersInit;\n}\n\n/**\n * Response callbacks for side effects (toasts, redirects, etc.)\n */\nexport type RespondCallbacks = (() => void | Promise<void>)[];\n\n/**\n * Toast configuration\n */\nexport interface ToastConfig {\n  message: string;\n  type: 'success' | 'error' | 'warning' | 'info';\n  duration?: number;\n}\n\n/**\n * Field errors extracted from AppError details\n */\nexport type FieldErrors = Record<string, string> & {\n  form?: string; // General form-level error\n};\n\n/**\n * Type guard to check if a value is an AppError\n * An AppError must have a 'message' string property and should not have\n * typical success object properties\n */\nexport function isAppError(value: unknown): value is AppError {\n  if (value == null || typeof value !== 'object' || !('message' in value) || typeof (value as any).message !== 'string') {\n    return false;\n  }\n\n  // Check if it has the structure of an AppError\n  const obj = value as any;\n\n  // Must have message\n  if (!obj.message) return false;\n\n  // Optional properties should be the right types if present\n  if (obj.details !== undefined && (typeof obj.details !== 'object' || obj.details === null)) {\n    return false;\n  }\n\n  if (obj.code !== undefined && typeof obj.code !== 'string') {\n    return false;\n  }\n\n  if (obj.status !== undefined && typeof obj.status !== 'number') {\n    return false;\n  }\n\n  // If it has other properties that look like success data, it's probably not an error\n  // This is a heuristic - we assume AppErrors won't have arbitrary data properties\n  const allowedErrorProperties = new Set(['message', 'details', 'cause', 'code', 'status']);\n  const hasNonErrorProperties = Object.keys(obj).some(key => !allowedErrorProperties.has(key));\n\n  if (hasNonErrorProperties) {\n    return false;\n  }\n\n  return true;\n}\n","import type { AppError, Result } from '../@types/result.types';\nimport { isAppError } from '../@types/result.types';\n\n/**\n * Return a successful value directly\n * This is essentially a no-op but provides semantic clarity\n */\nexport function ok<T>(value: T): T {\n  return value;\n}\n\n/**\n * Create an AppError\n */\nexport function err(\n  message: string,\n  details?: Record<string, unknown>,\n  options?: {\n    cause?: Error | unknown;\n    code?: string;\n    status?: number;\n  }\n): AppError {\n  return {\n    message,\n    details,\n    cause: options?.cause,\n    code: options?.code,\n    status: options?.status,\n  };\n}\n\n/**\n * Check if a result is an error\n */\nexport function isError<T>(result: Result<T>): result is AppError {\n  return isAppError(result);\n}\n\n/**\n * Check if a result is successful (not an error)\n */\nexport function isOk<T>(result: Result<T>): result is T {\n  return !isAppError(result);\n}\n\n/**\n * Get the data from a result, or undefined if it's an error\n */\nexport function getData<T>(result: Result<T>): T | undefined {\n  return isError(result) ? undefined : result;\n}\n\n/**\n * Get the error from a result, or undefined if it's successful\n */\nexport function getError<T>(result: Result<T>): AppError | undefined {\n  return isError(result) ? result : undefined;\n}\n\n/**\n * Unwrap a result, throwing if it's an error\n */\nexport function unwrap<T>(result: Result<T>): T {\n  if (isError(result)) {\n    throw new Error(result.message);\n  }\n  return result;\n}\n\n/**\n * Unwrap a result or return a default value if it's an error\n */\nexport function unwrapOr<T>(result: Result<T>, defaultValue: T): T {\n  return isError(result) ? defaultValue : result;\n}\n\n/**\n * Map a successful result to a new value\n */\nexport function map<T, U>(result: Result<T>, fn: (value: T) => U): Result<U> {\n  return isError(result) ? result : fn(result);\n}\n\n/**\n * Map an error result to a new error\n */\nexport function mapError<T>(result: Result<T>, fn: (error: AppError) => AppError): Result<T> {\n  return isError(result) ? fn(result) : result;\n}\n\n/**\n * Chain operations on successful results\n */\nexport function andThen<T, U>(result: Result<T>, fn: (value: T) => Result<U>): Result<U> {\n  return isError(result) ? result : fn(result);\n}\n\n/**\n * Provide an alternative result if the first is an error\n */\nexport function orElse<T>(result: Result<T>, fn: () => Result<T>): Result<T> {\n  return isError(result) ? fn() : result;\n}\n\n/**\n * Convert a promise that might throw into a Result\n */\nexport async function tryCatch<T>(fn: () => Promise<T>, errorMessage?: string): Promise<Result<T>> {\n  try {\n    return await fn();\n  } catch (error) {\n    return err(errorMessage || 'Operation failed', undefined, { cause: error });\n  }\n}\n\n/**\n * Combine multiple results - returns first error or all values\n */\nexport function combine<T extends readonly Result<any>[]>(results: T): Result<{ [K in keyof T]: T[K] extends Result<infer U> ? U : never }> {\n  const values: any[] = [];\n\n  for (const result of results) {\n    if (isError(result)) {\n      return result;\n    }\n    values.push(result);\n  }\n\n  return values as any;\n}\n\n/**\n * Combine results into an object\n */\nexport function combineObject<T extends Record<string, Result<any>>>(results: T): Result<{ [K in keyof T]: T[K] extends Result<infer U> ? U : never }> {\n  const values: any = {};\n\n  for (const [key, result] of Object.entries(results)) {\n    if (isError(result)) {\n      return result;\n    }\n    values[key] = result;\n  }\n\n  return values;\n}\n","import { ValiError } from 'valibot';\nimport type { AppError, FieldErrors } from '../@types/result.types';\nimport { err } from './result';\n\n/**\n * Transform unknown error to AppError\n */\nexport function toAppError(error: unknown): AppError {\n  // Already an AppError\n  if (error && typeof error === 'object' && 'message' in error && typeof (error as any).message === 'string') {\n    const e = error as any;\n    return {\n      message: e.message,\n      details: e.details,\n      cause: e.cause,\n      code: e.code,\n      status: e.status,\n    };\n  }\n\n  // Standard Error\n  if (error instanceof Error) {\n    return err(error.message, undefined, { cause: error });\n  }\n\n  // String error\n  if (typeof error === 'string') {\n    return err(error);\n  }\n\n  // Unknown\n  return err('Unknown error occurred', { error });\n}\n\n/**\n * Transform any error into an AppError (including validation errors)\n */\nexport function transformError(error: unknown): AppError {\n  // Handle Valibot validation errors\n  if (error instanceof ValiError) {\n    const fieldErrors: Record<string, string> = {};\n\n    for (const issue of error.issues || []) {\n      const field = issue.path?.length > 0 ? String(issue.path[0].key) : 'form';\n\n      // Only keep the first error per field for simplicity\n      if (!fieldErrors[field]) {\n        fieldErrors[field] = issue.message;\n      }\n    }\n\n    return err('Validation failed', fieldErrors, { cause: error });\n  }\n\n  return toAppError(error);\n}\n\n/**\n * Extract field errors from AppError for form display\n */\nexport function extractFieldErrors(error: AppError | undefined | null): FieldErrors {\n  if (!error) {\n    return {};\n  }\n\n  const result: FieldErrors = {};\n\n  // Add the main message as a form-level error if no field-specific errors exist\n  if (error.message && (!error.details || Object.keys(error.details).length === 0)) {\n    result.form = error.message;\n  }\n\n  // Extract field-specific errors from details\n  if (error.details && typeof error.details === 'object') {\n    for (const [field, value] of Object.entries(error.details)) {\n      // Convert the value to a string for display\n      result[field] = typeof value === 'string' ? value : String(value);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Get a flattened string summary of an error for logging\n */\nexport function flattenError(error: AppError | unknown): string {\n  if (!error) {\n    return 'Unknown error';\n  }\n\n  // Handle AppError\n  if (typeof error === 'object' && 'message' in error) {\n    const appError = error as AppError;\n\n    // If there are field-specific errors in details, include them\n    if (appError.details && typeof appError.details === 'object') {\n      const fieldErrors = Object.entries(appError.details)\n        .filter(([_, value]) => typeof value === 'string' || typeof value === 'number')\n        .map(([field, message]) => `${field}: ${message}`)\n        .join('; ');\n\n      if (fieldErrors) {\n        return `${appError.message} - ${fieldErrors}`;\n      }\n    }\n\n    return appError.message;\n  }\n\n  // Fallback for non-AppError types\n  return String(error);\n}\n\n/**\n * Create a validation error with field-specific messages\n */\nexport function validationError(fieldErrors: Record<string, string>, message = 'Validation failed'): AppError {\n  return err(message, fieldErrors, { code: 'VALIDATION_ERROR', status: 400 });\n}\n\n/**\n * Create a not found error\n */\nexport function notFoundError(resource: string, identifier?: string | number): AppError {\n  const message = identifier ? `${resource} not found: ${identifier}` : `${resource} not found`;\n\n  return err(message, { resource, identifier }, { code: 'NOT_FOUND', status: 404 });\n}\n\n/**\n * Create an unauthorized error\n */\nexport function unauthorizedError(message = 'Unauthorized'): AppError {\n  return err(message, undefined, { code: 'UNAUTHORIZED', status: 401 });\n}\n\n/**\n * Create a forbidden error\n */\nexport function forbiddenError(message = 'Forbidden'): AppError {\n  return err(message, undefined, { code: 'FORBIDDEN', status: 403 });\n}\n\n/**\n * Create a bad request error\n */\nexport function badRequestError(message: string, details?: Record<string, unknown>): AppError {\n  return err(message, details, { code: 'BAD_REQUEST', status: 400 });\n}\n\n/**\n * Create an internal server error\n */\nexport function serverError(message = 'Internal server error', cause?: Error): AppError {\n  return err(message, undefined, { cause, code: 'INTERNAL_ERROR', status: 500 });\n}\n\n/**\n * Check if an error is a system error (5xx status codes)\n * System errors should typically be thrown to error boundaries\n */\nexport function isSystemError(error: AppError): boolean {\n  return (error.status ?? 0) >= 500;\n}\n\n/**\n * Check if an error is a user error (4xx status codes or no status)\n * User errors should be displayed in the UI (forms, toasts, etc.)\n */\nexport function isUserError(error: AppError): boolean {\n  const status = error.status ?? 400; // Default to user error if no status\n  return status < 500;\n}\n\n/**\n * Create a service unavailable error (503)\n * Use for external service failures, database connection issues, etc.\n */\nexport function serviceUnavailableError(message = 'Service temporarily unavailable', cause?: Error): AppError {\n  return err(message, undefined, { cause, code: 'SERVICE_UNAVAILABLE', status: 503 });\n}\n\n/**\n * Create a configuration error (500)\n * Use for missing or invalid application configuration\n */\nexport function configError(message: string, details?: Record<string, unknown>): AppError {\n  return err(message, details, { code: 'CONFIG_ERROR', status: 500 });\n}\n","const HEADER_NAMES = Object.freeze([\n  'CF-Connecting-IP',\n  'X-Azure-ClientIP' /** Azure Front Door */,\n  'X-Client-IP',\n  'X-Forwarded-For',\n  'HTTP-X-Forwarded-For',\n  'Fly-Client-IP',\n  'Fastly-Client-Ip',\n  'True-Client-Ip',\n  'X-Real-IP',\n  'X-Cluster-Client-IP',\n  'X-Forwarded',\n  'Forwarded-For',\n  'Forwarded',\n  'DO-Connecting-IP' /** Digital ocean app platform */,\n  'oxygen-buyer-ip' /** Shopify oxygen platform */,\n] as const);\n\n/**\n * Merge multiple headers objects into one (uses set so headers are overridden)\n */\nexport function mergeHeaders(...headers: Array<ResponseInit['headers'] | null | undefined>) {\n  const merged = new Headers();\n  for (const header of headers) {\n    if (!header) continue;\n    const h = new Headers(header);\n    h.forEach((value, key) => {\n      merged.set(key, value);\n    });\n  }\n  return merged;\n}\n\n/**\n * Combine multiple header objects into one (uses append so headers are not overridden)\n */\nexport function combineHeaders(...headers: Array<ResponseInit['headers'] | null | undefined>) {\n  const combined = new Headers();\n  for (const header of headers) {\n    if (!header) continue;\n    const h = new Headers(header);\n    h.forEach((value, key) => {\n      combined.append(key, value);\n    });\n  }\n  return combined;\n}\n\n/**\n * Extracts the client IP address from request headers\n *\n * Checks multiple headers in priority order (Cloudflare, Azure, etc.)\n * and validates IP addresses to ensure they're legitimate\n *\n * @param requestOrHeaders - Request object or Headers instance\n * @returns Valid client IP address or null if none found\n *\n * @example\n * ```ts\n * const clientIP = getClientIP(request);\n * if (clientIP) {\n *   logger.info('client_request', { ip: clientIP });\n * }\n * ```\n */\nexport function getClientIP(requestOrHeaders: Request | Headers): string | null {\n  const headers = requestOrHeaders instanceof Request ? requestOrHeaders.headers : requestOrHeaders;\n\n  const ipAddress = HEADER_NAMES.flatMap(headerName => {\n    const value = headers.get(headerName);\n    if (headerName === 'Forwarded') {\n      return parseForwardedHeader(value);\n    }\n    if (!value?.includes(',')) return value;\n    return value.split(',').map(ip => ip.trim());\n  }).find(ip => {\n    if (ip === null) return false;\n    return isValidIP(ip);\n  });\n\n  return ipAddress ?? null;\n}\n\n/**\n * Validates if a string is a valid IPv4 or IPv6 address\n * Works natively on Cloudflare Workers without external dependencies\n */\nfunction isValidIP(ip: string): boolean {\n  if (!ip) return false;\n\n  // IPv4 validation (supports 0-255 for each octet)\n  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n  if (ipv4Regex.test(ip)) return true;\n\n  // IPv6 validation (supports full, compressed, and IPv4-mapped formats)\n  const ipv6Regex =\n    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\n  if (ipv6Regex.test(ip)) return true;\n\n  return false;\n}\n\n/**\n * Parses the RFC 7239 Forwarded header to extract client IP\n * Format: Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43\n */\nfunction parseForwardedHeader(value: string | null): string | null {\n  if (!value) return null;\n  for (const part of value.split(';')) {\n    const trimmed = part.trim();\n    if (trimmed.startsWith('for=')) {\n      // Remove \"for=\" prefix and clean up quotes/brackets\n      let ip = trimmed.slice(4);\n      // Remove quotes if present\n      ip = ip.replace(/^[\"']|[\"']$/g, '');\n      // Remove IPv6 brackets if present\n      ip = ip.replace(/^\\[|\\]$/g, '');\n      return ip;\n    }\n  }\n  return null;\n}\n","import type { AppError } from '../@types/result.types';\nimport { err } from '../core/result';\n\n/**\n * Middleware response function for early termination with error\n * Returns a formatted Response object that follows the standard error shape\n */\nexport function middlewareFailure<E = AppError>(error: E, options?: { status?: number; headers?: HeadersInit }): Response {\n  const responseData = typeof error === 'object' && error && 'message' in error ? (error as AppError) : err(String(error));\n  const status = options?.status ?? 403;\n  const headers = new Headers(options?.headers);\n\n  if (!headers.has('Content-Type')) {\n    headers.set('Content-Type', 'application/json');\n  }\n\n  return new Response(JSON.stringify(responseData), { status, headers });\n}\n\n/**\n * Middleware helper to pass through a response with modified headers\n * Preserves the original response body and status while allowing header modifications\n * Commonly used for adding cookies, cors headers, or other response metadata\n */\nexport function middlewarePassthrough(response: Response, headerModifications?: { append?: Record<string, string>; set?: Record<string, string> }): Response {\n  if (!headerModifications) {\n    return response;\n  }\n\n  // Create new headers from original response\n  const headers = new Headers(response.headers);\n  if (headerModifications.set) {\n    Object.entries(headerModifications.set).forEach(([key, value]) => {\n      headers.set(key, value);\n    });\n  }\n\n  if (headerModifications.append) {\n    Object.entries(headerModifications.append).forEach(([key, value]) => {\n      headers.append(key, value);\n    });\n  }\n\n  // Return new response with modified headers\n  return new Response(response.body, { status: response.status, statusText: response.statusText, headers });\n}\n","import { data, redirect } from 'react-router';\nimport type { AppError, RespondCallbacks, ResponseMeta, Result } from '../@types/result.types';\nimport { isError } from '../core/result';\n\n/**\n * Send an HTTP response with optional metadata and callbacks\n * Automatically determines status based on whether result is an error\n * Executes callbacks after creating the response for side effects (toasts, logging, etc.)\n */\nfunction respond<T>(result: Result<T>, meta?: ResponseMeta, ...callbacks: RespondCallbacks) {\n  const defaultStatus = isError(result) ? 400 : 200;\n  const status = meta?.status ?? defaultStatus;\n\n  // Execute callbacks for side effects (toasts, logging, etc.)\n  callbacks.forEach(callback => {\n    if (callback) callback();\n  });\n\n  // Return standard response\n  return data(result, { status, headers: meta?.headers });\n}\n\n/**\n * Send a successful response\n */\nexport function respondOk<T>(value: T, meta?: ResponseMeta, ...callbacks: RespondCallbacks) {\n  return respond(value, { ...meta, status: meta?.status ?? 200 }, ...callbacks);\n}\n\n/**\n * Send an error response\n */\nexport function respondError(error: AppError, meta?: ResponseMeta, ...callbacks: RespondCallbacks) {\n  const status = meta?.status ?? error.status ?? 400;\n\n  return respond(error, { ...meta, status }, ...callbacks);\n}\n\n/**\n * Redirect with optional headers (e.g., Set-Cookie)\n * Use this for successful form submissions that require navigation\n */\nexport function respondRedirect(path: string, meta?: ResponseMeta): never {\n  throw redirect(path, { status: meta?.status ?? 302, headers: meta?.headers });\n}\n\n/**\n * Throw a system error to error boundary\n * Use for unrecoverable errors that should not be shown in forms/toasts\n */\nexport function throwSystemError(message: string, status: 500 | 503 | 502 = 500): never {\n  throw new Response(message, { status });\n}\n","import type { BaseSchema, InferOutput } from 'valibot';\nimport { safeParse } from 'valibot';\nimport type { Result } from '../@types/result.types';\nimport { err } from '../core/result';\n\n/**\n * Parse Valibot issues into an error with field-specific details\n */\nfunction parseValibotIssues(issues: any[]): Result<never> {\n  if (!issues?.length) {\n    return err('Validation failed');\n  }\n\n  const fieldErrors: Record<string, string> = {};\n\n  for (const issue of issues) {\n    const field = issue.path?.length > 0 ? String(issue.path[0].key) : 'form';\n\n    // Only keep the first error per field for simplicity\n    if (!fieldErrors[field]) {\n      fieldErrors[field] = issue.message;\n    }\n  }\n\n  return err('Validation failed', fieldErrors, {\n    code: 'VALIDATION_ERROR',\n    status: 400,\n  });\n}\n\n/**\n * Validate data against a schema, returning Result\n */\nasync function validate<S extends BaseSchema<any, any, any>>(schema: S, input: any): Promise<Result<InferOutput<S>>> {\n  const result = safeParse(schema, input);\n\n  if (result.success) {\n    return result.output;\n  }\n\n  return parseValibotIssues(result.issues);\n}\n\n/**\n * Validate form data against a schema\n */\nexport async function validateFormData<S extends BaseSchema<any, any, any>>(schema: S, requestOrFormData: Request | FormData): Promise<Result<InferOutput<S>>> {\n  const formData = requestOrFormData instanceof FormData ? requestOrFormData : await requestOrFormData.formData();\n\n  const object: Record<string, any> = {};\n\n  formData.forEach((value, key) => {\n    // Handle file uploads\n    if (value instanceof File) {\n      object[key] = value;\n    }\n    // Handle multiple values for the same key (checkboxes, etc)\n    else if (object[key]) {\n      if (Array.isArray(object[key])) {\n        object[key].push(String(value));\n      } else {\n        object[key] = [object[key], String(value)];\n      }\n    }\n    // Single value\n    else {\n      object[key] = String(value);\n    }\n  });\n\n  return validate(schema, object);\n}\n\n/**\n * Validate JSON data against a schema\n */\nexport async function validateJsonData<S extends BaseSchema<any, any, any>>(schema: S, data: any): Promise<Result<InferOutput<S>>> {\n  return validate(schema, data);\n}\n\n/**\n * Validate query parameters against a schema\n */\nexport async function validateQueryParams<S extends BaseSchema<any, any, any>>(schema: S, requestOrUrl: Request | URL | URLSearchParams): Promise<Result<InferOutput<S>>> {\n  let searchParams: URLSearchParams;\n\n  if (requestOrUrl instanceof Request) {\n    const url = new URL(requestOrUrl.url);\n    searchParams = url.searchParams;\n  } else if (requestOrUrl instanceof URL) {\n    searchParams = requestOrUrl.searchParams;\n  } else {\n    searchParams = requestOrUrl;\n  }\n\n  const object: Record<string, any> = {};\n\n  searchParams.forEach((value, key) => {\n    // Handle multiple values for the same key\n    if (object[key]) {\n      if (Array.isArray(object[key])) {\n        object[key].push(value);\n      } else {\n        object[key] = [object[key], value];\n      }\n    } else {\n      object[key] = value;\n    }\n  });\n\n  return validate(schema, object);\n}\n\n/**\n * Create a validation middleware for routes\n */\nexport function createValidationMiddleware<S extends BaseSchema<any, any, any>>(\n  schema: S,\n  options?: {\n    source?: 'form' | 'json' | 'query';\n    onError?: (error: any) => any;\n  }\n) {\n  return async (args: { request: Request; context: any }) => {\n    let result: Result<InferOutput<S>>;\n\n    switch (options?.source) {\n      case 'json': {\n        const json = await args.request.json();\n        result = await validateJsonData(schema, json);\n        break;\n      }\n      case 'query':\n        result = await validateQueryParams(schema, args.request);\n        break;\n      // case 'form':\n      default:\n        result = await validateFormData(schema, args.request);\n        break;\n    }\n\n    // Store validation result in context for route to use\n    args.context.set('validationResult', result);\n\n    // Call error handler if validation failed\n    if (options?.onError && typeof result === 'object' && 'message' in result) {\n      return options.onError(result);\n    }\n  };\n}\n"],"names":["data"],"mappings":"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"}