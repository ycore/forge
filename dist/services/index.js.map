{
  "version": 3,
  "sources": ["../../src/services/@types/cloudflare.types.ts", "../../src/services/cloudflare.ts", "../../src/services/database.ts", "../../src/logger/logger.config.ts", "../../src/logger/logger.ts", "../../src/services/environment.ts", "../../src/services/kv-store.ts", "../../src/services/origin.ts", "../../src/services/site/robots.ts", "../../src/services/site/sitemap.ts"],
  "sourcesContent": [
    "// Placeholder value for unconfigured bindings/secrets\nexport const UNCONFIGURED = 'UNCONFIGURED' as const;\nexport type Unconfigured = typeof UNCONFIGURED;\n\n// Actual binding names from Cloudflare.Env\nexport type ActualKVBindingNames = {\n  [K in keyof Cloudflare.Env]: Cloudflare.Env[K] extends KVNamespace ? K : never;\n}[keyof Cloudflare.Env];\n\nexport type ActualD1BindingNames = {\n  [K in keyof Cloudflare.Env]: Cloudflare.Env[K] extends D1Database ? K : never;\n}[keyof Cloudflare.Env];\n\nexport type ActualSecretNames = {\n  [K in keyof Cloudflare.Env]: K extends `${string}_SECRET_KEY` | `${string}_API_KEY` ? K : never;\n}[keyof Cloudflare.Env];\n\nexport type ActualEnvironmentVarNames = {\n  [K in keyof Cloudflare.Env]: Cloudflare.Env[K] extends string ? (K extends ActualSecretNames ? never : K) : never;\n}[keyof Cloudflare.Env];\n\n// Types that allow unconfigured defaults\nexport type KVBindings = ActualKVBindingNames | Unconfigured;\nexport type D1Bindings = ActualD1BindingNames | Unconfigured;\nexport type SecretBindings = ActualSecretNames | Unconfigured;\nexport type VarBindings = ActualEnvironmentVarNames | Unconfigured;\n// Legacy alias for backward compatibility\nexport type EnvironmentVarNames = ActualEnvironmentVarNames;\n",
    "import { createContext, type RouterContextProvider } from 'react-router';\n\nexport const CloudflareContext = createContext<{ env: Cloudflare.Env; ctx: ExecutionContext; cf?: RequestInitCfProperties }>({} as { env: Cloudflare.Env; ctx: ExecutionContext; cf?: RequestInitCfProperties });\n\nexport function getBindings(context: Readonly<RouterContextProvider>) {\n  return context.get(CloudflareContext).env;\n}\n\nexport function getExecutionContext(context: Readonly<RouterContextProvider>): ExecutionContext {\n  return context.get(CloudflareContext).ctx;\n}\n\nexport function getRequestProperties(context: Readonly<RouterContextProvider>): RequestInitCfProperties | undefined {\n  return context.get(CloudflareContext).cf;\n}\n\nexport function waitUntil<T>(context: Readonly<RouterContextProvider>, promise: Promise<T>) {\n  return getExecutionContext(context).waitUntil(promise);\n}\n",
    "import { drizzle } from 'drizzle-orm/d1';\nimport type { Logger as LoggerInterface } from 'drizzle-orm/logger';\nimport { createContext, type RouterContextProvider } from 'react-router';\n\nimport { logger } from '../logger/logger';\n\ntype DatabaseWithSchema<TSchema extends Record<string, unknown>> = ReturnType<typeof drizzle<TSchema>>;\n\nexport interface DatabaseConfig<TSchema extends Record<string, unknown>> {\n  binding: string;\n  schema: TSchema;\n  enableLogging?: boolean;\n}\n\n// Create typed database context\nexport const DatabaseContext = createContext<DatabaseWithSchema<Record<string, unknown>> | null>(null);\n\n/**\n * Create a typed database connection from Cloudflare environment and binding config\n */\nexport function bindDatabase<TSchema extends Record<string, unknown>>(env: Cloudflare.Env, binding: string, schema: TSchema, enableLogging = false) {\n  const d1Database = env[binding as keyof Cloudflare.Env] as D1Database;\n  const drizzleConfig: Parameters<typeof drizzle>[1] = { schema };\n  if (enableLogging) {\n    drizzleConfig.logger = new Logger();\n  }\n\n  return drizzle(d1Database, drizzleConfig);\n}\n\n/**\n * Initialize database and set it in the router context\n * Consolidates database binding and context setting in one call\n */\nexport function initDatabase<TSchema extends Record<string, unknown>>(context: Readonly<RouterContextProvider>, env: Cloudflare.Env, config: DatabaseConfig<TSchema>) {\n  const db = bindDatabase(env, config.binding, config.schema, config.enableLogging);\n  context.set(DatabaseContext, db);\n  return db;\n}\n\n/**\n * Simple database getter function following getBindings pattern\n * Extracts the typed database instance from React Router context\n * @throws Error if database context is not set\n */\nexport function getDatabase(context: Readonly<RouterContextProvider>) {\n  const db = context.get(DatabaseContext);\n  if (!db) {\n    throw new Error('Database context not found. Make sure to bind database in your worker entry point.');\n  }\n  return db;\n}\n\n/**\n * Custom Drizzle logger that integrates with the logger system\n * - Strips newlines, excessive whitespace and replaces double quotes with backticks for cleaner JSON serialization\n */\nclass Logger implements LoggerInterface {\n  logQuery(query: string, params: unknown[]): void {\n    const cleanQuery = query\n      .replace(/\\s*\\n\\s*/g, ' ')  // Remove newlines and surrounding whitespace\n      .replace(/\"/g, '`')         // Replace double quotes with backticks\n      .replace(/\\s+/g, ' ')       // Normalize multiple spaces to single space\n      .trim();\n\n    logger.debug('SQL', { query: cleanQuery, params: params.length > 0 ? params : undefined });\n  }\n}\n",
    "import type { LoggerConfig, LogLevel } from './@types/logger.types';\n\n// RFC 5424 log level hierarchy (higher number = higher severity)\nexport const LOG_LEVELS: Record<LogLevel, number> = {\n  emergency: 7,\n  alert: 6,\n  critical: 5,\n  error: 4,\n  warning: 3,\n  notice: 2,\n  info: 1,\n  debug: 0,\n} as const;\n\n/**\n * Check if a log level should be logged based on minimum level threshold\n */\nexport function shouldLog(level: LogLevel, minLevel: LogLevel): boolean {\n  return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];\n}\n\n/**\n * Get environment-specific channel options\n */\nexport function getChannelOptions(registry: 'console' | 'kv', production: boolean, baseOptions: Record<string, unknown> = {}, kv?: KVNamespace): Record<string, unknown> {\n  // Console channel environment-specific defaults\n  if (registry === 'console') {\n    const envDefaults = {\n      format: production ? 'raw' : 'json',\n      useLogLevelMethods: !production,\n    };\n    // Explicit options override environment defaults\n    return { ...envDefaults, ...baseOptions };\n  }\n\n  let options = { ...baseOptions };\n\n  // KV channel - inject KV namespace\n  if (registry === 'kv' && kv) {\n    options = { ...options, kv };\n  }\n\n  return options;\n}\n\n/**\n * Get environment-specific logger defaults\n */\nexport function getLoggerDefaults(config: LoggerConfig, production: boolean): { defaultLevel: LogLevel; enableSanitization: boolean } {\n  const defaults = production ? config.defaults?.production : config.defaults?.development;\n\n  return {\n    defaultLevel: defaults?.defaultLevel || (production ? 'warning' : 'info'),\n    enableSanitization: defaults?.enableSanitization ?? true,\n  };\n}\n\n/**\n * Default logger configuration\n */\nexport const defaultLoggerConfig: LoggerConfig = {\n  init: [\n    {\n      production: false,\n      channel: 'console',\n      level: 'debug',\n    },\n    {\n      production: false,\n      channel: 'console',\n      level: 'warning',\n    },\n    {\n      production: false,\n      channel: 'kv',\n      level: 'info',\n    },\n    {\n      production: true,\n      channel: 'kv',\n      level: 'warning',\n    },\n  ],\n  channels: {\n    console: {\n      registry: 'console',\n      options: {}, // Will be populated with environment defaults\n    },\n    kv: {\n      registry: 'kv',\n      options: {\n        logsLimit: 500,\n        logsTrigger: 750,\n      },\n    },\n  },\n  defaults: {\n    development: {\n      defaultLevel: 'debug',\n      enableSanitization: true,\n    },\n    production: {\n      defaultLevel: 'warning',\n      enableSanitization: true,\n    },\n  },\n};\n",
    "/** biome-ignore-all lint/suspicious/noExplicitAny: acceptable */\nimport type { BaseLogParams, InternalLoggerConfig, LogArgs, LogEntry, Logger, LoggerConfig, LogLevel, LogParams } from './@types/logger.types';\nimport { shouldLog } from './logger.config';\nimport { createInternalLoggerConfig } from './logger.helpers';\n\nexport interface LoggerState {\n  initialized: boolean;\n  wasInitializedHere?: boolean;\n}\n\n// Global logger configuration\nlet loggerConfig: InternalLoggerConfig = {\n  defaultLevel: 'info',\n  channels: [],\n  enableSanitization: true,\n};\n\n/**\n * Sanitizes log parameters by removing sensitive fields\n */\nfunction sanitizeLogParams(params: LogParams): LogParams {\n  if (!loggerConfig.enableSanitization) {\n    return params;\n  }\n\n  // biome-ignore lint/correctness/noUnusedVariables: intentional\n  const { password, token, secret, apiKey, sessionToken, bearerToken, refreshToken, ...sanitized } = params as LogParams & {\n    password?: unknown;\n    token?: unknown;\n    secret?: unknown;\n    apiKey?: unknown;\n    sessionToken?: unknown;\n    bearerToken?: unknown;\n    refreshToken?: unknown;\n  };\n  return sanitized;\n}\n\n/**\n * Formats log arguments similar to diary's approach\n */\nfunction formatLogArgs(args: LogArgs): BaseLogParams {\n  const [message, ...rest] = args;\n\n  if (typeof message === 'object' && message !== null) {\n    return { ...message, ...(rest.length > 0 ? { args: rest } : {}) } as BaseLogParams;\n  }\n\n  return { event: String(message), ...(rest.length > 0 ? { args: rest } : {}) } as BaseLogParams;\n}\n\n/**\n * Creates a structured log entry\n */\nfunction createLogEntry(params: LogParams): LogEntry {\n  const sanitizedParams = sanitizeLogParams(params);\n  return {\n    ...sanitizedParams,\n    level: (sanitizedParams.level || loggerConfig.defaultLevel) as LogLevel,\n    timestamp: new Date().toISOString(),\n  } as LogEntry;\n}\n\n/**\n * Writes log entry to all enabled channels that meet the level threshold\n * Logging failures are silently ignored to prevent disrupting application flow\n */\nasync function writeToChannels(entry: LogEntry): Promise<void> {\n  const writePromises = loggerConfig.channels\n    .filter(channel => channel.enabled && shouldLog(entry.level, channel.minLevel))\n    .map(channel => {\n      try {\n        const result = channel.output(entry);\n        return result instanceof Promise ? result : Promise.resolve();\n      } catch (_error) {\n        // Silently ignore logging failures to prevent disrupting application flow\n        return Promise.resolve();\n      }\n    });\n\n  await Promise.allSettled(writePromises);\n}\n\n// Production optimizations are handled by the Vite logger plugin\n// These runtime checks will be replaced with static values during build\n\n/**\n * Enhanced Structured Logging Utility with Multi-Channel Support\n *\n * Features:\n * - RFC 5424 log levels with proper hierarchy\n * - Multi-channel output (console, webhooks, Slack, etc.)\n * - Environment-specific configuration\n * - Flexible API supporting both structured objects and diary-style strings\n * - Security sanitization for sensitive data\n * - Production build optimization with dead code elimination\n * - Optimized for Cloudflare Workers deployment\n * - **Error-safe**: Never throws or contributes to error flow - logging failures are silently ignored\n *\n * Usage patterns:\n * - Critical logging: `await logger.error(...)` - ensures completion\n * - Non-critical logging: `logger.debug(...)` - fire-and-forget\n * - All methods return Promise<void> but never throw or reject\n *\n * @see {@link https://developers.cloudflare.com/workers/observability/logs/workers-logs/}\n * @see {@link https://tools.ietf.org/html/rfc5424}\n */\nexport const logger: Logger = {\n  /**\n   * Configure the logger with custom settings\n   */\n  configure(config: Partial<InternalLoggerConfig>) {\n    loggerConfig = { ...loggerConfig, ...config };\n  },\n\n  /**\n   * Get current logger configuration\n   */\n  getConfig(): InternalLoggerConfig {\n    return { ...loggerConfig };\n  },\n\n  /**\n   * Core logging method that writes to all enabled channels\n   */\n  async log(params: LogParams): Promise<void> {\n    const entry = createLogEntry(params);\n    await writeToChannels(entry);\n  },\n\n  /**\n   * Genarates a support number\n   */\n  async support(): Promise<string> {\n    return crypto.randomUUID();\n  },\n  // RFC 5424 log levels in descending order of severity\n\n  /**\n   * System is unusable - emergency level\n   */\n  emergency(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'emergency' });\n  },\n\n  /**\n   * Action must be taken immediately - alert level\n   */\n  alert(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'alert' });\n  },\n\n  /**\n   * Critical conditions - critical level\n   */\n  critical(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'critical' });\n  },\n\n  /**\n   * Error conditions - error level\n   */\n  error(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'error' });\n  },\n\n  /**\n   * Warning conditions - warning level\n   */\n  warning(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'warning' });\n  },\n\n  /**\n   * Normal but significant conditions - notice level\n   */\n  notice(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'notice' });\n  },\n\n  /**\n   * Informational messages - info level\n   */\n  info(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'info' });\n  },\n\n  /**\n   * Debug-level messages - debug level\n   */\n  debug(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'debug' });\n  },\n};\n\n// Track initialization state\nlet isLoggerInitialized = false;\n\n/**\n * Logger initialization options\n */\nexport interface InitLoggerOptions {\n  config: LoggerConfig;\n  store: KVNamespace;\n  production: boolean;\n  startupCallback?: () => Promise<void>;\n}\n\n/**\n * Initialize logger with named options\n * Returns a boolean indicating whether initialization actually occurred (true) or was already done (false)\n * Handles race conditions internally - safe to call multiple times\n */\nexport async function initLogger(options: InitLoggerOptions): Promise<boolean> {\n  if (isLoggerInitialized) {\n    return false;\n  }\n\n  const {\n    config,\n    store,\n    production = true, // Default to production for safety\n    startupCallback,\n  } = options;\n\n  // Create internal logger config from declarative config\n  const finalConfig = createInternalLoggerConfig(config, production, store);\n\n  logger.configure(finalConfig);\n  isLoggerInitialized = true;\n\n  // Execute optional startup logging callback\n  if (startupCallback) {\n    await startupCallback();\n  }\n\n  return true; // Initialization completed\n}\n\n/**\n * Check if logger has been initialized\n */\nexport function isInitialized(): boolean {\n  return isLoggerInitialized;\n}\n\n/**\n * Require logger to be initialized, throws if not\n */\nexport function requireInitialized(): void {\n  if (!isLoggerInitialized) {\n    throw new Error('Logger must be initialized before use. Call initLogger() in entry.worker.ts first.');\n  }\n}\n",
    "import { createContext, type RouterContextProvider } from 'react-router';\n\n/**\n * Environment type definition\n */\nexport type Environment = 'development' | 'production' | 'test';\n\n/**\n * Environment context for storing the current environment state\n */\nexport const EnvironmentContext = createContext<Environment>('development');\n\n/**\n * Get the current environment from context\n */\nexport function getEnvironment(context: Readonly<RouterContextProvider>): Environment {\n  return context.get(EnvironmentContext);\n}\n\n/**\n * Check if the application is running in development mode\n */\nexport function isDevelopment(context: Readonly<RouterContextProvider>): boolean {\n  return getEnvironment(context) === 'development';\n}\n\n/**\n * Check if the application is running in production mode\n */\nexport function isProduction(context: Readonly<RouterContextProvider>): boolean {\n  return getEnvironment(context) === 'production';\n}\n\n/**\n * Check if the application is running in test mode\n */\nexport function isTesting(context: Readonly<RouterContextProvider>): boolean {\n  return getEnvironment(context) === 'test';\n}\n",
    "import type { RouterContextProvider } from 'react-router';\nimport type { KVBindings } from './@types/cloudflare.types';\nimport { getBindings } from './cloudflare';\n\n/**\n * Get KV namespace from context using a pre-configured binding name\n */\nexport function getKVStore(context: Readonly<RouterContextProvider>, bindingName: KVBindings): KVNamespace | undefined {\n  const bindings = getBindings(context);\n\n  return bindings[bindingName as keyof typeof bindings] as KVNamespace | undefined;\n}\n",
    "import type { RouterContextProvider } from 'react-router';\nimport { getBindings } from './cloudflare';\nimport { isDevelopment } from './environment';\n\n/**\n * Runtime origin information extracted from current request\n */\nexport type OriginInfo = {\n  domain: string; // Domain only (e.g., 'example.com')\n  origin: string; // Full origin (e.g., 'https://example.com')\n  isLocalhost: boolean; // True if localhost/127.0.0.1\n  isDevelopment: boolean; // True if development environment\n};\n\n/**\n * Extract hostname from a URL string or Request\n */\nfunction extractHostname(urlOrRequest: string | Request): string {\n  const url = typeof urlOrRequest === 'string' ? urlOrRequest : urlOrRequest.url;\n\n  return new URL(url).hostname;\n}\n\n/**\n * Extract origin (protocol + hostname + port) from a URL string or Request\n */\nfunction extractOrigin(urlOrRequest: string | Request): string {\n  const url = typeof urlOrRequest === 'string' ? urlOrRequest : urlOrRequest.url;\n\n  return new URL(url).origin;\n}\n\n/**\n * Check if a hostname is localhost\n */\nfunction isLocalhost(hostname: string): boolean {\n  return hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '[::1]';\n}\n\n/**\n * Get origin domain (hostname without protocol/port)\n *\n * Resolution order:\n * 1. SITE_URL environment variable (extract domain)\n * 2. Request hostname (auto-detect)\n */\nexport function getOriginDomain(context: Readonly<RouterContextProvider>, request: Request): string {\n  const bindings = getBindings(context);\n\n  // Check for SITE_URL environment variable\n  const siteUrl = bindings['SITE_URL' as keyof typeof bindings] as string | undefined;\n  if (siteUrl) {\n    return extractHostname(siteUrl);\n  }\n\n  // Fall back to request hostname\n  return extractHostname(request);\n}\n\n/**\n * Get full origin (protocol + hostname + port)\n *\n * Resolution order:\n * 1. SITE_URL environment variable\n * 2. Request origin (auto-detect)\n */\nexport function getOrigin(context: Readonly<RouterContextProvider>, request: Request): string {\n  const bindings = getBindings(context);\n\n  // Check for SITE_URL environment variable\n  const siteUrl = bindings['SITE_URL' as keyof typeof bindings] as string | undefined;\n  if (siteUrl) {\n    return extractOrigin(siteUrl);\n  }\n\n  // Fall back to request origin\n  return extractOrigin(request);\n}\n\n/**\n * Check if the current request origin is localhost\n */\nexport function isLocalhostOrigin(context: Readonly<RouterContextProvider>, request: Request): boolean {\n  const domain = getOriginDomain(context, request);\n\n  return isLocalhost(domain);\n}\n\n/**\n * Get complete origin information for the current request\n *\n * Provides environment-aware origin detection:\n * - Development: localhost-friendly settings\n * - Production: strict production settings\n */\nexport function getOriginInfo(context: Readonly<RouterContextProvider>, request: Request): OriginInfo {\n  const domain = getOriginDomain(context, request);\n  const origin = getOrigin(context, request);\n  const localhost = isLocalhost(domain);\n  const development = isDevelopment(context);\n\n  return { domain, origin, isLocalhost: localhost, isDevelopment: development };\n}\n",
    "import type { RobotsOptions } from '../@types/robots.types';\n\nexport function generateRobotsTxt({ sitemapUrl, rules }: RobotsOptions): string {\n  let txt = '';\n\n  for (const rule of rules) {\n    txt += `User-agent: ${rule.userAgent}\\n`;\n\n    if (rule.allows?.length) {\n      txt += `${rule.allows.map(a => `Allow: ${a}`).join('\\n')}\\n`;\n    }\n\n    if (rule.disallows?.length) {\n      txt += `${rule.disallows.map(d => `Disallow: ${d}`).join('\\n')}\\n`;\n    }\n\n    if (rule.crawlDelay !== undefined) {\n      txt += `Crawl-delay: ${rule.crawlDelay}\\n`;\n    }\n\n    txt += '\\n';\n  }\n\n  if (sitemapUrl) {\n    txt += `Sitemap: ${sitemapUrl}\\n`;\n  }\n\n  return txt.trim();\n}\n",
    "import type { SEOHandle, SiteMap, SitemapEntry, SiteXml } from '../@types/sitemap.types';\n\nexport async function generateSitemap({ request, routes, options, exclude }: SiteMap) {\n  const { headers } = options;\n  const sitemap = await getSitemapXml({ request, routes, options, exclude });\n  const bytes = new TextEncoder().encode(sitemap).byteLength;\n\n  return new Response(sitemap, { headers: { ...headers, 'Content-Type': 'application/xml', 'Content-Length': String(bytes) } });\n}\n\nasync function getSitemapXml({ request, routes, options, exclude }: SiteXml) {\n  const { siteUrl } = options;\n\n  function getEntry({ route, lastmod, changefreq, priority = 0.7 }: SitemapEntry) {\n    if (excludeRoute(route.replace(/^\\/+/, ''), exclude)) return;\n\n    // Ensure proper URL construction without double slashes\n    const normalizedRoute = route.startsWith('/') ? route : `/${route}`;\n    const normalizedSiteUrl = siteUrl.endsWith('/') ? siteUrl.slice(0, -1) : siteUrl;\n    const fullUrl = `${normalizedSiteUrl}${normalizedRoute}`;\n\n    return `\n  <url>\n    <loc>${fullUrl}</loc>\n    ${lastmod ? `<lastmod>${lastmod}</lastmod>` : ''}\n    ${changefreq ? `<changefreq>${changefreq}</changefreq>` : ''}\n    ${typeof priority === 'number' ? `<priority>${priority}</priority>` : ''}\n  </url>\n    `.trim();\n  }\n\n  const sitemapText = (sitemapEntries: SitemapEntry[]) =>\n    `\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <urlset\n    xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd\"\n  >\n    ${sitemapEntries.map(entry => getEntry(entry)).join('')}\n  </urlset>\n    `.trim();\n\n  const rawSitemapEntries = (\n    await Promise.all(\n      Object.entries(routes).map(async ([id, route]) => {\n        if (id === 'root') return;\n        if (!route) return;\n        if (!('module' in route)) return;\n        const mod = route.module;\n\n        const handle = mod.handle as SEOHandle | undefined;\n        if (handle?.getSitemapEntries) {\n          return handle.getSitemapEntries(request);\n        }\n\n        if (!('default' in mod)) return;\n\n        const manifestEntry = routes[id];\n        if (!manifestEntry) {\n          console.warn(`Could not find a manifest entry for ${id}`);\n          return;\n        }\n        let parentId = manifestEntry.parentId;\n        let parent = parentId ? routes[parentId] : null;\n\n        let path: string | string[];\n        if (manifestEntry.path) {\n          path = removeTrailingSlash(manifestEntry.path);\n        } else if (manifestEntry.index) {\n          path = '';\n        } else {\n          return;\n        }\n\n        while (parent) {\n          // the root path is '/', so it messes things up if we add another '/'\n          const parentPath = parent.path ? removeTrailingSlash(parent.path) : '';\n          path = `${parentPath}/${path}`;\n          parentId = parent.parentId;\n          parent = parentId ? routes[parentId] : null;\n        }\n\n        // can't handle dynamic routes or wildcards, so return if the handle doesn't have a getSitemapEntries function\n        if (path.includes(':') || path.includes('*')) return;\n        if (id === 'root') return;\n\n        const entry: SitemapEntry = { route: removeTrailingSlash(path) };\n        return entry;\n      })\n    )\n  )\n    .flat()\n    .filter(typedBoolean);\n\n  const sitemapEntries: Array<SitemapEntry> = [];\n  for (const entry of rawSitemapEntries) {\n    const existingEntryForRoute = sitemapEntries.find(e => e.route === entry.route);\n    if (!existingEntryForRoute) {\n      sitemapEntries.push(entry);\n    }\n  }\n\n  return sitemapText(sitemapEntries);\n}\n\nfunction excludeRoute(route: string, exclude: string[]): boolean {\n  for (const pattern of exclude) {\n    if (pattern === route) return true;\n\n    if (pattern.includes('*')) {\n      const regexPattern = pattern\n        .replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&') // escape special regex chars\n        .replace(/\\*/g, '.*'); // convert * to .*\n\n      const regex = new RegExp(`^${regexPattern}$`);\n      if (regex.test(route)) return true;\n    }\n  }\n  return false;\n}\n\nfunction typedBoolean<T>(value: T): value is Exclude<T, '' | 0 | false | null | undefined> {\n  return Boolean(value);\n}\n\nfunction removeTrailingSlash(s: string) {\n  return s.endsWith('/') ? s.slice(0, -1) : s;\n}\n"
  ],
  "mappings": "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",
  "debugId": "1AA127D2ADADDFC564756E2164756E21",
  "names": []
}