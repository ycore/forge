{"version":3,"file":"index.js","sources":["../../src/services/@types/cloudflare.types.ts","../../src/services/cloudflare.ts","../../src/logger/logger.config.ts","../../src/logger/logger.ts","../../src/services/database.ts","../../src/services/environment.ts","../../src/services/kv-store.ts","../../src/services/origin.ts","../../src/services/site/robots.ts","../../src/services/site/sitemap.ts"],"sourcesContent":["// Placeholder value for unconfigured bindings/secrets\nexport const UNCONFIGURED = 'UNCONFIGURED' as const;\nexport type Unconfigured = typeof UNCONFIGURED;\n\n// Actual binding names from Cloudflare.Env\nexport type ActualKVBindingNames = {\n  [K in keyof Cloudflare.Env]: Cloudflare.Env[K] extends KVNamespace ? K : never;\n}[keyof Cloudflare.Env];\n\nexport type ActualD1BindingNames = {\n  [K in keyof Cloudflare.Env]: Cloudflare.Env[K] extends D1Database ? K : never;\n}[keyof Cloudflare.Env];\n\nexport type ActualSecretNames = {\n  [K in keyof Cloudflare.Env]: K extends `${string}_SECRET_KEY` | `${string}_API_KEY` ? K : never;\n}[keyof Cloudflare.Env];\n\nexport type ActualEnvironmentVarNames = {\n  [K in keyof Cloudflare.Env]: Cloudflare.Env[K] extends string ? (K extends ActualSecretNames ? never : K) : never;\n}[keyof Cloudflare.Env];\n\n// Types that allow unconfigured defaults\nexport type KVBindings = ActualKVBindingNames | Unconfigured;\nexport type D1Bindings = ActualD1BindingNames | Unconfigured;\nexport type SecretBindings = ActualSecretNames | Unconfigured;\nexport type VarBindings = ActualEnvironmentVarNames | Unconfigured;\n// Legacy alias for backward compatibility\nexport type EnvironmentVarNames = ActualEnvironmentVarNames;\n","import { createContext, type RouterContextProvider } from 'react-router';\n\nexport const CloudflareContext = createContext<{ env: Cloudflare.Env; ctx: ExecutionContext; cf?: RequestInitCfProperties }>({} as { env: Cloudflare.Env; ctx: ExecutionContext; cf?: RequestInitCfProperties });\n\nexport function getBindings(context: Readonly<RouterContextProvider>) {\n  return context.get(CloudflareContext).env;\n}\n\nexport function getExecutionContext(context: Readonly<RouterContextProvider>): ExecutionContext {\n  return context.get(CloudflareContext).ctx;\n}\n\nexport function getRequestProperties(context: Readonly<RouterContextProvider>): RequestInitCfProperties | undefined {\n  return context.get(CloudflareContext).cf;\n}\n\nexport function waitUntil<T>(context: Readonly<RouterContextProvider>, promise: Promise<T>) {\n  return getExecutionContext(context).waitUntil(promise);\n}\n","/// <reference path=\"../@types/worker-runtime.d.ts\" />\n\nimport type { LoggerConfig, LogLevel } from './@types/logger.types';\n\n// RFC 5424 log level hierarchy (higher number = higher severity)\nexport const LOG_LEVELS: Record<LogLevel, number> = {\n  emergency: 7,\n  alert: 6,\n  critical: 5,\n  error: 4,\n  warning: 3,\n  notice: 2,\n  info: 1,\n  debug: 0,\n} as const;\n\n/**\n * Check if a log level should be logged based on minimum level threshold\n */\nexport function shouldLog(level: LogLevel, minLevel: LogLevel): boolean {\n  return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];\n}\n\n/**\n * Get environment-specific channel options\n */\nexport function getChannelOptions(registry: 'console' | 'kv', production: boolean, baseOptions: Record<string, unknown> = {}, kv?: KVNamespace): Record<string, unknown> {\n  // Console channel environment-specific defaults\n  if (registry === 'console') {\n    const envDefaults = {\n      format: production ? 'raw' : 'json',\n      useLogLevelMethods: !production,\n    };\n    // Explicit options override environment defaults\n    return { ...envDefaults, ...baseOptions };\n  }\n\n  let options = { ...baseOptions };\n\n  // KV channel - inject KV namespace\n  if (registry === 'kv' && kv) {\n    options = { ...options, kv };\n  }\n\n  return options;\n}\n\n/**\n * Get environment-specific logger defaults\n */\nexport function getLoggerDefaults(config: LoggerConfig, production: boolean): { defaultLevel: LogLevel; enableSanitization: boolean } {\n  const defaults = production ? config.defaults?.production : config.defaults?.development;\n\n  return {\n    defaultLevel: defaults?.defaultLevel || (production ? 'warning' : 'info'),\n    enableSanitization: defaults?.enableSanitization ?? true,\n  };\n}\n\n/**\n * Default logger configuration\n */\nexport const defaultLoggerConfig: LoggerConfig = {\n  init: [\n    {\n      production: false,\n      channel: 'console',\n      level: 'debug',\n    },\n    {\n      production: false,\n      channel: 'console',\n      level: 'warning',\n    },\n    {\n      production: false,\n      channel: 'kv',\n      level: 'info',\n    },\n    {\n      production: true,\n      channel: 'kv',\n      level: 'warning',\n    },\n  ],\n  channels: {\n    console: {\n      registry: 'console',\n      options: {}, // Will be populated with environment defaults\n    },\n    kv: {\n      registry: 'kv',\n      options: {\n        logsLimit: 500,\n        logsTrigger: 750,\n      },\n    },\n  },\n  defaults: {\n    development: {\n      defaultLevel: 'debug',\n      enableSanitization: true,\n    },\n    production: {\n      defaultLevel: 'warning',\n      enableSanitization: true,\n    },\n  },\n};\n","/// <reference path=\"../@types/worker-runtime.d.ts\" />\n\n/** biome-ignore-all lint/suspicious/noExplicitAny: acceptable */\nimport type { BaseLogParams, InternalLoggerConfig, LogArgs, LogEntry, Logger, LoggerConfig, LogLevel, LogParams } from './@types/logger.types';\nimport { shouldLog } from './logger.config';\nimport { createInternalLoggerConfig } from './logger.helpers';\n\nexport interface LoggerState {\n  initialized: boolean;\n  wasInitializedHere?: boolean;\n}\n\n// Global logger configuration\nlet loggerConfig: InternalLoggerConfig = {\n  defaultLevel: 'info',\n  channels: [],\n  enableSanitization: true,\n};\n\n/**\n * Sanitizes log parameters by removing sensitive fields\n */\nfunction sanitizeLogParams(params: LogParams): LogParams {\n  if (!loggerConfig.enableSanitization) {\n    return params;\n  }\n\n  // biome-ignore lint/correctness/noUnusedVariables: intentional\n  const { password, token, secret, apiKey, sessionToken, bearerToken, refreshToken, ...sanitized } = params as LogParams & {\n    password?: unknown;\n    token?: unknown;\n    secret?: unknown;\n    apiKey?: unknown;\n    sessionToken?: unknown;\n    bearerToken?: unknown;\n    refreshToken?: unknown;\n  };\n  return sanitized;\n}\n\n/**\n * Formats log arguments similar to diary's approach\n */\nfunction formatLogArgs(args: LogArgs): BaseLogParams {\n  const [message, ...rest] = args;\n\n  if (typeof message === 'object' && message !== null) {\n    return { ...message, ...(rest.length > 0 ? { args: rest } : {}) } as BaseLogParams;\n  }\n\n  return { event: String(message), ...(rest.length > 0 ? { args: rest } : {}) } as BaseLogParams;\n}\n\n/**\n * Creates a structured log entry\n */\nfunction createLogEntry(params: LogParams): LogEntry {\n  const sanitizedParams = sanitizeLogParams(params);\n  return {\n    ...sanitizedParams,\n    level: (sanitizedParams.level || loggerConfig.defaultLevel) as LogLevel,\n    timestamp: new Date().toISOString(),\n  } as LogEntry;\n}\n\n/**\n * Writes log entry to all enabled channels that meet the level threshold\n * Logging failures are silently ignored to prevent disrupting application flow\n */\nasync function writeToChannels(entry: LogEntry): Promise<void> {\n  const writePromises = loggerConfig.channels\n    .filter(channel => channel.enabled && shouldLog(entry.level, channel.minLevel))\n    .map(channel => {\n      try {\n        const result = channel.output(entry);\n        return result instanceof Promise ? result : Promise.resolve();\n      } catch (_error) {\n        // Silently ignore logging failures to prevent disrupting application flow\n        return Promise.resolve();\n      }\n    });\n\n  await Promise.allSettled(writePromises);\n}\n\n// Production optimizations are handled by the Vite logger plugin\n// These runtime checks will be replaced with static values during build\n\n/**\n * Enhanced Structured Logging Utility with Multi-Channel Support\n *\n * Features:\n * - RFC 5424 log levels with proper hierarchy\n * - Multi-channel output (console, webhooks, Slack, etc.)\n * - Environment-specific configuration\n * - Flexible API supporting both structured objects and diary-style strings\n * - Security sanitization for sensitive data\n * - Production build optimization with dead code elimination\n * - Optimized for Cloudflare Workers deployment\n * - **Error-safe**: Never throws or contributes to error flow - logging failures are silently ignored\n *\n * Usage patterns:\n * - Critical logging: `await logger.error(...)` - ensures completion\n * - Non-critical logging: `logger.debug(...)` - fire-and-forget\n * - All methods return Promise<void> but never throw or reject\n *\n * @see {@link https://developers.cloudflare.com/workers/observability/logs/workers-logs/}\n * @see {@link https://tools.ietf.org/html/rfc5424}\n */\nexport const logger: Logger = {\n  /**\n   * Configure the logger with custom settings\n   */\n  configure(config: Partial<InternalLoggerConfig>) {\n    loggerConfig = { ...loggerConfig, ...config };\n  },\n\n  /**\n   * Get current logger configuration\n   */\n  getConfig(): InternalLoggerConfig {\n    return { ...loggerConfig };\n  },\n\n  /**\n   * Core logging method that writes to all enabled channels\n   */\n  async log(params: LogParams): Promise<void> {\n    const entry = createLogEntry(params);\n    await writeToChannels(entry);\n  },\n\n  /**\n   * Genarates a support number\n   */\n  async support(): Promise<string> {\n    return crypto.randomUUID();\n  },\n  // RFC 5424 log levels in descending order of severity\n\n  /**\n   * System is unusable - emergency level\n   */\n  emergency(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'emergency' });\n  },\n\n  /**\n   * Action must be taken immediately - alert level\n   */\n  alert(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'alert' });\n  },\n\n  /**\n   * Critical conditions - critical level\n   */\n  critical(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'critical' });\n  },\n\n  /**\n   * Error conditions - error level\n   */\n  error(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'error' });\n  },\n\n  /**\n   * Warning conditions - warning level\n   */\n  warning(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'warning' });\n  },\n\n  /**\n   * Normal but significant conditions - notice level\n   */\n  notice(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'notice' });\n  },\n\n  /**\n   * Informational messages - info level\n   */\n  info(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'info' });\n  },\n\n  /**\n   * Debug-level messages - debug level\n   */\n  debug(...args: LogArgs): Promise<void> {\n    const params = formatLogArgs(args);\n    return this.log({ ...params, level: 'debug' });\n  },\n};\n\n// Track initialization state\nlet isLoggerInitialized = false;\n\n/**\n * Logger initialization options\n */\nexport interface InitLoggerOptions {\n  config: LoggerConfig;\n  store: KVNamespace;\n  production: boolean;\n  startupCallback?: () => Promise<void>;\n}\n\n/**\n * Initialize logger with named options\n * Returns a boolean indicating whether initialization actually occurred (true) or was already done (false)\n * Handles race conditions internally - safe to call multiple times\n */\nexport async function initLogger(options: InitLoggerOptions): Promise<boolean> {\n  if (isLoggerInitialized) {\n    return false;\n  }\n\n  // Default to production for safety\n  const { config, store, production = true, startupCallback } = options;\n\n  // Create internal logger config from declarative config\n  const finalConfig = createInternalLoggerConfig(config, production, store);\n\n  logger.configure(finalConfig);\n  isLoggerInitialized = true;\n\n  // Execute optional startup logging callback\n  if (startupCallback) {\n    await startupCallback();\n  }\n\n  return true; // Initialization completed\n}\n\n/**\n * Check if logger has been initialized\n */\nexport function isInitialized(): boolean {\n  return isLoggerInitialized;\n}\n\n/**\n * Require logger to be initialized, throws if not\n */\nexport function requireInitialized(): void {\n  if (!isLoggerInitialized) {\n    throw new Error('Logger must be initialized before use. Call initLogger() in entry.worker.ts first.');\n  }\n}\n","import { drizzle } from 'drizzle-orm/d1';\nimport type { Logger as LoggerInterface } from 'drizzle-orm/logger';\nimport { createContext, type RouterContextProvider } from 'react-router';\n\nimport { logger } from '../logger/logger';\n\ntype DatabaseWithSchema<TSchema extends Record<string, unknown>> = ReturnType<typeof drizzle<TSchema>>;\n\nexport interface DatabaseConfig<TSchema extends Record<string, unknown>> {\n  binding: string;\n  schema: TSchema;\n  enableLogging?: boolean;\n}\n\n// Create typed database context\nexport const DatabaseContext = createContext<DatabaseWithSchema<Record<string, unknown>> | null>(null);\n\n/**\n * Create a typed database connection from Cloudflare environment and binding config\n */\nexport function bindDatabase<TSchema extends Record<string, unknown>>(env: Cloudflare.Env, binding: string, schema: TSchema, enableLogging = false) {\n  const d1Database = env[binding as keyof Cloudflare.Env] as D1Database;\n  const drizzleConfig: Parameters<typeof drizzle>[1] = { schema };\n  if (enableLogging) {\n    drizzleConfig.logger = new Logger();\n  }\n\n  return drizzle(d1Database, drizzleConfig);\n}\n\n/**\n * Initialize database and set it in the router context\n * Consolidates database binding and context setting in one call\n */\nexport function initDatabase<TSchema extends Record<string, unknown>>(context: Readonly<RouterContextProvider>, env: Cloudflare.Env, config: DatabaseConfig<TSchema>) {\n  const db = bindDatabase(env, config.binding, config.schema, config.enableLogging);\n  context.set(DatabaseContext, db);\n  return db;\n}\n\n/**\n * Simple database getter function following getBindings pattern\n * Extracts the typed database instance from React Router context\n * @throws Error if database context is not set\n */\nexport function getDatabase(context: Readonly<RouterContextProvider>) {\n  const db = context.get(DatabaseContext);\n  if (!db) {\n    throw new Error('Database context not found. Make sure to bind database in your worker entry point.');\n  }\n  return db;\n}\n\n/**\n * Custom Drizzle logger that integrates with the logger system\n * - Strips newlines, excessive whitespace and replaces double quotes with backticks for cleaner JSON serialization\n */\nclass Logger implements LoggerInterface {\n  logQuery(query: string, params: unknown[]): void {\n    const cleanQuery = query\n      .replace(/\\s*\\n\\s*/g, ' ') // Remove newlines and surrounding whitespace\n      .replace(/\"/g, '`') // Replace double quotes with backticks\n      .replace(/\\s+/g, ' ') // Normalize multiple spaces to single space\n      .trim();\n\n    logger.debug('SQL', { query: cleanQuery, params: params.length > 0 ? params : undefined });\n  }\n}\n","import { createContext, type RouterContextProvider } from 'react-router';\n\n/**\n * Environment type definition\n */\nexport type Environment = 'development' | 'production' | 'test';\n\n/**\n * Environment context for storing the current environment state\n */\nexport const EnvironmentContext = createContext<Environment>('development');\n\n/**\n * Get the current environment from context\n */\nexport function getEnvironment(context: Readonly<RouterContextProvider>): Environment {\n  return context.get(EnvironmentContext);\n}\n\n/**\n * Check if the application is running in development mode\n */\nexport function isDevelopment(context: Readonly<RouterContextProvider>): boolean {\n  return getEnvironment(context) === 'development';\n}\n\n/**\n * Check if the application is running in production mode\n */\nexport function isProduction(context: Readonly<RouterContextProvider>): boolean {\n  return getEnvironment(context) === 'production';\n}\n\n/**\n * Check if the application is running in test mode\n */\nexport function isTesting(context: Readonly<RouterContextProvider>): boolean {\n  return getEnvironment(context) === 'test';\n}\n","/// <reference path=\"../@types/worker-runtime.d.ts\" />\n\nimport type { RouterContextProvider } from 'react-router';\nimport type { KVBindings } from './@types/cloudflare.types';\nimport { getBindings } from './cloudflare';\n\n/**\n * Get KV namespace from context using a pre-configured binding name\n */\nexport function getKVStore(context: Readonly<RouterContextProvider>, bindingName: KVBindings): KVNamespace | undefined {\n  const bindings = getBindings(context);\n\n  return bindings[bindingName as keyof typeof bindings] as KVNamespace | undefined;\n}\n","import type { RouterContextProvider } from 'react-router';\nimport { getBindings } from './cloudflare';\nimport { isDevelopment } from './environment';\n\n/**\n * Runtime origin information extracted from current request\n */\nexport type OriginInfo = {\n  domain: string; // Domain only (e.g., 'example.com')\n  origin: string; // Full origin (e.g., 'https://example.com')\n  isLocalhost: boolean; // True if localhost/127.0.0.1\n  isDevelopment: boolean; // True if development environment\n};\n\n/**\n * Extract hostname from a URL string or Request\n */\nfunction extractHostname(urlOrRequest: string | Request): string {\n  const url = typeof urlOrRequest === 'string' ? urlOrRequest : urlOrRequest.url;\n\n  return new URL(url).hostname;\n}\n\n/**\n * Extract origin (protocol + hostname + port) from a URL string or Request\n */\nfunction extractOrigin(urlOrRequest: string | Request): string {\n  const url = typeof urlOrRequest === 'string' ? urlOrRequest : urlOrRequest.url;\n\n  return new URL(url).origin;\n}\n\n/**\n * Check if a hostname is localhost\n */\nfunction isLocalhost(hostname: string): boolean {\n  return hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '[::1]';\n}\n\n/**\n * Get origin domain (hostname without protocol/port)\n *\n * Resolution order:\n * 1. SITE_URL environment variable (extract domain)\n * 2. Request hostname (auto-detect)\n */\nexport function getOriginDomain(context: Readonly<RouterContextProvider>, request: Request): string {\n  const bindings = getBindings(context);\n\n  // Check for SITE_URL environment variable\n  const siteUrl = bindings['SITE_URL' as keyof typeof bindings] as string | undefined;\n  if (siteUrl) {\n    return extractHostname(siteUrl);\n  }\n\n  // Fall back to request hostname\n  return extractHostname(request);\n}\n\n/**\n * Get full origin (protocol + hostname + port)\n *\n * Resolution order:\n * 1. SITE_URL environment variable\n * 2. Request origin (auto-detect)\n */\nexport function getOrigin(context: Readonly<RouterContextProvider>, request: Request): string {\n  const bindings = getBindings(context);\n\n  // Check for SITE_URL environment variable\n  const siteUrl = bindings['SITE_URL' as keyof typeof bindings] as string | undefined;\n  if (siteUrl) {\n    return extractOrigin(siteUrl);\n  }\n\n  // Fall back to request origin\n  return extractOrigin(request);\n}\n\n/**\n * Check if the current request origin is localhost\n */\nexport function isLocalhostOrigin(context: Readonly<RouterContextProvider>, request: Request): boolean {\n  const domain = getOriginDomain(context, request);\n\n  return isLocalhost(domain);\n}\n\n/**\n * Get complete origin information for the current request\n *\n * Provides environment-aware origin detection:\n * - Development: localhost-friendly settings\n * - Production: strict production settings\n */\nexport function getOriginInfo(context: Readonly<RouterContextProvider>, request: Request): OriginInfo {\n  const domain = getOriginDomain(context, request);\n  const origin = getOrigin(context, request);\n  const localhost = isLocalhost(domain);\n  const development = isDevelopment(context);\n\n  return { domain, origin, isLocalhost: localhost, isDevelopment: development };\n}\n","import type { RobotsOptions } from '../@types/robots.types';\n\nexport function generateRobotsTxt({ sitemapUrl, rules }: RobotsOptions): string {\n  let txt = '';\n\n  for (const rule of rules) {\n    txt += `User-agent: ${rule.userAgent}\\n`;\n\n    if (rule.allows?.length) {\n      txt += `${rule.allows.map(a => `Allow: ${a}`).join('\\n')}\\n`;\n    }\n\n    if (rule.disallows?.length) {\n      txt += `${rule.disallows.map(d => `Disallow: ${d}`).join('\\n')}\\n`;\n    }\n\n    if (rule.crawlDelay !== undefined) {\n      txt += `Crawl-delay: ${rule.crawlDelay}\\n`;\n    }\n\n    txt += '\\n';\n  }\n\n  if (sitemapUrl) {\n    txt += `Sitemap: ${sitemapUrl}\\n`;\n  }\n\n  return txt.trim();\n}\n","import type { SEOHandle, SiteMap, SitemapEntry, SiteXml } from '../@types/sitemap.types';\n\nexport async function generateSitemap({ request, routes, options, exclude }: SiteMap) {\n  const { headers } = options;\n  const sitemap = await getSitemapXml({ request, routes, options, exclude });\n  const bytes = new TextEncoder().encode(sitemap).byteLength;\n\n  return new Response(sitemap, { headers: { ...headers, 'Content-Type': 'application/xml', 'Content-Length': String(bytes) } });\n}\n\nasync function getSitemapXml({ request, routes, options, exclude }: SiteXml) {\n  const { siteUrl } = options;\n\n  function getEntry({ route, lastmod, changefreq, priority = 0.7 }: SitemapEntry) {\n    if (excludeRoute(route.replace(/^\\/+/, ''), exclude)) return;\n\n    // Ensure proper URL construction without double slashes\n    const normalizedRoute = route.startsWith('/') ? route : `/${route}`;\n    const normalizedSiteUrl = siteUrl.endsWith('/') ? siteUrl.slice(0, -1) : siteUrl;\n    const fullUrl = `${normalizedSiteUrl}${normalizedRoute}`;\n\n    return `\n  <url>\n    <loc>${fullUrl}</loc>\n    ${lastmod ? `<lastmod>${lastmod}</lastmod>` : ''}\n    ${changefreq ? `<changefreq>${changefreq}</changefreq>` : ''}\n    ${typeof priority === 'number' ? `<priority>${priority}</priority>` : ''}\n  </url>\n    `.trim();\n  }\n\n  const sitemapText = (sitemapEntries: SitemapEntry[]) =>\n    `\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <urlset\n    xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd\"\n  >\n    ${sitemapEntries.map(entry => getEntry(entry)).join('')}\n  </urlset>\n    `.trim();\n\n  const rawSitemapEntries = (\n    await Promise.all(\n      Object.entries(routes).map(async ([id, route]) => {\n        if (id === 'root') return;\n        if (!route) return;\n        if (!('module' in route)) return;\n        const mod = route.module;\n\n        const handle = mod.handle as SEOHandle | undefined;\n        if (handle?.getSitemapEntries) {\n          return handle.getSitemapEntries(request);\n        }\n\n        if (!('default' in mod)) return;\n\n        const manifestEntry = routes[id];\n        if (!manifestEntry) {\n          console.warn(`Could not find a manifest entry for ${id}`);\n          return;\n        }\n        let parentId = manifestEntry.parentId;\n        let parent = parentId ? routes[parentId] : null;\n\n        let path: string | string[];\n        if (manifestEntry.path) {\n          path = removeTrailingSlash(manifestEntry.path);\n        } else if (manifestEntry.index) {\n          path = '';\n        } else {\n          return;\n        }\n\n        while (parent) {\n          // the root path is '/', so it messes things up if we add another '/'\n          const parentPath = parent.path ? removeTrailingSlash(parent.path) : '';\n          path = `${parentPath}/${path}`;\n          parentId = parent.parentId;\n          parent = parentId ? routes[parentId] : null;\n        }\n\n        // can't handle dynamic routes or wildcards, so return if the handle doesn't have a getSitemapEntries function\n        if (path.includes(':') || path.includes('*')) return;\n        if (id === 'root') return;\n\n        const entry: SitemapEntry = { route: removeTrailingSlash(path) };\n        return entry;\n      })\n    )\n  )\n    .flat()\n    .filter(typedBoolean);\n\n  const sitemapEntries: Array<SitemapEntry> = [];\n  for (const entry of rawSitemapEntries) {\n    const existingEntryForRoute = sitemapEntries.find(e => e.route === entry.route);\n    if (!existingEntryForRoute) {\n      sitemapEntries.push(entry);\n    }\n  }\n\n  return sitemapText(sitemapEntries);\n}\n\nfunction excludeRoute(route: string, exclude: string[]): boolean {\n  for (const pattern of exclude) {\n    if (pattern === route) return true;\n\n    if (pattern.includes('*')) {\n      const regexPattern = pattern\n        .replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&') // escape special regex chars\n        .replace(/\\*/g, '.*'); // convert * to .*\n\n      const regex = new RegExp(`^${regexPattern}$`);\n      if (regex.test(route)) return true;\n    }\n  }\n  return false;\n}\n\nfunction typedBoolean<T>(value: T): value is Exclude<T, '' | 0 | false | null | undefined> {\n  return Boolean(value);\n}\n\nfunction removeTrailingSlash(s: string) {\n  return s.endsWith('/') ? s.slice(0, -1) : s;\n}\n"],"names":["sitemapEntries"],"mappings":";;AACO,MAAM,eAAe;ACCrB,MAAM,oBAAoB,cAA4F,CAAA,CAAkF;AAExM,SAAS,YAAY,SAA0C;AACpE,SAAO,QAAQ,IAAI,iBAAiB,EAAE;AACxC;AAEO,SAAS,oBAAoB,SAA4D;AAC9F,SAAO,QAAQ,IAAI,iBAAiB,EAAE;AACxC;AAEO,SAAS,qBAAqB,SAA+E;AAClH,SAAO,QAAQ,IAAI,iBAAiB,EAAE;AACxC;AAEO,SAAS,UAAa,SAA0C,SAAqB;AAC1F,SAAO,oBAAoB,OAAO,EAAE,UAAU,OAAO;AACvD;ACbO,MAAM,aAAuC;AAAA,EAClD,WAAW;AAAA,EACX,OAAO;AAAA,EACP,UAAU;AAAA,EACV,OAAO;AAAA,EACP,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AACT;AAKO,SAAS,UAAU,OAAiB,UAA6B;AACtE,SAAO,WAAW,KAAK,KAAK,WAAW,QAAQ;AACjD;ACRA,IAAI,eAAqC;AAAA,EACvC,cAAc;AAAA,EACd,UAAU,CAAA;AAAA,EACV,oBAAoB;AACtB;AAKA,SAAS,kBAAkB,QAA8B;AACvD,MAAI,CAAC,aAAa,oBAAoB;AACpC,WAAO;AAAA,EACT;AAGA,QAAM,EAAE,UAAU,OAAO,QAAQ,QAAQ,cAAc,aAAa,cAAc,GAAG,UAAA,IAAc;AASnG,SAAO;AACT;AAKA,SAAS,cAAc,MAA8B;AACnD,QAAM,CAAC,SAAS,GAAG,IAAI,IAAI;AAE3B,MAAI,OAAO,YAAY,YAAY,YAAY,MAAM;AACnD,WAAO,EAAE,GAAG,SAAS,GAAI,KAAK,SAAS,IAAI,EAAE,MAAM,KAAA,IAAS,GAAC;AAAA,EAC/D;AAEA,SAAO,EAAE,OAAO,OAAO,OAAO,GAAG,GAAI,KAAK,SAAS,IAAI,EAAE,MAAM,KAAA,IAAS,CAAA,EAAC;AAC3E;AAKA,SAAS,eAAe,QAA6B;AACnD,QAAM,kBAAkB,kBAAkB,MAAM;AAChD,SAAO;AAAA,IACL,GAAG;AAAA,IACH,OAAQ,gBAAgB,SAAS,aAAa;AAAA,IAC9C,YAAW,oBAAI,KAAA,GAAO,YAAA;AAAA,EAAY;AAEtC;AAMA,eAAe,gBAAgB,OAAgC;AAC7D,QAAM,gBAAgB,aAAa,SAChC,OAAO,aAAW,QAAQ,WAAW,UAAU,MAAM,OAAO,QAAQ,QAAQ,CAAC,EAC7E,IAAI,CAAA,YAAW;AACd,QAAI;AACF,YAAM,SAAS,QAAQ,OAAO,KAAK;AACnC,aAAO,kBAAkB,UAAU,SAAS,QAAQ,QAAA;AAAA,IACtD,SAAS,QAAQ;AAEf,aAAO,QAAQ,QAAA;AAAA,IACjB;AAAA,EACF,CAAC;AAEH,QAAM,QAAQ,WAAW,aAAa;AACxC;AA0BO,MAAM,SAAiB;AAAA;AAAA;AAAA;AAAA,EAI5B,UAAU,QAAuC;AAC/C,mBAAe,EAAE,GAAG,cAAc,GAAG,OAAA;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,YAAkC;AAChC,WAAO,EAAE,GAAG,aAAA;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,QAAkC;AAC1C,UAAM,QAAQ,eAAe,MAAM;AACnC,UAAM,gBAAgB,KAAK;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAA2B;AAC/B,WAAO,OAAO,WAAA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa,MAA8B;AACzC,UAAM,SAAS,cAAc,IAAI;AACjC,WAAO,KAAK,IAAI,EAAE,GAAG,QAAQ,OAAO,aAAa;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,MAA8B;AACrC,UAAM,SAAS,cAAc,IAAI;AACjC,WAAO,KAAK,IAAI,EAAE,GAAG,QAAQ,OAAO,SAAS;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,MAA8B;AACxC,UAAM,SAAS,cAAc,IAAI;AACjC,WAAO,KAAK,IAAI,EAAE,GAAG,QAAQ,OAAO,YAAY;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,MAA8B;AACrC,UAAM,SAAS,cAAc,IAAI;AACjC,WAAO,KAAK,IAAI,EAAE,GAAG,QAAQ,OAAO,SAAS;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,MAA8B;AACvC,UAAM,SAAS,cAAc,IAAI;AACjC,WAAO,KAAK,IAAI,EAAE,GAAG,QAAQ,OAAO,WAAW;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,MAA8B;AACtC,UAAM,SAAS,cAAc,IAAI;AACjC,WAAO,KAAK,IAAI,EAAE,GAAG,QAAQ,OAAO,UAAU;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,MAA8B;AACpC,UAAM,SAAS,cAAc,IAAI;AACjC,WAAO,KAAK,IAAI,EAAE,GAAG,QAAQ,OAAO,QAAQ;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,MAA8B;AACrC,UAAM,SAAS,cAAc,IAAI;AACjC,WAAO,KAAK,IAAI,EAAE,GAAG,QAAQ,OAAO,SAAS;AAAA,EAC/C;AACF;AC5LO,MAAM,kBAAkB,cAAkE,IAAI;AAK9F,SAAS,aAAsD,KAAqB,SAAiB,QAAiB,gBAAgB,OAAO;AAClJ,QAAM,aAAa,IAAI,OAA+B;AACtD,QAAM,gBAA+C,EAAE,OAAA;AACvD,MAAI,eAAe;AACjB,kBAAc,SAAS,IAAI,OAAA;AAAA,EAC7B;AAEA,SAAO,QAAQ,YAAY,aAAa;AAC1C;AAMO,SAAS,aAAsD,SAA0C,KAAqB,QAAiC;AACpK,QAAM,KAAK,aAAa,KAAK,OAAO,SAAS,OAAO,QAAQ,OAAO,aAAa;AAChF,UAAQ,IAAI,iBAAiB,EAAE;AAC/B,SAAO;AACT;AAOO,SAAS,YAAY,SAA0C;AACpE,QAAM,KAAK,QAAQ,IAAI,eAAe;AACtC,MAAI,CAAC,IAAI;AACP,UAAM,IAAI,MAAM,oFAAoF;AAAA,EACtG;AACA,SAAO;AACT;AAMA,MAAM,OAAkC;AAAA,EACtC,SAAS,OAAe,QAAyB;AAC/C,UAAM,aAAa,MAChB,QAAQ,aAAa,GAAG,EACxB,QAAQ,MAAM,GAAG,EACjB,QAAQ,QAAQ,GAAG,EACnB,KAAA;AAEH,WAAO,MAAM,OAAO,EAAE,OAAO,YAAY,QAAQ,OAAO,SAAS,IAAI,SAAS,OAAA,CAAW;AAAA,EAC3F;AACF;ACzDO,MAAM,qBAAqB,cAA2B,aAAa;AAKnE,SAAS,eAAe,SAAuD;AACpF,SAAO,QAAQ,IAAI,kBAAkB;AACvC;AAKO,SAAS,cAAc,SAAmD;AAC/E,SAAO,eAAe,OAAO,MAAM;AACrC;AAKO,SAAS,aAAa,SAAmD;AAC9E,SAAO,eAAe,OAAO,MAAM;AACrC;AAKO,SAAS,UAAU,SAAmD;AAC3E,SAAO,eAAe,OAAO,MAAM;AACrC;AC7BO,SAAS,WAAW,SAA0C,aAAkD;AACrH,QAAM,WAAW,YAAY,OAAO;AAEpC,SAAO,SAAS,WAAoC;AACtD;ACIA,SAAS,gBAAgB,cAAwC;AAC/D,QAAM,MAAM,OAAO,iBAAiB,WAAW,eAAe,aAAa;AAE3E,SAAO,IAAI,IAAI,GAAG,EAAE;AACtB;AAKA,SAAS,cAAc,cAAwC;AAC7D,QAAM,MAAM,OAAO,iBAAiB,WAAW,eAAe,aAAa;AAE3E,SAAO,IAAI,IAAI,GAAG,EAAE;AACtB;AAKA,SAAS,YAAY,UAA2B;AAC9C,SAAO,aAAa,eAAe,aAAa,eAAe,aAAa;AAC9E;AASO,SAAS,gBAAgB,SAA0C,SAA0B;AAClG,QAAM,WAAW,YAAY,OAAO;AAGpC,QAAM,UAAU,SAAS,UAAmC;AAC5D,MAAI,SAAS;AACX,WAAO,gBAAgB,OAAO;AAAA,EAChC;AAGA,SAAO,gBAAgB,OAAO;AAChC;AASO,SAAS,UAAU,SAA0C,SAA0B;AAC5F,QAAM,WAAW,YAAY,OAAO;AAGpC,QAAM,UAAU,SAAS,UAAmC;AAC5D,MAAI,SAAS;AACX,WAAO,cAAc,OAAO;AAAA,EAC9B;AAGA,SAAO,cAAc,OAAO;AAC9B;AAKO,SAAS,kBAAkB,SAA0C,SAA2B;AACrG,QAAM,SAAS,gBAAgB,SAAS,OAAO;AAE/C,SAAO,YAAY,MAAM;AAC3B;AASO,SAAS,cAAc,SAA0C,SAA8B;AACpG,QAAM,SAAS,gBAAgB,SAAS,OAAO;AAC/C,QAAM,SAAS,UAAU,SAAS,OAAO;AACzC,QAAM,YAAY,YAAY,MAAM;AACpC,QAAM,cAAc,cAAc,OAAO;AAEzC,SAAO,EAAE,QAAQ,QAAQ,aAAa,WAAW,eAAe,YAAA;AAClE;ACpGO,SAAS,kBAAkB,EAAE,YAAY,SAAgC;AAC9E,MAAI,MAAM;AAEV,aAAW,QAAQ,OAAO;AACxB,WAAO,eAAe,KAAK,SAAS;AAAA;AAEpC,QAAI,KAAK,QAAQ,QAAQ;AACvB,aAAO,GAAG,KAAK,OAAO,IAAI,CAAA,MAAK,UAAU,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA,IAC1D;AAEA,QAAI,KAAK,WAAW,QAAQ;AAC1B,aAAO,GAAG,KAAK,UAAU,IAAI,CAAA,MAAK,aAAa,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA,IAChE;AAEA,QAAI,KAAK,eAAe,QAAW;AACjC,aAAO,gBAAgB,KAAK,UAAU;AAAA;AAAA,IACxC;AAEA,WAAO;AAAA,EACT;AAEA,MAAI,YAAY;AACd,WAAO,YAAY,UAAU;AAAA;AAAA,EAC/B;AAEA,SAAO,IAAI,KAAA;AACb;AC1BA,eAAsB,gBAAgB,EAAE,SAAS,QAAQ,SAAS,WAAoB;AACpF,QAAM,EAAE,YAAY;AACpB,QAAM,UAAU,MAAM,cAAc,EAAE,SAAS,QAAQ,SAAS,SAAS;AACzE,QAAM,QAAQ,IAAI,YAAA,EAAc,OAAO,OAAO,EAAE;AAEhD,SAAO,IAAI,SAAS,SAAS,EAAE,SAAS,EAAE,GAAG,SAAS,gBAAgB,mBAAmB,kBAAkB,OAAO,KAAK,EAAA,GAAK;AAC9H;AAEA,eAAe,cAAc,EAAE,SAAS,QAAQ,SAAS,WAAoB;AAC3E,QAAM,EAAE,YAAY;AAEpB,WAAS,SAAS,EAAE,OAAO,SAAS,YAAY,WAAW,OAAqB;AAC9E,QAAI,aAAa,MAAM,QAAQ,QAAQ,EAAE,GAAG,OAAO,EAAG;AAGtD,UAAM,kBAAkB,MAAM,WAAW,GAAG,IAAI,QAAQ,IAAI,KAAK;AACjE,UAAM,oBAAoB,QAAQ,SAAS,GAAG,IAAI,QAAQ,MAAM,GAAG,EAAE,IAAI;AACzE,UAAM,UAAU,GAAG,iBAAiB,GAAG,eAAe;AAEtD,WAAO;AAAA;AAAA,WAEA,OAAO;AAAA,MACZ,UAAU,YAAY,OAAO,eAAe,EAAE;AAAA,MAC9C,aAAa,eAAe,UAAU,kBAAkB,EAAE;AAAA,MAC1D,OAAO,aAAa,WAAW,aAAa,QAAQ,gBAAgB,EAAE;AAAA;AAAA,MAEtE,KAAA;AAAA,EACJ;AAEA,QAAM,cAAc,CAACA,oBACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOEA,gBAAe,IAAI,CAAA,UAAS,SAAS,KAAK,CAAC,EAAE,KAAK,EAAE,CAAC;AAAA;AAAA,MAErD,KAAA;AAEJ,QAAM,qBACJ,MAAM,QAAQ;AAAA,IACZ,OAAO,QAAQ,MAAM,EAAE,IAAI,OAAO,CAAC,IAAI,KAAK,MAAM;AAChD,UAAI,OAAO,OAAQ;AACnB,UAAI,CAAC,MAAO;AACZ,UAAI,EAAE,YAAY,OAAQ;AAC1B,YAAM,MAAM,MAAM;AAElB,YAAM,SAAS,IAAI;AACnB,UAAI,QAAQ,mBAAmB;AAC7B,eAAO,OAAO,kBAAkB,OAAO;AAAA,MACzC;AAEA,UAAI,EAAE,aAAa,KAAM;AAEzB,YAAM,gBAAgB,OAAO,EAAE;AAC/B,UAAI,CAAC,eAAe;AAClB,gBAAQ,KAAK,uCAAuC,EAAE,EAAE;AACxD;AAAA,MACF;AACA,UAAI,WAAW,cAAc;AAC7B,UAAI,SAAS,WAAW,OAAO,QAAQ,IAAI;AAE3C,UAAI;AACJ,UAAI,cAAc,MAAM;AACtB,eAAO,oBAAoB,cAAc,IAAI;AAAA,MAC/C,WAAW,cAAc,OAAO;AAC9B,eAAO;AAAA,MACT,OAAO;AACL;AAAA,MACF;AAEA,aAAO,QAAQ;AAEb,cAAM,aAAa,OAAO,OAAO,oBAAoB,OAAO,IAAI,IAAI;AACpE,eAAO,GAAG,UAAU,IAAI,IAAI;AAC5B,mBAAW,OAAO;AAClB,iBAAS,WAAW,OAAO,QAAQ,IAAI;AAAA,MACzC;AAGA,UAAI,KAAK,SAAS,GAAG,KAAK,KAAK,SAAS,GAAG,EAAG;AAC9C,UAAI,OAAO,OAAQ;AAEnB,YAAM,QAAsB,EAAE,OAAO,oBAAoB,IAAI,EAAA;AAC7D,aAAO;AAAA,IACT,CAAC;AAAA,EAAA,GAGF,KAAA,EACA,OAAO,YAAY;AAEtB,QAAM,iBAAsC,CAAA;AAC5C,aAAW,SAAS,mBAAmB;AACrC,UAAM,wBAAwB,eAAe,KAAK,OAAK,EAAE,UAAU,MAAM,KAAK;AAC9E,QAAI,CAAC,uBAAuB;AAC1B,qBAAe,KAAK,KAAK;AAAA,IAC3B;AAAA,EACF;AAEA,SAAO,YAAY,cAAc;AACnC;AAEA,SAAS,aAAa,OAAe,SAA4B;AAC/D,aAAW,WAAW,SAAS;AAC7B,QAAI,YAAY,MAAO,QAAO;AAE9B,QAAI,QAAQ,SAAS,GAAG,GAAG;AACzB,YAAM,eAAe,QAClB,QAAQ,sBAAsB,MAAM,EACpC,QAAQ,OAAO,IAAI;AAEtB,YAAM,QAAQ,IAAI,OAAO,IAAI,YAAY,GAAG;AAC5C,UAAI,MAAM,KAAK,KAAK,EAAG,QAAO;AAAA,IAChC;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,aAAgB,OAAkE;AACzF,SAAO,QAAQ,KAAK;AACtB;AAEA,SAAS,oBAAoB,GAAW;AACtC,SAAO,EAAE,SAAS,GAAG,IAAI,EAAE,MAAM,GAAG,EAAE,IAAI;AAC5C;"}