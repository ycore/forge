{"version":3,"file":"index.js","sources":["../../../src/result/core/result.ts","../../../src/intent/server/intent-action.ts"],"sourcesContent":["import type { AppError, Result } from '../@types/result.types';\nimport { isAppError } from '../@types/result.types';\n\n/**\n * Return a successful value directly\n * This is essentially a no-op but provides semantic clarity\n */\nexport function ok<T>(value: T): T {\n  return value;\n}\n\n/**\n * Create an AppError\n */\nexport function err(\n  message: string,\n  details?: Record<string, unknown>,\n  options?: {\n    cause?: Error | unknown;\n    code?: string;\n    status?: number;\n  }\n): AppError {\n  return {\n    message,\n    details,\n    cause: options?.cause,\n    code: options?.code,\n    status: options?.status,\n  };\n}\n\n/**\n * Check if a result is an error\n */\nexport function isError<T>(result: Result<T>): result is AppError {\n  return isAppError(result);\n}\n\n/**\n * Check if a result is successful (not an error)\n */\nexport function isOk<T>(result: Result<T>): result is T {\n  return !isAppError(result);\n}\n\n/**\n * Get the data from a result, or undefined if it's an error\n */\nexport function getData<T>(result: Result<T>): T | undefined {\n  return isError(result) ? undefined : result;\n}\n\n/**\n * Get the error from a result, or undefined if it's successful\n */\nexport function getError<T>(result: Result<T>): AppError | undefined {\n  return isError(result) ? result : undefined;\n}\n\n/**\n * Unwrap a result, throwing if it's an error\n */\nexport function unwrap<T>(result: Result<T>): T {\n  if (isError(result)) {\n    throw new Error(result.message);\n  }\n  return result;\n}\n\n/**\n * Unwrap a result or return a default value if it's an error\n */\nexport function unwrapOr<T>(result: Result<T>, defaultValue: T): T {\n  return isError(result) ? defaultValue : result;\n}\n\n/**\n * Map a successful result to a new value\n */\nexport function map<T, U>(result: Result<T>, fn: (value: T) => U): Result<U> {\n  return isError(result) ? result : fn(result);\n}\n\n/**\n * Map an error result to a new error\n */\nexport function mapError<T>(result: Result<T>, fn: (error: AppError) => AppError): Result<T> {\n  return isError(result) ? fn(result) : result;\n}\n\n/**\n * Chain operations on successful results\n */\nexport function andThen<T, U>(result: Result<T>, fn: (value: T) => Result<U>): Result<U> {\n  return isError(result) ? result : fn(result);\n}\n\n/**\n * Provide an alternative result if the first is an error\n */\nexport function orElse<T>(result: Result<T>, fn: () => Result<T>): Result<T> {\n  return isError(result) ? fn() : result;\n}\n\n/**\n * Convert a promise that might throw into a Result\n */\nexport async function tryCatch<T>(fn: () => Promise<T>, errorMessage?: string): Promise<Result<T>> {\n  try {\n    return await fn();\n  } catch (error) {\n    return err(errorMessage || 'Operation failed', undefined, { cause: error });\n  }\n}\n\n/**\n * Combine multiple results - returns first error or all values\n */\nexport function combine<T extends readonly Result<any>[]>(results: T): Result<{ [K in keyof T]: T[K] extends Result<infer U> ? U : never }> {\n  const values: any[] = [];\n\n  for (const result of results) {\n    if (isError(result)) {\n      return result;\n    }\n    values.push(result);\n  }\n\n  return values as any;\n}\n\n/**\n * Combine results into an object\n */\nexport function combineObject<T extends Record<string, Result<any>>>(results: T): Result<{ [K in keyof T]: T[K] extends Result<infer U> ? U : never }> {\n  const values: any = {};\n\n  for (const [key, result] of Object.entries(results)) {\n    if (isError(result)) {\n      return result;\n    }\n    values[key] = result;\n  }\n\n  return values;\n}\n","import type { IntentActionConfig, IntentHandlers, IntentResponse } from '../../@types/intent.types';\nimport type { AppError, Result } from '../../result/@types/result.types';\nimport { err } from '../../result/core/result';\n\n/**\n * Clones FormData by creating a new instance with all entries\n */\nfunction cloneFormData(formData: FormData): FormData {\n  const cloned = new FormData();\n  formData.forEach((value, key) => {\n    cloned.append(key, value);\n  });\n  return cloned;\n}\n\n/**\n * Executes an intent-based action handler from FormData\n */\nexport async function handleIntent<Handlers extends IntentHandlers>(formData: FormData, handlers: Handlers, config?: IntentActionConfig): Promise<Result<IntentResponse<Handlers>, AppError>> {\n  const fieldName = config?.fieldName ?? 'intent';\n  const intentValue = formData.get(fieldName);\n\n  const intentName = typeof intentValue === 'string' ? intentValue : null;\n\n  // Prepare FormData to pass to handlers (clone if requested)\n  const handlerFormData = config?.cloneFormData ? cloneFormData(formData) : formData;\n\n  if (intentName === null) {\n    if (config?.defaultHandler) {\n      return config.defaultHandler(handlerFormData) as Promise<Result<IntentResponse<Handlers>, AppError>>;\n    }\n    return err('Intent field is required', { field: fieldName, code: 'INTENT_MISSING' });\n  }\n\n  // Check if handler exists for the intent\n  const handler = handlers[intentName];\n\n  if (!handler) {\n    return err(`Unknown intent: ${intentName}`, {\n      field: fieldName,\n      intent: intentName,\n      availableIntents: Object.keys(handlers),\n      code: 'INTENT_NOT_FOUND',\n    });\n  }\n\n  return handler(handlerFormData) as Promise<Result<IntentResponse<Handlers>, AppError>>;\n}\n\n/**\n * Extracts the intent value from FormData\n */\nexport function getIntent(formData: FormData, fieldName = 'intent'): string | null {\n  const value = formData.get(fieldName);\n  return typeof value === 'string' ? value : null;\n}\n\n/**\n * Type guard to check if a FormData has a specific intent\n */\nexport function hasIntent(formData: FormData, intent: string, fieldName = 'intent'): boolean {\n  return getIntent(formData, fieldName) === intent;\n}\n"],"names":[],"mappings":"AAcO,SAAS,IACd,SACA,SACA,SAKU;AACV,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OAAO,SAAS;AAAA,IAChB,MAAM,SAAS;AAAA,IACf,QAAQ,SAAS;AAAA,EAAA;AAErB;ACvBA,SAAS,cAAc,UAA8B;AACnD,QAAM,SAAS,IAAI,SAAA;AACnB,WAAS,QAAQ,CAAC,OAAO,QAAQ;AAC/B,WAAO,OAAO,KAAK,KAAK;AAAA,EAC1B,CAAC;AACD,SAAO;AACT;AAKA,eAAsB,aAA8C,UAAoB,UAAoB,QAAkF;AAC5L,QAAM,YAAY,QAAQ,aAAa;AACvC,QAAM,cAAc,SAAS,IAAI,SAAS;AAE1C,QAAM,aAAa,OAAO,gBAAgB,WAAW,cAAc;AAGnE,QAAM,kBAAkB,QAAQ,gBAAgB,cAAc,QAAQ,IAAI;AAE1E,MAAI,eAAe,MAAM;AACvB,QAAI,QAAQ,gBAAgB;AAC1B,aAAO,OAAO,eAAe,eAAe;AAAA,IAC9C;AACA,WAAO,IAAI,4BAA4B,EAAE,OAAO,WAAW,MAAM,kBAAkB;AAAA,EACrF;AAGA,QAAM,UAAU,SAAS,UAAU;AAEnC,MAAI,CAAC,SAAS;AACZ,WAAO,IAAI,mBAAmB,UAAU,IAAI;AAAA,MAC1C,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,kBAAkB,OAAO,KAAK,QAAQ;AAAA,MACtC,MAAM;AAAA,IAAA,CACP;AAAA,EACH;AAEA,SAAO,QAAQ,eAAe;AAChC;AAKO,SAAS,UAAU,UAAoB,YAAY,UAAyB;AACjF,QAAM,QAAQ,SAAS,IAAI,SAAS;AACpC,SAAO,OAAO,UAAU,WAAW,QAAQ;AAC7C;AAKO,SAAS,UAAU,UAAoB,QAAgB,YAAY,UAAmB;AAC3F,SAAO,UAAU,UAAU,SAAS,MAAM;AAC5C;"}