{
  "version": 3,
  "sources": ["../../../src/result/core/result.ts", "../../../src/intent/server/intent-action.ts"],
  "sourcesContent": [
    "import type { AppError, Result } from '../@types/result.types';\nimport { isAppError } from '../@types/result.types';\n\n/**\n * Return a successful value directly\n * This is essentially a no-op but provides semantic clarity\n */\nexport function ok<T>(value: T): T {\n  return value;\n}\n\n/**\n * Create an AppError\n */\nexport function err(\n  message: string,\n  details?: Record<string, unknown>,\n  options?: {\n    cause?: Error | unknown;\n    code?: string;\n    status?: number;\n  }\n): AppError {\n  return {\n    message,\n    details,\n    cause: options?.cause,\n    code: options?.code,\n    status: options?.status,\n  };\n}\n\n/**\n * Check if a result is an error\n */\nexport function isError<T>(result: Result<T>): result is AppError {\n  return isAppError(result);\n}\n\n/**\n * Check if a result is successful (not an error)\n */\nexport function isOk<T>(result: Result<T>): result is T {\n  return !isAppError(result);\n}\n\n/**\n * Get the data from a result, or undefined if it's an error\n */\nexport function getData<T>(result: Result<T>): T | undefined {\n  return isError(result) ? undefined : result;\n}\n\n/**\n * Get the error from a result, or undefined if it's successful\n */\nexport function getError<T>(result: Result<T>): AppError | undefined {\n  return isError(result) ? result : undefined;\n}\n\n/**\n * Unwrap a result, throwing if it's an error\n */\nexport function unwrap<T>(result: Result<T>): T {\n  if (isError(result)) {\n    throw new Error(result.message);\n  }\n  return result;\n}\n\n/**\n * Unwrap a result or return a default value if it's an error\n */\nexport function unwrapOr<T>(result: Result<T>, defaultValue: T): T {\n  return isError(result) ? defaultValue : result;\n}\n\n/**\n * Map a successful result to a new value\n */\nexport function map<T, U>(result: Result<T>, fn: (value: T) => U): Result<U> {\n  return isError(result) ? result : fn(result);\n}\n\n/**\n * Map an error result to a new error\n */\nexport function mapError<T>(result: Result<T>, fn: (error: AppError) => AppError): Result<T> {\n  return isError(result) ? fn(result) : result;\n}\n\n/**\n * Chain operations on successful results\n */\nexport function andThen<T, U>(result: Result<T>, fn: (value: T) => Result<U>): Result<U> {\n  return isError(result) ? result : fn(result);\n}\n\n/**\n * Provide an alternative result if the first is an error\n */\nexport function orElse<T>(result: Result<T>, fn: () => Result<T>): Result<T> {\n  return isError(result) ? fn() : result;\n}\n\n/**\n * Convert a promise that might throw into a Result\n */\nexport async function tryCatch<T>(fn: () => Promise<T>, errorMessage?: string): Promise<Result<T>> {\n  try {\n    return await fn();\n  } catch (error) {\n    return err(errorMessage || 'Operation failed', undefined, { cause: error });\n  }\n}\n\n/**\n * Combine multiple results - returns first error or all values\n */\nexport function combine<T extends readonly Result<any>[]>(results: T): Result<{ [K in keyof T]: T[K] extends Result<infer U> ? U : never }> {\n  const values: any[] = [];\n\n  for (const result of results) {\n    if (isError(result)) {\n      return result;\n    }\n    values.push(result);\n  }\n\n  return values as any;\n}\n\n/**\n * Combine results into an object\n */\nexport function combineObject<T extends Record<string, Result<any>>>(results: T): Result<{ [K in keyof T]: T[K] extends Result<infer U> ? U : never }> {\n  const values: any = {};\n\n  for (const [key, result] of Object.entries(results)) {\n    if (isError(result)) {\n      return result;\n    }\n    values[key] = result;\n  }\n\n  return values;\n}\n",
    "import type { IntentActionConfig, IntentHandlers, IntentResponse } from '../../@types/intent.types';\nimport type { AppError, Result } from '../../result/@types/result.types';\nimport { err } from '../../result/core/result';\n\n/**\n * Clones FormData by creating a new instance with all entries\n */\nfunction cloneFormData(formData: FormData): FormData {\n  const cloned = new FormData();\n  formData.forEach((value, key) => {\n    cloned.append(key, value);\n  });\n  return cloned;\n}\n\n/**\n * Executes an intent-based action handler from FormData\n */\nexport async function handleIntent<Handlers extends IntentHandlers>(formData: FormData, handlers: Handlers, config?: IntentActionConfig): Promise<Result<IntentResponse<Handlers>, AppError>> {\n  const fieldName = config?.fieldName ?? 'intent';\n  const intentValue = formData.get(fieldName);\n\n  const intentName = typeof intentValue === 'string' ? intentValue : null;\n\n  // Prepare FormData to pass to handlers (clone if requested)\n  const handlerFormData = config?.cloneFormData ? cloneFormData(formData) : formData;\n\n  if (intentName === null) {\n    if (config?.defaultHandler) {\n      return config.defaultHandler(handlerFormData) as Promise<Result<IntentResponse<Handlers>, AppError>>;\n    }\n    return err('Intent field is required', { field: fieldName, code: 'INTENT_MISSING' });\n  }\n\n  // Check if handler exists for the intent\n  const handler = handlers[intentName];\n\n  if (!handler) {\n    return err(`Unknown intent: ${intentName}`, {\n      field: fieldName,\n      intent: intentName,\n      availableIntents: Object.keys(handlers),\n      code: 'INTENT_NOT_FOUND',\n    });\n  }\n\n  return handler(handlerFormData) as Promise<Result<IntentResponse<Handlers>, AppError>>;\n}\n\n/**\n * Extracts the intent value from FormData\n */\nexport function getIntent(formData: FormData, fieldName = 'intent'): string | null {\n  const value = formData.get(fieldName);\n  return typeof value === 'string' ? value : null;\n}\n\n/**\n * Type guard to check if a FormData has a specific intent\n */\nexport function hasIntent(formData: FormData, intent: string, fieldName = 'intent'): boolean {\n  return getIntent(formData, fieldName) === intent;\n}\n"
  ],
  "mappings": ";AAcO,SAAS,GAAG,CACjB,SACA,SACA,SAKU;AAAA,EACV,OAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OAAO,SAAS;AAAA,IAChB,MAAM,SAAS;AAAA,IACf,QAAQ,SAAS;AAAA,EACnB;AAAA;;;ACtBF,SAAS,aAAa,CAAC,UAA8B;AAAA,EACnD,MAAM,SAAS,IAAI;AAAA,EACnB,SAAS,QAAQ,CAAC,OAAO,QAAQ;AAAA,IAC/B,OAAO,OAAO,KAAK,KAAK;AAAA,GACzB;AAAA,EACD,OAAO;AAAA;AAMT,eAAsB,YAA6C,CAAC,UAAoB,UAAoB,QAAkF;AAAA,EAC5L,MAAM,YAAY,QAAQ,aAAa;AAAA,EACvC,MAAM,cAAc,SAAS,IAAI,SAAS;AAAA,EAE1C,MAAM,aAAa,OAAO,gBAAgB,WAAW,cAAc;AAAA,EAGnE,MAAM,kBAAkB,QAAQ,gBAAgB,cAAc,QAAQ,IAAI;AAAA,EAE1E,IAAI,eAAe,MAAM;AAAA,IACvB,IAAI,QAAQ,gBAAgB;AAAA,MAC1B,OAAO,OAAO,eAAe,eAAe;AAAA,IAC9C;AAAA,IACA,OAAO,IAAI,4BAA4B,EAAE,OAAO,WAAW,MAAM,iBAAiB,CAAC;AAAA,EACrF;AAAA,EAGA,MAAM,UAAU,SAAS;AAAA,EAEzB,IAAI,CAAC,SAAS;AAAA,IACZ,OAAO,IAAI,mBAAmB,cAAc;AAAA,MAC1C,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,kBAAkB,OAAO,KAAK,QAAQ;AAAA,MACtC,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,QAAQ,eAAe;AAAA;AAMzB,SAAS,SAAS,CAAC,UAAoB,YAAY,UAAyB;AAAA,EACjF,MAAM,QAAQ,SAAS,IAAI,SAAS;AAAA,EACpC,OAAO,OAAO,UAAU,WAAW,QAAQ;AAAA;AAMtC,SAAS,SAAS,CAAC,UAAoB,QAAgB,YAAY,UAAmB;AAAA,EAC3F,OAAO,UAAU,UAAU,SAAS,MAAM;AAAA;",
  "debugId": "441B6A5C2B3794AF64756E2164756E21",
  "names": []
}